<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写题</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E6%89%8B%E5%86%99%E9%A2%98/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E6%89%8B%E5%86%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数组原型常用方法实现"><a href="#数组原型常用方法实现" class="headerlink" title="数组原型常用方法实现"></a>数组原型常用方法实现</h2><h3 id="Array-prototype-every"><a href="#Array-prototype-every" class="headerlink" title="Array.prototype.every"></a>Array.prototype.every</h3><pre><code class="js">Array.prototype.every2 = function (callback) &#123;  for (let i = 0; i &lt; this.length; i++) &#123;    if (!callback(this[i], i, this)) &#123;      return false;    &#125;  &#125;  return true;&#125;;// examplevar arr = [  &#123; name: &quot;zhangsan&quot;, age: 20 &#125;,  &#123; name: &quot;lisi&quot;, age: 19 &#125;,  &#123; name: &quot;wangwu&quot;, age: 18 &#125;,  &#123; name: &quot;liliu&quot;, age: 21 &#125;];console.log(arr.every2(item =&gt; item.age &gt; 17));</code></pre><h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><pre><code class="js">Array.prototype.filter2 = function (callback) &#123;  let arr = [];  for (let i = 0; i &lt; this.length; i++) &#123;    if (callback(this[i], i, this)) &#123;      arr.push(this[i]);    &#125;  &#125;  return arr;&#125;;// examplevar arr = [  &#123; name: &quot;zhangsan&quot;, age: 20 &#125;,  &#123; name: &quot;lisi&quot;, age: 19 &#125;,  &#123; name: &quot;wangwu&quot;, age: 18 &#125;,  &#123; name: &quot;liliu&quot;, age: 21 &#125;];console.log(arr.filter2(item =&gt; item.age &gt; 19));console.log(arr.filter2(item =&gt; item.age &gt; 17));</code></pre><h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach"></a>Array.prototype.forEach</h3><pre><code class="js">Array.prototype.forEach2 = function (callback) &#123;  for (let i = 0; i &lt; this.length; i++) &#123;    callback(this[i], i, this);  &#125;&#125;;// examplevar arr = [1, 2, 3, 4];arr.forEach2((item, index) =&gt; &#123;  console.log(item, index);&#125;);</code></pre><h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><pre><code class="js">Array.prototype.map2 = function (callback) &#123;  let arr = [];  for (let i = 0; i &lt; this.length; i++) &#123;    arr.push(callback(this[i], i, this));  &#125;  return arr;&#125;;// examplevar arr = [  &#123; name: &quot;zhangsan&quot;, age: 20 &#125;,  &#123; name: &quot;lisi&quot;, age: 19 &#125;];console.log(arr.map2(item =&gt; item.name));console.log(arr.map2(item =&gt; item.age));</code></pre><h3 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some"></a>Array.prototype.some</h3><pre><code class="js">Array.prototype.some2 = function (callback) &#123;  let arr = [];  for (let i = 0; i &lt; this.length; i++) &#123;    arr.push(callback(this[i], i, this));  &#125;  return arr.indexOf(true) &gt; -1;&#125;;// examplevar arr = [  &#123; name: &quot;zhangsan&quot;, age: 20 &#125;,  &#123; name: &quot;lisi&quot;, age: 19 &#125;,  &#123; name: &quot;wangwu&quot;, age: 18 &#125;,  &#123; name: &quot;liliu&quot;, age: 21 &#125;];console.log(arr.some2(item =&gt; item.age === 22));console.log(arr.some2(item =&gt; item.age === 21));console.log(arr.some2(item =&gt; item.age &gt;= 19));</code></pre><h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><pre><code class="js">Array.prototype.reduce2 = function (callback, initValue) &#123;  if (!Array.isArray(this) || !this.length || typeof callback !== &quot;function&quot;) return [];  var hasInitValue = initValue !== undefined;  var val = hasInitValue ? initValue : this[0];  for (var i = hasInitValue ? 0 : 1; i &lt; this.length; i++) &#123;    val = callback(val, this[i], i, this);  &#125;  return val;&#125;;var arr = [  &#123; name: &quot;zhangsan&quot;, age: 20 &#125;,  &#123; name: &quot;lisi&quot;, age: 19 &#125;,  &#123; name: &quot;wangwu&quot;, age: 18 &#125;,  &#123; name: &quot;liliu&quot;, age: 21 &#125;];console.log(arr.reduce2((prev, cur) =&gt; prev + cur.age, 0));console.log(arr.reduce2((prev, cur) =&gt; [...prev, cur.name], []));</code></pre><h2 id="长列表虚拟滚动实现"><a href="#长列表虚拟滚动实现" class="headerlink" title="长列表虚拟滚动实现"></a>长列表虚拟滚动实现</h2><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;virtual-list&quot;&gt;    &lt;section class=&quot;container&quot; ref=&quot;container&quot; @scroll=&quot;scrollView&quot;&gt;      &lt;div class=&quot;scroll-bar&quot; ref=&quot;scrollBar&quot;&gt;&lt;/div&gt;      &lt;ul ref=&quot;list&quot; class=&quot;list&quot;&gt;        &lt;li v-for=&quot;item in showList&quot; :key=&quot;item&quot;&gt;          &#123;&#123; item &#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/section&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;App&quot;,  data() &#123;    return &#123;      list: [],      childHeight: 30,      maxCount: 10,      start: 0,      end: 10    &#125;;  &#125;,  mounted() &#123;    this.list = Array.from(&#123; length: 100000 &#125;, (k, v) =&gt; v);    // 计算滚动容器高度    this.$refs.container.style.height = this.childHeight * this.maxCount + &quot;px&quot;;    // 计算总的数据需要的高度，构造滚动条高度    this.$refs.scrollBar.style.height = this.childHeight * this.list.length + &quot;px&quot;;  &#125;,  computed: &#123;    showList() &#123;      return this.list.slice(this.start, this.end);    &#125;  &#125;,  methods: &#123;    scrollView() &#123;      let scrollTop = this.$refs.container.scrollTop;      this.start = Math.floor(scrollTop / this.childHeight);      this.end = this.start + this.maxCount;      this.$refs.list.style.top = this.start * this.childHeight + &quot;px&quot;;    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style&gt;.virtual-list &#123;  text-align: center;&#125;ul,li &#123;  list-style: none;&#125;.container &#123;  position: relative;  overflow: scroll;  border-bottom: 1px solid #ddd;&#125;.list &#123;  position: absolute;  width: 100%;  top: 0;  left: 0;  text-align: left;&#125;.list li &#123;  margin-bottom: 10px;  line-height: 1.5;  width: 100%;  border-bottom: 1px dashed #1890ff;  color: #52c41a;  font-weight: bold;&#125;&lt;/style&gt;</code></pre><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><pre><code class="jsx">import &#123; useState, useRef, useMemo, useEffect &#125; from &quot;react&quot;;import &quot;./styles.css&quot;;export default function App() &#123;  const containerRef = useRef();  const scrollBarRef = useRef();  const listRef = useRef();  const [list, setList] = useState([]);  const [options, setOptions] = useState(&#123;    childrenHeight: 30,    maxCount: 10,    start: 0,    end: 10  &#125;);  const sliceList = useMemo(() =&gt; &#123;    const &#123; start, end &#125; = options;    return list.slice(start, end);  &#125;, [list, options]);  useEffect(() =&gt; &#123;    const virtualList = Array.from(&#123; length: 10000 &#125;, (k, v) =&gt; v);    setList(virtualList);  &#125;, []);  useEffect(() =&gt; &#123;    const &#123; childrenHeight, maxCount &#125; = options;    containerRef.current.style.height = `$&#123;childrenHeight * maxCount&#125;px`;    scrollBarRef.current.style.height = `$&#123;childrenHeight * list.length&#125;px`;  &#125;, [list.length, options]);  const scrollView = () =&gt; &#123;    const &#123; childrenHeight, maxCount, start &#125; = options;    let scrollTop = containerRef.current.scrollTop;    const startIndex = Math.floor(scrollTop / childrenHeight);    setOptions(prevOptions =&gt; (&#123; ...prevOptions, start: startIndex &#125;));    const endIndex = startIndex + maxCount;    setOptions(prevOptions =&gt; (&#123; ...prevOptions, end: endIndex &#125;));    listRef.current.style.top = `$&#123;start * childrenHeight&#125;px`;  &#125;;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;section className=&quot;container&quot; ref=&#123;containerRef&#125; onScroll=&#123;scrollView&#125;&gt;        &lt;div className=&quot;scroll-bar&quot; ref=&#123;scrollBarRef&#125;&gt;&lt;/div&gt;        &lt;ul className=&quot;list&quot; ref=&#123;listRef&#125;&gt;          &#123;sliceList.map(item =&gt; (            &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;          ))&#125;        &lt;/ul&gt;      &lt;/section&gt;    &lt;/div&gt;  );&#125;</code></pre><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><pre><code class="js">class EventBus &#123;  constructor() &#123;    this.events = &#123;&#125;;    // 最大监听数量    // this.maxListeners = maxListeners || Infinity;  &#125;  // 触发  emit(event, ...args) &#123;    const cbs = this.events[event];    if (!cbs) &#123;      console.log(&quot;没有这个事件!&quot;);      return this;    &#125;    cbs.forEach(cb =&gt; cb.apply(this, args));    return this;  &#125;  // 监听  on(event, cb) &#123;    if (!this.events[event]) &#123;      this.events[event] = [];    &#125;    // TODO 拦截最大监听    // if (this.maxListeners !== Infinity &amp;&amp; this.events[event].length &gt;= this.maxListeners) &#123;    //   console.log(`当前事件$&#123;event&#125;超过最大监听数`);    //   return this;    // &#125;    this.events[event].push(cb);    return this; // 链式调用，则需要返回 this  &#125;  // 移除监听  off(event, cb) &#123;    if (!cb) &#123;      this.events[event] = null;    &#125; else &#123;      this.events[event] = this.events[event].filter(item =&gt; item !== cb);    &#125;    return this; // 链式调用，则需要返回 this  &#125;  // 只执行一次  once(event, cb) &#123;    const func = (...args) =&gt; &#123;      this.off(event, func);      cb.apply(this, args);    &#125;;    this.on(event, func);    return this;  &#125;&#125;// 测试const add = (a, b) =&gt; console.log(a + b);const log = (...args) =&gt; console.log(...args);const event = new EventBus();event.on(&quot;add&quot;, add);event.on(&quot;log&quot;, log);event.emit(&quot;add&quot;, 1, 2); // 3event.emit(&quot;log&quot;, &quot;hi&quot;); // hievent.off(&quot;add&quot;);event.emit(&quot;add&quot;, 1, 2); // Error: add event is not registeredevent.once(&quot;once&quot;, add);event.emit(&quot;once&quot;, 1, 2); // 3event.emit(&quot;once&quot;, 1, 2);event.emit(&quot;once&quot;, 1, 2);</code></pre><h2 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h2><pre><code class="js">const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;class Promise &#123;  constructor(executor) &#123;    // 状态    this.status = PENDING;    // success    this.value = undefined;    // error    this.reason = undefined;    // callback    this.onResolvedCallbackList = [];    this.onRejectedCallbackList = [];    // success cb    const resolve = value =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = FULFILLED;        this.value = value;        this.onResolvedCallbackList.forEach(fn =&gt; fn());      &#125;    &#125;;    // error cb    const reject = reason =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = FULFILLED;        this.reason = reason;        this.onRejectedCallbackList.forEach(fn =&gt; fn());      &#125;    &#125;;    // 捕获异常    try &#123;      executor(resolve, reject);    &#125; catch (err) &#123;      reject(err);    &#125;  &#125;  resolvePromise(promise, next, resolve, reject) &#123;    // 避免循环引用    if (next === promise) &#123;      return reject(new TypeError(&quot;Chaining cycle detected for promise #&lt;Promise&gt;&quot;));    &#125;    // 判断是否被调用过    let called;    // 判定类型    if ((next !== null &amp;&amp; typeof next === &quot;object&quot;) || typeof next === &quot;function&quot;) &#123;      try &#123;        if (typeof next.then === &quot;function&quot;) &#123;          const resolveArg = next =&gt; &#123;            if (called) return;            called = true;            this.resolvePromise(promise, next, resolve, reject);          &#125;;          const rejectArg = err =&gt; &#123;            if (called) return;            called = true;            this.resolvePromise(promise, next, resolve, reject);          &#125;;          // 改变作用域 context          next.then.call(next, resolveArg, rejectArg);        &#125; else &#123;          resolve(next);        &#125;      &#125; catch (err) &#123;        if (called) return;        called = true;        reject(err);      &#125;    &#125; else &#123;      // next 以参数执行 promise      reject(next);    &#125;  &#125;  then(onFulfilled, onRejected) &#123;    // 判断是否为函数, 不是则被忽略    onFulfilled =      typeof onFulfilled === &quot;funciton&quot;        ? onFulfilled        : function (val) &#123;            return val;          &#125;;    onRejected =      typeof onRejected === &quot;function&quot;        ? onRejected        : function (err) &#123;            throw new Error(err);          &#125;;    // 每次调用 then 都会返回新的 Promise    const promise = new Promise((resolve, reject) =&gt; &#123;      const resolveCb = () =&gt; &#123;        try &#123;          let next = onFulfilled(this.value);          this.resolvePromise(promise, next, resolve, reject);        &#125; catch (err) &#123;          reject(err);        &#125;      &#125;;      const rejectCb = () =&gt; &#123;        try &#123;          let next = onRejected(this.reason);          this.resolvePromise(promise, next, resolve, reject);        &#125; catch (err) &#123;          reject(err);        &#125;      &#125;;      if (this.status === FULFILLED) setTimeout(resolveCb, 0);      if (this.status === REJECTED) setTimeout(rejectCb, 0);      if (this.status === PENDING) &#123;        this.onResolvedCallbackList.push(resolveCb);        this.onRejectedCallbackList.push(rejectCb);      &#125;    &#125;);    return promise;  &#125;  catch(cb) &#123;    return this.then(null, cb);  &#125;  static resolve(value) &#123;    if (value instanceof Promsie) return value;    return new Promise((resolve, reject) =&gt; resolve(value));  &#125;  static reject(reason) &#123;    return new Promise((_, reject) =&gt; reject(reason));  &#125;  /**   * @desc 成功返回 list, 失败返回最先失败的结果   */  static all(promiseList) &#123;    let index = 0,      result = [];    return new Promise((resolve, reject) =&gt; &#123;      let len = promiseList.length;      for (let i = 0; i &lt; len; i++) &#123;        let item = promiseList[i];        Promise.resolve(item).then(          value =&gt; &#123;            index++;            result[i] = value;            if (index === len) &#123;              return resolve(result);            &#125;          &#125;,          err =&gt; reject(err)        );      &#125;    &#125;);  &#125;  /**   * @desc 哪个跑得快先返回哪个，无论成功/失败   */  static race(promiseList) &#123;    return new Promise((resolve, reject) =&gt; &#123;      let len = promiseList.length;      for (let i = 0; i &lt; len; i++) &#123;        let item = promiseList[i];        Promise.resolve(item).then(          value =&gt; reoslve(value),          err =&gt; reject(err)        );      &#125;    &#125;);  &#125;  /**   * @desc 不管成功 or 失败，会等所有实例都返回结果   */  static allSettled(promiseList) &#123;    return new Promise((resolve, reject) =&gt; &#123;      let len = promiseList.length;      for (let i = 0; i &lt; len; i++) &#123;        let item = promiseList[i];        Promise.resolve(item).then(          value =&gt; &#123;            result.push(&#123; status: &quot;fulfilled&quot;, value &#125;);            if (result.length === len) return resolve(result);          &#125;,          err =&gt; &#123;            result.push(&#123; status: &quot;rejected&quot;, reason: err &#125;);            if (result.length === len) return reject(result);          &#125;        );      &#125;    &#125;);  &#125;  /**   * @desc 全部失败才会失败，有一个成功则返回第一个成功的实例   */  static any(promiseList) &#123;    let index = 0;    return new Promise((resolve, reject) =&gt; &#123;      let len = promiseList.length;      if (len === 0) return;      for (let i = 0; i &lt; len; i++) &#123;        let item = promiseList[i];        Promise.resolve(item).then(          value =&gt; resolve(value),          err =&gt; &#123;            index++;            if (index === len) return reject(new Error(&quot;All promises were rejected&quot;));          &#125;        );      &#125;    &#125;);  &#125;&#125;console.log(4);Promise.resolve()  .then(() =&gt; &#123;    console.log(1);    setTimeout(() =&gt; &#123;      console.log(3);    &#125;, 0);  &#125;)  .then(() =&gt; &#123;    console.log(2);  &#125;);setTimeout(() =&gt; &#123;  console.log(5);&#125;, 0);</code></pre><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖和节流对比"><a href="#防抖和节流对比" class="headerlink" title="防抖和节流对比"></a>防抖和节流对比</h3><ul><li>防抖</li></ul><blockquote><p>设置了固定时间触发的时候，在触发高频事件后如果达到了设置的时间间隔，将执行一次，如果在设置的时间间隔内再次触发就会重新计算时间。</p></blockquote><blockquote><p>常用场景: input 输入</p></blockquote><ul><li>节流</li></ul><blockquote><p>设置了固定时间触发的时候，在触发高频事件过程中如果达到了设置的时间间隔，将执行一次。</p></blockquote><blockquote><p>常用场景: resize scroll 等一定会触发的高频率时间中</p></blockquote><ul><li>两者对比</li></ul><blockquote><p>防抖是最后一个执行事件才会触发函数，节流在一定时间内会触发函数。</p></blockquote><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><ul><li>简单版</li></ul><pre><code class="js">function shallowDebounce(func, wait) &#123;  let timeout;  return function (...args) &#123;    let context = this;    if (timeout) clearTimeout(timeout);    timeout = setTimeout(function () &#123;      func.apply(context, args);    &#125;, wait);  &#125;;&#125;</code></pre><ul><li>复杂版</li></ul><pre><code class="js">function debounce(func, wait, immediate) &#123;  let timeout = null;  let fn = function (...args) &#123;    let context = this;    if (timeout) clearTimeout(timeout);    if (immediate) &#123;      let callNow = !timeout;      timeout = setTimeout(function () &#123;        timeout = null;      &#125;, wait);      if (callNow) &#123;        func.apply(context, args);      &#125;    &#125; else &#123;      timeout = setTimeout(function () &#123;        func.apply(context, args);      &#125;, wait);    &#125;  &#125;;  fn.cancel = function () &#123;    clearTimeout(timeout);    timeout = null;  &#125;;  return fn;&#125;</code></pre><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><ul><li>简单版</li></ul><pre><code class="js">// 第一次立即执行, 时间戳法function shallowThrottle(func, wait) &#123;  let previous = 0;  return function (...args) &#123;    let now = +new Date();    let context = this;    if (now - previous &gt; wait) &#123;      func.apply(context, args);      previous = now;    &#125;  &#125;;&#125;// 第一次不立即执行，定时器法function shallowThrottle(func, wait) &#123;  let timer = null;  return function () &#123;    let context = this;    let args = arguments;    if (!timer) &#123;      timer = setTimeout(function () &#123;        func.apply(context, args);        timer = null;      &#125;, wait);    &#125;  &#125;;&#125;// 结合时间戳法和定时器法，保证第一次和最后一次都执行function shallowThrottle(func, wait) &#123;  let timer = null;  let startTime = Date.now();  return function () &#123;    let currentTime = Date.now();    let remainningTime = wait - (currentTime - startTime);    let context = this;    let args = arguments;    clearTimeout(timer);    if (remainning &lt;= 0) &#123;      func.apply(context, args);      startTime = Date.now();    &#125; else &#123;      timer = setTimeout(func, remaining);    &#125;  &#125;;&#125;</code></pre><ul><li>复杂版</li></ul><pre><code class="js">/** * @desc leading 立即执行一次 * @desc trailing 执行结束后是否再执一次 */function throttle(func, wait, leading = true, trailing = true) &#123;  let timeout = null,    previous = 0;  let fn = function (...args) &#123;    let now = +new Date();    let context = this;    if (!previous &amp;&amp; !leading) previous = now;    // 剩余时间    let remaining = wait - (now - previous);    if (timeout) &#123;      clearTimeout(timeout);      timeout = null;    &#125; else &#123;      if (remaining &lt;= 0 || remaining &gt; wait) &#123;        previous = now;        func.apply(context, args);      &#125; else if (!timeout &amp;&amp; trailing) &#123;        timeout = setTimeout(function () &#123;          previous = !leading ? 0 : +new Date();          timeout = null;          func.apply(context, args);        &#125;, remaining);      &#125;    &#125;  &#125;;  fn.cancel = function () &#123;    clearTimeout(timeout);    previous = 0;    timeout = null;  &#125;;  return fn;&#125;</code></pre><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="利用-filter-indexOf-去重"><a href="#利用-filter-indexOf-去重" class="headerlink" title="利用 filter + indexOf 去重"></a>利用 filter + indexOf 去重</h3><pre><code class="js">const arr = [1, 2, 3, 4, 4, 3, 65, 16, 24, null, undefined, undefined];const filter = arr.filter((item, index, array) =&gt; array.indexOf(item) === index);console.log(filter);</code></pre><h3 id="利用-reduce-includes-去重"><a href="#利用-reduce-includes-去重" class="headerlink" title="利用 reduce + includes 去重"></a>利用 reduce + includes 去重</h3><pre><code class="js">const arr = [1, 2, 3, 4, 4, 3, 65, 16, 24, null, undefined, undefined];const filter = arr.reduce((prev, cur) =&gt; (prev.includes(cur) ? prev : [...prev, cur]), []);console.log(filter);</code></pre><h3 id="利用-Set-数据结构去重"><a href="#利用-Set-数据结构去重" class="headerlink" title="利用 Set 数据结构去重"></a>利用 Set 数据结构去重</h3><pre><code class="js">const arr = [1, 2, 3, 4, 4, 3, 65, 16, 24, null, undefined, undefined];const filter = Array.from(new Set(arr));console.log(filter);</code></pre><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><pre><code class="js">const arr = [1, [2, [3]]];const flatten = arr =&gt; &#123;  let result = [];  for (let i = 0; i &lt; arr.length; i++) &#123;    if (arr[i] &amp;&amp; arr[i].length) &#123;      result = result.concat(flatten(arr[i]));    &#125; else &#123;      result.push(arr[i]);    &#125;  &#125;  return result;&#125;;console.log(flatten(arr));</code></pre><h3 id="利用-while-实现"><a href="#利用-while-实现" class="headerlink" title="利用 while 实现"></a>利用 while 实现</h3><pre><code class="js">const arr = [1, [2, [3]]];const flatten = arr =&gt; &#123;  while (arr.some(item =&gt; Array.isArray(item))) &#123;    arr = [].concat(...arr);  &#125;  return arr;&#125;;console.log(flatten(arr));</code></pre><h3 id="利用-reduce-实现"><a href="#利用-reduce-实现" class="headerlink" title="利用 reduce 实现"></a>利用 reduce 实现</h3><pre><code class="js">const arr = [1, [2, [3]]];const flatten = arr =&gt; &#123;  return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? flatten(cur) : cur), []);&#125;;console.log(flatten(arr));</code></pre><h2 id="函数柯理化"><a href="#函数柯理化" class="headerlink" title="函数柯理化"></a>函数柯理化</h2><blockquote><p>使函数从一次调用传入多个参数变成多次调用每次传一个参数</p></blockquote><pre><code class="js">function curry(fn) &#123;  const judge = (...args) =&gt; &#123;    if (args.length === fn.length) return fn(...args);    return (...arg) =&gt; judge(...args, ...arg);  &#125;;  return judge;&#125;function add(a, b, c) &#123;  return a + b + c;&#125;let addCurry = curry(add);console.log(addCurry(1)(2)(3));</code></pre><h2 id="解析-url-参数"><a href="#解析-url-参数" class="headerlink" title="解析 url 参数"></a>解析 url 参数</h2><pre><code class="js">function getParams(url) &#123;  const str = /.+\?(.+)$/.exec(url)[1];  const arr = str.split(&quot;&amp;&quot;);  let obj = &#123;&#125;;  arr.forEach(item =&gt; &#123;    if (/=/.test(item)) &#123;      let [key, value] = item.split(&quot;=&quot;);      value = decodeURIComponent(value);      value = /^\d+$/.test(value) ? parseFloat(value) : value;      if (obj.hasOwnProperty(key)) &#123;        obj[key] = [].concat(obj[key], value);      &#125; else if (typeof value === &quot;string&quot; &amp;&amp; value.split(&quot;,&quot;).length &gt; 1) &#123;        obj[key] = value.split(&quot;,&quot;);      &#125; else &#123;        obj[key] = value;      &#125;    &#125; else &#123;      obj[item] = ture;    &#125;    return obj;  &#125;);&#125;console.log(getParams(&quot;https://www.baidu.com?name=1&amp;age=20&amp;hobby=1,2,3&amp;name=2&amp;name=3&quot;));</code></pre><h2 id="实现-new-关键字"><a href="#实现-new-关键字" class="headerlink" title="实现 new 关键字"></a>实现 new 关键字</h2><blockquote><p>新对象需要能够访问到构造函数的属性，因此需重新指定它的原型</p></blockquote><pre><code class="js">function ObjectFactory() &#123;  let constructor = [].shift.call(arguments);  let obj = &#123;&#125;;  obj.__proto__ = constructor.prototype;  constructor.apply(obj, arguments);  return obj;&#125;function Person(name, age) &#123;  this.name = name;  this.age = age;&#125;let person = ObjectFactory(Person, &quot;zhangsan&quot;, 12);console.log(person);</code></pre><h2 id="实现-jsonp"><a href="#实现-jsonp" class="headerlink" title="实现 jsonp"></a>实现 jsonp</h2><pre><code class="js">const jsonp = (&#123; url, params, callback &#125;) =&gt; &#123;  const generateUrl = () =&gt; &#123;    let dataSrc = &quot;&quot;;    for (let key in params) &#123;      if (params.hasOwnProperty(key)) &#123;        dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`;      &#125;    &#125;    dataSrc += `callback=$&#123;callback&#125;`;    return `$&#123;url&#125;?$&#123;dataSrc&#125;`;  &#125;;  return new Promise((resolve, reject) =&gt; &#123;    const scriptElement = document.createElement(&quot;script&quot;);    scriptElement.src = generateUrl();    document.body.appendChild(scriptElement);    window.callback = data =&gt; &#123;      resolve(data);      document.removeChild(scriptElement);    &#125;;  &#125;);&#125;;</code></pre><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><pre><code class="js">function shallowCopy(obj) &#123;  let newObj = obj instanceof Array ? [] : &#123;&#125;;  for (let key in obj) &#123;    if (obj.hasOwnproperty(key)) &#123;      newObj[key] = obj[key];    &#125;  &#125;  return newObj;&#125;let obj1 = &#123;  a: 1,  b: 2,  c: &#123;    d: 3  &#125;&#125;;let obj2 = shallowCopy(obj1);obj2.a = 3;obj2.c.d = 4;console.log(obj1.a); // 1console.log(obj2.a); // 3console.log(obj1.c.d); // 4console.log(obj2.c.d); // 4</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre><code class="js">/** * @desc 只考虑普通对象属性，不考虑内置对象和函数。 */function deepCopy(obj) &#123;  let newObj = Array.isArray(obj) ? [] : &#123;&#125;;  if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123;    for (let key in obj) &#123;      if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;        newObj[key] = deepClone(obj[key]);      &#125; else &#123;        newObj[key] = obj[key];      &#125;    &#125;  &#125;  return newObj;&#125;let obj1 = &#123;  a: 1,  b: 2,  c: &#123;    d: 3  &#125;&#125;;let obj2 = deepClone(obj1);obj2.a = 3;obj2.c.d = 4;console.log(obj1.a); // 1console.log(obj2.a); // 3console.log(obj1.c.d); // 3console.log(obj2.c.d); // 4</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><blockquote><p>为了解决组合式继承调用两次构造函数的问题<br>解决方案:<br>不直接调用父类构造函数给子类原型赋值, 而是通过创建空函数 F 获取父类原型的副本</p></blockquote><pre><code class="js">function Animal(name) &#123;  this.name = name;  this.colors = [&quot;black&quot;, &quot;white&quot;];&#125;Animal.prototype.getName = function () &#123;  return this.name;&#125;;function Dog(name, age) &#123;  Animal.call(this, name);  this.age = age;&#125;// Dog.prototype = new Animal();// Dog.prototype.constructor = Dog;// 最简单的替换Dog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;let dog1 = new Dog(&quot;奶昔&quot;, 2);dog1.colors.push(&quot;yellow&quot;);let dog2 = new Dog(&quot;奶茶&quot;, 1);console.log(dog2);</code></pre><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><blockquote><p>解决了原型链继承的 2 个问题: 引用类型共享问题、传参问题<br>问题:<br>方法都定义在构造函数中，无法复用；每次创建子类实例都会重新创建一边方法，性能问题。</p></blockquote><pre><code class="js">function Animal() &#123;  this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];  this.getColors = function () &#123;    return this.colors;  &#125;;&#125;function Dog() &#123;  Animal.call(this);&#125;let dog1 = new Dog();dog1.colors.push(&quot;white&quot;);console.log(dog1.getColors());let dog2 = new Dog();console.log(dog2.getColors());</code></pre><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><blockquote><p>问题:<br>原型包含的引用类型的属性将被所有实例共享<br>子类实例化时不能给父类构造函数传递参数</p></blockquote><pre><code class="js">function Animal() &#123;  this.colors = [&quot;black&quot;, &quot;white&quot;];&#125;Animal.prototype.getColor = function () &#123;  return this.colors;&#125;;function Dog() &#123;&#125;Dog.prototype = new Animal();let dog1 = new Dog();dog1.colors.push(&quot;yellow&quot;);let dog2 = new Dog();console.log(dog2.colors);</code></pre><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><blockquote><p>问题:<br>调用了两次构造函数 new 和 Animal.call</p></blockquote><pre><code class="js">// 结合原型链和借用构造函数function Animal(name) &#123;  this.name = name;  this.colors = [&quot;black&quot;, &quot;white&quot;];&#125;Animal.prototype.getName = function () &#123;  return this.name;&#125;;function Dog(name, age) &#123;  Animal.call(this, name);  this.age = age;&#125;Dog.prototype = new Animal();Dog.prototype.constructor = Dog;let dog1 = new Dog(&quot;奶昔&quot;, 2);dog1.colors.push(&quot;yellow&quot;);let dog2 = new Dog(&quot;奶茶&quot;, 1);console.log(dog2);</code></pre><h3 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h3><pre><code class="js">class Animal &#123;  constructor(name) &#123;    this.name = name;    this.colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];  &#125;  getName() &#123;    return this.name;  &#125;&#125;class Dog extends Animal &#123;  constructor(name, age) &#123;    super(name);    this.age = age;  &#125;&#125;let dog1 = new Dog(&quot;奶昔&quot;, 2);dog1.colors.push(&quot;yellow&quot;);let dog2 = new Dog(&quot;奶茶&quot;, 1);console.log(dog2);</code></pre><h2 id="使用-setTimeout-模拟-setInterval"><a href="#使用-setTimeout-模拟-setInterval" class="headerlink" title="使用 setTimeout 模拟 setInterval"></a>使用 setTimeout 模拟 setInterval</h2><pre><code class="js">function mySetInterval(fn, timeout) &#123;  let timer = &#123; flag: true &#125;;  function interval() &#123;    if (timer.flag) &#123;      fn();      setTimeout(interval, timeout);    &#125;    setTimeout(interval, timeout);    return timer;  &#125;&#125;</code></pre><h2 id="异步串行输出"><a href="#异步串行输出" class="headerlink" title="异步串行输出"></a>异步串行输出</h2><blockquote><p>实现 createFlow 按照 a, b, 延时 1s, c, 延时 1s, d, e, done 顺序打印</p></blockquote><pre><code class="js">const log = console.log;const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));const subFlow = createFlow([() =&gt; delay(1000).then(() =&gt; log(&quot;c&quot;))]);createFlow([() =&gt; log(&quot;a&quot;), () =&gt; log(&quot;b&quot;), subFlow, [() =&gt; delay(1000).then(() =&gt; log(&quot;d&quot;)), () =&gt; log(&quot;e&quot;)]]).run(() =&gt; &#123;  log(&quot;done&quot;);&#125;);function createFlow(iterator = []) &#123;  return &#123;    run(cb = () =&gt; &#123;&#125;) &#123;      return [...iterator, cb].reduce((prev, cur) =&gt; &#123;        return prev.then(Array.isArray(cur) ? createFlow(cur).run : cur.hasOwnProperty(&quot;run&quot;) ? cur.run : cur);      &#125;, Promise.resolve());    &#125;  &#125;;&#125;</code></pre><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h3 id="如果一段-js-执行时间非常长，怎么去分析"><a href="#如果一段-js-执行时间非常长，怎么去分析" class="headerlink" title="如果一段 js 执行时间非常长，怎么去分析"></a>如果一段 js 执行时间非常长，怎么去分析</h3><blockquote><p>利用装饰器打印某个方法的执行时间</p></blockquote><h3 id="阿里云-oss-支持通过链接后面拼参数来做图片的格式转换，尝试写一下把任意图片格式转换为-webp"><a href="#阿里云-oss-支持通过链接后面拼参数来做图片的格式转换，尝试写一下把任意图片格式转换为-webp" class="headerlink" title="阿里云 oss 支持通过链接后面拼参数来做图片的格式转换，尝试写一下把任意图片格式转换为 webp"></a>阿里云 oss 支持通过链接后面拼参数来做图片的格式转换，尝试写一下把任意图片格式转换为 webp</h3><blockquote><p>需要注意 webp 的兼容性</p></blockquote><pre><code class="js">function checkWebp() &#123;  try &#123;    return document.createElement(&quot;canvas&quot;).toDataURL(&quot;image/webp&quot;).indexOf(&quot;data:image/webp&quot;) === 0;  &#125; catch (e) &#123;    return false;  &#125;&#125;const supportWebp = checkWebp();export function getWebpImageUrl(url) &#123;  // 边界条件: url 是否为空  if (!url) &#123;    throw new Error(&quot;url 不能为空&quot;);  &#125;  // 边界条件: base64  if (url.startWith(&quot;data:&quot;)) &#123;    return url;  &#125;  // 边界条件: 浏览器是否支持 webp  if (!supportWebp) &#123;    return url;  &#125;  return url + &quot;?x-oss-processxxx&quot;;&#125;</code></pre><h3 id="如果有巨量的图片需要展示，除了懒加载的方式，有没有其他方法限制一下同时加载的图片数量"><a href="#如果有巨量的图片需要展示，除了懒加载的方式，有没有其他方法限制一下同时加载的图片数量" class="headerlink" title="如果有巨量的图片需要展示，除了懒加载的方式，有没有其他方法限制一下同时加载的图片数量"></a>如果有巨量的图片需要展示，除了懒加载的方式，有没有其他方法限制一下同时加载的图片数量</h3><blockquote><p>代码题，实现 promise 的并发控制</p></blockquote><pre><code class="js">function limitLoad(urls, handler, limit) &#123;  const sequence = [].cancat(urls);  let promises = [];  promises = sequence.splice(0, limit).map((url, index) =&gt; &#123;    return handler(url).then(() =&gt; &#123;      // 哪一个执行完了      return index;    &#125;);  &#125;);  let p = Promise.race(promises);  for (let i = 0; i &lt; sequence.length; i++) &#123;    p = p.then(res =&gt; &#123;      promises[res] = handler(sequence[i]).then(() =&gt; &#123;        return res;      &#125;);      return Promise.race(promises);    &#125;);  &#125;&#125;// 设置要执行的任务function loadImage(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    console.log(&quot;---&quot; + url.info + &quot; start!&quot;);    setTimeout(() =&gt; &#123;      console.log(url.info + &quot; OK!!!&quot;);      resolve();    &#125;, url.time);  &#125;);&#125;limitLoad(urls, loadImage, 3);</code></pre><h3 id="实现-sizeof-函数，传入一个参数-object-计算这个-object-占用的多少-bytes"><a href="#实现-sizeof-函数，传入一个参数-object-计算这个-object-占用的多少-bytes" class="headerlink" title="实现 sizeof 函数，传入一个参数 object, 计算这个 object 占用的多少 bytes"></a>实现 sizeof 函数，传入一个参数 object, 计算这个 object 占用的多少 bytes</h3><pre><code class="js">const testData = &#123;  a: 111,  b: &quot;ccc&quot;,  2222: false&#125;;// number: 8 字节// string: 每个长度 2 字节// boolean: 4 字节// 存储已经计算过的内存，避免相同引用造成的问题const seen = new WeakSet();function sizeOfObject(object) &#123;  if (object === null) &#123;    return 0;  &#125;  let bytes = 0;  // 对象里的 key 也是占用内存  const properties = Object.keys(object);  for (let i = 0; i &lt; properties.length; i++) &#123;    const key = properties[i];    bytes += calculator(key);    if (typeof object[key] === &quot;object&quot; &amp;&amp; object[key] !== null) &#123;      if (seen.has(object[key])) &#123;        // 坑点，key 一定要被算上, 因此 bytes += calculator(key); 要放到前面        continue;      &#125;      seen.add(object[key]);    &#125;    bytes += calculator(object[key]);  &#125;  return bytes;&#125;function calculator(object) &#123;  const objectType = typeof object;  switch (objectType) &#123;    case &quot;string&quot;:      return object.length * 2;    case &quot;boolean&quot;:      return 4;    case &quot;number&quot;:      return 8;    case &quot;object&quot;:      if (Array.isArray(object)) &#123;        // 递归处理数组        return object.map(calculator).reduce((pre, cur) =&gt; pre + cur, 0);      &#125; else &#123;        // 对对象的处理        return sizeOfObject(object);      &#125;    default:      return 0;  &#125;&#125;</code></pre><h3 id="给-xhr-添加-hook-实现在各个阶段打印日志"><a href="#给-xhr-添加-hook-实现在各个阶段打印日志" class="headerlink" title="给 xhr 添加 hook, 实现在各个阶段打印日志"></a>给 xhr 添加 hook, 实现在各个阶段打印日志</h3><blockquote><p>重写 xhr 的属性和方法</p></blockquote><pre><code class="js">class XhrHook &#123;  constructor(beforeHooks = &#123;&#125;, afterHooks = &#123;&#125;) &#123;    this.XHR = window.XMLHttpRequest;    this.beforeHooks = beforeHooks;    this.afterHooks = afterHooks;    this.init();  &#125;  init() &#123;    let _this = this;    // 此处不用箭头函数的问题是因为 this 指向问题，因为实例化后需要指向新构造出的实例上    window.XMLHttpRequest = function () &#123;      this._xhr = new _this.XHR();      _this.overwrite(this);    &#125;;  &#125;  overwrite(proxyXHR) &#123;    for (let key in proxyXHR._xhr) &#123;      if (typeof proxyXHR._xhr[key] === &quot;function&quot;) &#123;        this.overwriteMethod(key, proxyXHR);        continue;      &#125;      this.overwriteAttributes(key, proxyXHR);    &#125;  &#125;  // 重写方法  overwriteMethod(key, proxyXHR) &#123;    let beforeHooks = this.beforeHooks; // 我们应该可以拦截原有行为    let afterHooks = this.afterHooks;    proxyXHR[key] = (...args) =&gt; &#123;      // 拦截      if (beforeHooks[key]) &#123;        const res = beforeHooks[key].call(proxyXHR, args);        if (res === false) &#123;          return;        &#125;      &#125;      const res = proxyXHR._xhr[key].apply(proxyXHR._xhr, args);      afterHooks[key] &amp;&amp; afterHooks[key].call(proxyXHR._xhr, res);      return res;    &#125;;  &#125;  // 重写属性  overwriteAttributes(key, proxyXHR) &#123;    Object.defineProperties(proxyXHR, key, this.setPropertyDescriptor(key, proxyXHR));  &#125;  setPropertyDescriptor(key, proxyXHR) &#123;    let obj = Object.create(null); // 得到一个非常干净的对象    let _this = this;    obj.set = function (val) &#123;      if (!key.startsWith(&quot;on&quot;)) &#123;        proxyXHR[&quot;__&quot; + key] = val;        return;      &#125;      if (_this.beforeHooks[key]) &#123;        this._xhr[key] = function (...args) &#123;          _this.beforeHooks[key].call(proxyXHR);          val.apply(proxyXHR, args);        &#125;;        return;      &#125;      this._xhr[key] = val;    &#125;;    obj.get = function () &#123;      return proxyXHR[&quot;__&quot; + key] || this._xhr[key];    &#125;;    return obj;  &#125;&#125;</code></pre><h2 id="简易版-Vue-实现"><a href="#简易版-Vue-实现" class="headerlink" title="简易版 Vue 实现"></a>简易版 Vue 实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="1-index-html-主页面"><a href="#1-index-html-主页面" class="headerlink" title="1, index.html 主页面"></a>1, index.html 主页面</h4><h4 id="2-vue-js-Vue-主文件"><a href="#2-vue-js-Vue-主文件" class="headerlink" title="2. vue.js Vue 主文件"></a>2. vue.js Vue 主文件</h4><pre><code class="js">// vue.jsimport Observer from &quot;./observer.js&quot;;import Compiler from &quot;./compiler.js&quot;;/** * 包括 vue 构造函数，接收各种配置参数等 */export default class Vue &#123;  constructor(options = &#123;&#125;) &#123;    this.$options = options;    this.$data = options.data;    this.$methods = options.methods;    this.initRootElement(options);    this._proxyData(this.$data);    // 实例化 Observer 对象，监听数据变化    new Observer(this.$data);    // 实例化 Compiler 对象，解析指令和模版表达式    new Compiler(this);  &#125;  /**   * 获取根元素，并存储到 vue 实例，简单检查一下传入的 el 是否合规   */  initRootElement(options) &#123;    if (typeof options.el === &quot;string&quot;) &#123;      // id / class      this.$el = document.querySelector(options.el);    &#125; else if (options.el instanceof HTMLElement) &#123;      this.$el = options.el;    &#125;    if (!this.$el) &#123;      throw new Error(&quot;传入的 el 不合法, 请传入 css selector 或 HTMLElement&quot;);    &#125;  &#125;  /**   * 利用 Object.defineProxy 将 data 的属性注入到 vue 实例中   */  _proxyData(data) &#123;    Object.keys(data).forEach(key =&gt; &#123;      Object.defineProperty(this, key, &#123;        enumerable: true,        configurable: true,        get() &#123;          return data[key];        &#125;,        set(newVal) &#123;          if (data[key] === newVal) &#123;            return;          &#125;          data[key] = newVal;        &#125;      &#125;);    &#125;);  &#125;&#125;</code></pre><h4 id="3-compiler-js-解析模版，解析指令，如-v-model-v-html"><a href="#3-compiler-js-解析模版，解析指令，如-v-model-v-html" class="headerlink" title="3. compiler.js 解析模版，解析指令，如 v-model v-html"></a>3. compiler.js 解析模版，解析指令，如 v-model v-html</h4><pre><code class="js">// compiler.jsimport Watcher from &quot;./watcher.js&quot;;export default class Compiler &#123;  constructor(vm) &#123;    this.el = vm.$el;    this.vm = vm;    this.methods = vm.$methods;    this.compile(vm.$el);  &#125;  /** 编译模版  */  compile(el) &#123;    const childNodes = el.childNodes;    Array.from(childNodes).forEach(node =&gt; &#123;      if (this.isTextNode(node)) &#123;        // 文本节点        this.compileText(node);      &#125; else if (this.isElementNode(node)) &#123;        // 元素节点        this.compileElement(node);      &#125;      // 有子节点，递归调用      if (node.childNodes &amp;&amp; node.childNodes.length &gt; 0) &#123;        this.compile(node);      &#125;    &#125;);  &#125;  compileText(node) &#123;    // &#123;&#123; msg &#125;&#125;    const reg = /\&#123;\&#123;(.+?)\&#125;\&#125;/;    const value = node.textContent;    if (reg.test(value)) &#123;      // 匹配 msg      const key = RegExp.$1.trim();      node.textContent = value.replace(reg, this.vm[key]);      // 用来响应式的展示      new Watcher(this.vm, key, newValue =&gt; &#123;        node.textContent = newValue;      &#125;);    &#125;  &#125;  compileElement(node) &#123;    if (node.attributes.length) &#123;      Array.from(node.attributes).forEach(attr =&gt; &#123;        // 遍历元素节点的所有属性        const attrName = attr.name; // v-model v-html v-on:click        if (this.isDirective(attrName)) &#123;          let directiveName = attrName.indexOf(&quot;:&quot;) &gt; -1 ? attrName.substr(5) : attrName.substr(2);          let key = attr.value;          this.update(node, key, directiveName);        &#125;      &#125;);    &#125;  &#125;  /**   * 更新元素节点   * @param &#123;*&#125; node   * @param &#123;*&#125; key   * @param &#123;*&#125; directiveName 指令名   */  update(node, key, directiveName) &#123;    // v-model v-text v-html v-on:click    const updateFn = this[directiveName + &quot;Updater&quot;];    updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key, directiveName);  &#125;  /** 解析 v-text */  textUpdater(node, value, key) &#123;    node.textContent = value;    new Watcher(this.vm, key, newValue =&gt; &#123;      node.textContent = newValue;    &#125;);  &#125;  /** 解析 v-model */  modelUpdater(node, value, key) &#123;    node.value = value;    new Watcher(this.vm, key, newValue =&gt; &#123;      node.value = newValue;    &#125;);    // 更新值，双向绑定    node.addEventListener(&quot;input&quot;, () =&gt; &#123;      this.vm[key] = node.value;    &#125;);  &#125;  /** 解析 v-html */  htmlUpdater(node, value, key) &#123;    node.innerHTML = value;    new Watcher(this.vm, key, newValue =&gt; &#123;      node.innerHTML = newValue;    &#125;);  &#125;  /** 解析 v-on */  clickUpdater(node, value, key, directiveName) &#123;    node.addEventListener(directiveName, this.methods[key]);  &#125;  /**   * 判断元素属性是否是指令   */  isDirective(attrName) &#123;    return attrName.startsWith(&quot;v-&quot;);  &#125;  /**   * 判断是否是文本节点   */  isTextNode(node) &#123;    return node.nodeType === 3;  &#125;  /**   * 判断是否是元素节点   */  isElementNode(node) &#123;    return node.nodeType === 1;  &#125;&#125;</code></pre><h4 id="4-dep-js-收集依赖关系，存储观察者-以发布订阅的形式实现"><a href="#4-dep-js-收集依赖关系，存储观察者-以发布订阅的形式实现" class="headerlink" title="4. dep.js 收集依赖关系，存储观察者(以发布订阅的形式实现)"></a>4. dep.js 收集依赖关系，存储观察者(以发布订阅的形式实现)</h4><pre><code class="js">// dep.js/** * 发布订阅模式 * 存储所有观察者，watcher * 每个 watcher 都有一个 update * 通知 subs 里的每个 watcher 实例，触发 update 方法 */export default class Dep &#123;  constructor() &#123;    // 存储所有的观察者    this.subs = [];  &#125;  /**   * 添加观察者   */  addSub(watcher) &#123;    if (watcher &amp;&amp; watcher.update) &#123;      this.subs.push(watcher);    &#125;  &#125;  /**   * 发送通知   */  notify() &#123;    this.subs.forEach(watcher =&gt; &#123;      watcher.update();    &#125;);  &#125;&#125;</code></pre><h4 id="5-observer-js-数据劫持实现-递归遍历所有属性"><a href="#5-observer-js-数据劫持实现-递归遍历所有属性" class="headerlink" title="5. observer.js 数据劫持实现(递归遍历所有属性)"></a>5. observer.js 数据劫持实现(递归遍历所有属性)</h4><pre><code class="js">// observer.jsimport Dep from &quot;./dep.js&quot;;export default class Observer &#123;  constructor(data) &#123;    this.traverse(data);  &#125;  /**   * 递归遍历 data 里的所有属性   */  traverse(data) &#123;    if (!data || typeof data !== &quot;object&quot;) return;    Object.keys(data).forEach(key =&gt; &#123;      this.defineReactive(data, key, data[key]);    &#125;);  &#125;  /**   * 数据劫持，给传入的数据设置 getter/setter   */  defineReactive(obj, key, val) &#123;    // val 可能是 object    this.traverse(val);    const that = this;    // Dep 在此处实例化, 因为要在 setter 中调用 dep.notify()    const dep = new Dep();    Object.defineProperty(obj, key, &#123;      enumerable: true,      configurable: true,      get() &#123;        // 获取的时候收集依赖        Dep.target &amp;&amp; dep.addSub(Dep.target); // Dep.target 就是为了在此处添加依赖收集用的，添加之后就可以删除了，所以为 null        return val;      &#125;,      set(newValue) &#123;        if (newValue === val) &#123;          return;        &#125;        val = newValue;        // 设置的时候可能设置了一个对象，因此要递归        that.traverse(newValue);        // 最后发送通知        dep.notify();      &#125;    &#125;);  &#125;&#125;</code></pre><h4 id="6-watcher-js-观察者对象类-需要有-update-方法"><a href="#6-watcher-js-观察者对象类-需要有-update-方法" class="headerlink" title="6. watcher.js 观察者对象类(需要有 update 方法)"></a>6. watcher.js 观察者对象类(需要有 update 方法)</h4><pre><code class="js">// watcher.jsimport Dep from &quot;./dep.js&quot;;export default class Watcher &#123;  /**   *   * @param &#123;*&#125; vm Vue 实例   * @param &#123;*&#125; key data 属性名   * @param &#123;*&#125; cb 负责更新视图的回调   */  constructor(vm, key, cb) &#123;    this.vm = vm;    this.key = key;    this.cb = cb;    // 同一时间只维持一个 Watcher    Dep.target = this;    // 触发 get 方法，在 get 方法里去做一些操作    this.oldValue = vm[key];    // 为了避免重复的添加 Watcher, 将其设置为 null    Dep.target = null;  &#125;  /** 当数据变化时，更新视图 */  update() &#123;    // 需要判断新旧两个值的关系    let newValue = this.vm[this.key];    if (this.oldValue === newValue) &#123;      return;    &#125;    this.cb(newValue);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 手写题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Vue/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Vue/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么-Vue-使用异步渲染"><a href="#为什么-Vue-使用异步渲染" class="headerlink" title="为什么 Vue 使用异步渲染"></a>为什么 Vue 使用异步渲染</h2><p>vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件重新渲染，为了性能考虑，vue 会在本轮数据更新后，再去异步更新视图</p><h2 id="Vue2-和-Vue3-渲染器的-diff-算法"><a href="#Vue2-和-Vue3-渲染器的-diff-算法" class="headerlink" title="Vue2 和 Vue3 渲染器的 diff 算法"></a>Vue2 和 Vue3 渲染器的 diff 算法</h2><p>简单来说, diff 算法有以下过程:</p><ol><li>同级比较, 再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心 diff)</li><li>递归比较子节点</li></ol><p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p><p>Vue2 的核心 Diff 算法采用了 <strong>双端比较</strong> 的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x 借鉴了 ivi 算法和 inferno 算法, 在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。(实际的实现可以结合 Vue3.x 源码看。)<br>该算法中还运用了动态规划的思想求解最长递归子序列。</p><blockquote><p>vue3 中做了优化，只比较动态节点，略过静态节点，极大的提高了效率，主要是通过双指针去确定位置<br>vue3 新增了静态标记(patch flag)与上次虚拟节点对比，只会对比带有 patch flag 的节点</p></blockquote><h2 id="Vue3-所做的一些优化"><a href="#Vue3-所做的一些优化" class="headerlink" title="Vue3 所做的一些优化"></a>Vue3 所做的一些优化</h2><ol><li>diff 算法优化</li><li>按需编译代码，体积缩小</li><li>composition api (类似 react hooks)</li><li>对 ts 的支持更好</li><li>暴露了一些自定义渲染的 api</li><li>更先进的组件 (telport)</li><li>Fragement</li></ol><h2 id="Vue-中-key-的作用"><a href="#Vue-中-key-的作用" class="headerlink" title="Vue 中 key 的作用"></a>Vue 中 key 的作用</h2><p>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p><p>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p><h2 id="Vue-响应式数据原理"><a href="#Vue-响应式数据原理" class="headerlink" title="Vue 响应式数据原理"></a>Vue 响应式数据原理</h2><h3 id="阐述"><a href="#阐述" class="headerlink" title="阐述"></a>阐述</h3><p>首先了解 Vue 中的三个核心类:</p><ol><li>Observer: 给对象的属性添加 getter 和 setter, 用于 <strong>依赖收集</strong> 和 <strong>派发更新</strong>， 即数据劫持。</li><li>Dep: 用于收集当前响应式对象的依赖关系，每个响应式对象都有一个 dep 实例，dep.subs = watcher[], 当数据发生变更的时候，会通过 dep.notify() 通知各个 watcher</li><li>Watcher: 观察者对象，render watcher, computed watcher, user watcher (需要有 update 方法)</li></ol><ul><li>依赖收集</li></ul><ol><li>initState 初始化时，对计算属性初始化时，会触发 computed watcher 依赖收集</li><li>initState 初始化时，对监听属性初始化的时，触发 user watcher 依赖收集</li><li>render 渲染时，触发 render watcher 依赖收集</li></ol><ul><li>派发更新</li></ul><ol><li>组件中对响应的数据进行修改，会触发 setter 逻辑 (Object.defineProperty)</li><li>当数据发生变更的时候, 会通过 dep.notify 通知各个 watcher</li><li>遍历所有的 subs, 调用每一个 watcher 的 update 方法</li></ol><h3 id="总结原理"><a href="#总结原理" class="headerlink" title="总结原理"></a>总结原理</h3><ul><li>整体思路: 数据劫持 + 观察者模式(发布-订阅者模式)</li><li>通过 Object.defineProperty(Proxy) 来劫持各个属性的 getter 和 setter</li><li>当页面使用对应属性时，首先进行依赖收集(收集当前组件的 watcher)</li><li>如果属性发生变化, 发布消息给订阅者, 触发响应的监听回调</li></ul><p>具体步骤:</p><ol><li>对 Observer 对象进行递归遍历, 包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到变化。</li><li>complile 解析模版指令，将模版中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据发生变动，收到通知后更新视图</li><li>待变动属性 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退</li><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模版指令，最终利用 Watcher 搭建起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化 -&gt; 数据 model 变更的双向绑定的效果</li></ol><h2 id="Vue-计算属性的实现原理"><a href="#Vue-计算属性的实现原理" class="headerlink" title="Vue 计算属性的实现原理"></a>Vue 计算属性的实现原理</h2><p>computed watcher, 计算属性的监听器</p><p>computed watcher 持有一个 dep 实例，通过 drity 属性标记计算属性是否需要重新求值</p><p>当 computed 的依赖值改变后，就会通知订阅的 watcher 进行更新，对于 computed watcher 会将 drity 属性设置为 true，并且进行计算属性方法的调用</p><h3 id="computed-所谓的缓存是什么"><a href="#computed-所谓的缓存是什么" class="headerlink" title="computed 所谓的缓存是什么"></a>computed 所谓的缓存是什么</h3><p>计算属性是基于它的响应式依赖进行缓存的，只有依赖发生改变的时候才会重新求值</p><h3 id="何时会用到-computed-缓存"><a href="#何时会用到-computed-缓存" class="headerlink" title="何时会用到 computed 缓存"></a>何时会用到 computed 缓存</h3><p>比如计算属性方法内部操作非常耗时，遍历一个极大的数组，计算一次可能要耗时 1s</p><h2 id="Vue-事件绑定原理"><a href="#Vue-事件绑定原理" class="headerlink" title="Vue 事件绑定原理"></a>Vue 事件绑定原理</h2><p>原生事件: 通过 addEventListener 绑定给真实元素<br>组件事件: 通过 Vue 自定义的 $on 实现; 在组件上使用原生事件, 需要加 .native 修饰符(相当于父组件中把子组件当作普通的 html 标签, 然后加上原生事件)</p><p>on、emit 是基于发布订阅模式的, 维护一个事件中心, on 的时候将事件按名称存在事件中心里，即订阅者。然后 emit 将对应事件发布，去执行事件中心里对应的监听器。</p><h2 id="Vue-Router-路由钩子函数和执行顺序"><a href="#Vue-Router-路由钩子函数和执行顺序" class="headerlink" title="Vue-Router 路由钩子函数和执行顺序"></a>Vue-Router 路由钩子函数和执行顺序</h2><p>钩子函数的种类分为: 全局守卫、路由守卫、组件守卫</p><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用 beforeRouteLeave 守卫。</li><li>调用全局的 beforeEach 守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li><li>在路由配置里调用 beforeEnter。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>触发 DOM 更新。</li><li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h2 id="Vue-nextTick-的原理-什么是-nextTick"><a href="#Vue-nextTick-的原理-什么是-nextTick" class="headerlink" title="Vue.nextTick 的原理(什么是 nextTick)"></a>Vue.nextTick 的原理(什么是 nextTick)</h2><p>Vue 是异步执行 dom 更新的，一旦观察到数据的变化，就会把同一个 event loop 中的观察数据变化的 watcher 推送进这个队列</p><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p><ul><li>Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout</li></ul><h3 id="什么时候用到-nextTick？"><a href="#什么时候用到-nextTick？" class="headerlink" title="什么时候用到 nextTick？"></a>什么时候用到 nextTick？</h3><p>在数据变化后执行某个操作，而这个操作依赖因你数据变化而变化的 dom, 这个操作就应该放到 Vue.nextTick 回调中</p><h2 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h2><ol><li>beforeCreate: new Vue()之后触发的第一个钩子, data、methods、computed 以及 watch 上的数据和方法都不能被访问。</li><li>created: 当前阶段已经完成了数据观测，可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。</li><li>beforeMount 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。</li><li>mounted: 真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用 $refs 属性对 Dom 进行操作。</li><li>beforeUpdate: 也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，可以在当前阶段进行更改数据，不会造成重渲染。</li><li>updated: 当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</li><li>beforeDestroy: 在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</li><li>destroyed: 这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li></ol><h2 id="vue-父子组件生命周期调用顺序"><a href="#vue-父子组件生命周期调用顺序" class="headerlink" title="vue 父子组件生命周期调用顺序"></a>vue 父子组件生命周期调用顺序</h2><ul><li>加载渲染过程<br>父 beforeCreate =&gt; 父 created =&gt; 父 beforeMount =&gt; 子 beforeCreate =&gt; 子 created =&gt; 子 beforeMount =&gt; 子 mounted =&gt; 父 mounted</li><li>子组件更新流程<br>父 beforeUpdate =&gt; 子 beforeUpdate =&gt; 子 updated =&gt; 父 updated</li><li>父组件更新流程<br>父 beforeUpdate =&gt; 父 updated</li><li>销毁过程<br>父 beforeDestory =&gt; 子 beforeDestory =&gt; 子 destoryed =&gt; 父 destoryed</li></ul><blockquote><p>理解: 组件调用顺序都是先父后子，渲染完成的顺序是先子后父，组件销毁的操作是先父后子，销毁完成的顺序是先子后父</p></blockquote><h2 id="Vue-组件中的-data-为什么是函数"><a href="#Vue-组件中的-data-为什么是函数" class="headerlink" title="Vue 组件中的 data 为什么是函数"></a>Vue 组件中的 data 为什么是函数</h2><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。</p><h2 id="Vue-模版的编译原理"><a href="#Vue-模版的编译原理" class="headerlink" title="Vue 模版的编译原理"></a>Vue 模版的编译原理</h2><p>Vue 的编译过程就是将 template 转化 为 render 函数的过程。会经历以下阶段</p><ol><li>首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)</li><li>使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理</li><li>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li></ol><h2 id="Vue-的-Keep-alive"><a href="#Vue-的-Keep-alive" class="headerlink" title="Vue 的 Keep-alive"></a>Vue 的 Keep-alive</h2><p>keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><p>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</p><p>两个生命周期 activated(命中缓存时调用)/deactivated(切换时调用)，用来得知当前组件是否处于活跃状态。</p><p>keep-alive 的中还运用了 LRU(Least Recently Used)算法。</p><h2 id="nextTick-实现原理"><a href="#nextTick-实现原理" class="headerlink" title="nextTick 实现原理"></a>nextTick 实现原理</h2><p>nextTick 主要是使用了宏任务和微任务，定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列，所以 nextTick 就是异步方法。</p><h2 id="Vue-的-computed-和-watch-的差异"><a href="#Vue-的-computed-和-watch-的差异" class="headerlink" title="Vue 的 computed 和 watch 的差异"></a>Vue 的 computed 和 watch 的差异</h2><p>computed: 计算一个新属性，挂载到实例上(当依赖发生变化后才会重新计算)。</p><p>watch: 监听已经被挂载到实例上的数据，数据发生变化了就会调用。</p><h2 id="Vue-生命周期调用顺序"><a href="#Vue-生命周期调用顺序" class="headerlink" title="Vue 生命周期调用顺序"></a>Vue 生命周期调用顺序</h2><p>组件的调用顺序都是先父后子, 渲染完成的顺序是先子后父。</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><h2 id="Vue-SSR"><a href="#Vue-SSR" class="headerlink" title="Vue SSR"></a>Vue SSR</h2><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><p>SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。</p><h2 id="Vue-性能优化"><a href="#Vue-性能优化" class="headerlink" title="Vue 性能优化"></a>Vue 性能优化</h2><h3 id="编码阶段"><a href="#编码阶段" class="headerlink" title="编码阶段"></a>编码阶段</h3><ul><li>尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</li><li>对象层级不要过深</li><li>不需要响应式的数据不要放在 data 中(可以使用 Object.freeze() 冻结数据)</li><li>v-if/v-show, computed/watch 区分使用场景</li><li>v-for 避免同时使用 v-if, 同时要 key, key 最好是唯一值</li><li>如果需要使用 v-for 给每项元素绑定事件时使用事件代理</li><li>大数据列表和表格性能优化(虚拟列表/虚拟表格), 长列表滚动到可视区域动态加载</li><li>防止内部泄漏, 组件销毁后把全局事件和事件销毁</li><li>图片/路由懒加载</li><li>适当使用 keep-alive 缓存组件</li><li>第三方模块按需引入</li><li>防抖节流</li></ul><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><ul><li>服务端 SSR / 服务端预渲染</li></ul><blockquote><p>服务端渲染优先渲染出某一部分重要的内容，让其他内容懒加载，这样到达浏览器端时一部分 html 已经存在，页面上就可以呈现出一定的内容。其中服务端渲染出的 html 最好不要超过 14kb，主要是因为 tcp 慢开始的规则让第一个 tcp 包的大小是 14kb，这是与网站交互会接受到的第一个包。</p></blockquote><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><ul><li>webpack 相关打包优化</li></ul><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>骨架屏</li><li>PWA</li></ul><h2 id="hash-路由和-history-路由实现原理说一下"><a href="#hash-路由和-history-路由实现原理说一下" class="headerlink" title="hash 路由和 history 路由实现原理说一下"></a>hash 路由和 history 路由实现原理说一下</h2><p>location.hash 的值实际就是 URL 中#后面的东西。</p><p>history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和 history.replaceState()。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。store 基本上就是一个容器，它包含应用中大部分的状态 ( state )。</p><ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ol><p>主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ul><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><h3 id="什么是-proxy"><a href="#什么是-proxy" class="headerlink" title="什么是 proxy"></a>什么是 proxy</h3><blockquote><p>Proxy 对象用于定义基本操作的自定义行为(属性查找、赋值、枚举、函数调用等)。对象代理模式<br>target: 目标对象<br>handler: 行为<br>const proxy = new Proxy(target, handler)</p></blockquote><h3 id="为什么使用-proxy-proxy-利弊"><a href="#为什么使用-proxy-proxy-利弊" class="headerlink" title="为什么使用 proxy? proxy 利弊"></a>为什么使用 proxy? proxy 利弊</h3><blockquote><p>vue3 带来了基于 proxy 的观察者模式的实现, 提供了全范围响应式的能力, 消除了 vue2 基于 Object.defineProperty 存在的局限性<br>局限性包含以下几点:</p><ol><li>对属性添加、删除动作的检测</li><li>对数组基于下标修改、对于数组长度修改的检测</li><li>对于 Map、Set、WeakMap、WeakSet 支持(使用 WeakMap, WeakSet 的好处: 弱引用, 避免内存泄漏, 不会阻止垃圾回收器回收它所引用的 key, 必须非空且需要引用数据类型作为 key)</li></ol></blockquote><h3 id="proxy-中-handler-对象基本用法"><a href="#proxy-中-handler-对象基本用法" class="headerlink" title="proxy 中 handler 对象基本用法"></a>proxy 中 handler 对象基本用法</h3><pre><code class="js">// has 捕获器(拦截判断 target 对象是否含有属性 propKey 的操作)const handler = &#123;  has(target, propKey) &#123;    return propKey in target;  &#125;&#125;;const proxy = new Proxy(target, handler);// get 捕获器(拦截对象属性的读取)const handler = &#123;  get(target, propKey) &#123;    return propKey in target ? target[propKey] : &quot;no&quot;;  &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);proxy.apple = &quot;苹果&quot;;proxy.banana = &quot;香蕉&quot;;console.log(proxy.apple, proxy.banana);console.log(&quot;watermalon&quot; in proxy, proxy.watermalon);// set 捕获器(拦截对象的属性赋值操作)let validator = &#123;  set(obj, prop, value, receiver) &#123;    if (prop === &quot;age&quot;) &#123;      if (!Number.isInteger(value)) &#123;        throw new TypeError(&quot;The age is not an integer&quot;);      &#125;      if (value &gt; 200) &#123;        throw new RangeError(&quot;The age seems invalid&quot;);      &#125;    &#125;    obj[prop] = value;    return true;  &#125;&#125;;const proxy = new Proxy(&#123;&#125;, validator);proxy.age = 100;console.log(proxy.age); // 100proxy.age = &quot;young&quot;; // Errorproxy.age = 300; // Error// deleteProperty 捕获器(拦截删除 target 对象的 propKey 属性的操作)const foot = &#123; apple: &quot;苹果&quot;, banana: &quot;香蕉&quot; &#125;;const proxy = new Proxy(foot, &#123;  deleteProperty(target, prop) &#123;    console.log(&quot;当前删除水果 :&quot;, target[prop]);    return delete target[prop];  &#125;&#125;);delete proxy.apple;console.log(foot);// 运行结果: &#39;当前删除水果 : 苹果&#39; &#123;  banana:&#39;香蕉&#39;  &#125;// ownKeys 捕获器(拦截获取键值的操作)let obj = &#123; a: 10, [Symbol.for(&quot;foo&quot;)]: 2 &#125;;Object.defineProperty(obj, &quot;c&quot;, &#123;  value: 3,  enumerable: false&#125;);let proxy = new Proxy(obj, &#123;  ownKeys(target) &#123;    return [...Reflect.ownKeys(target), &quot;b&quot;, Symbol.for(&quot;bar&quot;)];  &#125;&#125;);const keys = Object.keys(proxy); // [&quot;a&quot;]for (let prop in proxy) &#123;  console.log(&quot;prop-&quot;, prop);&#125;const ownNames = Object.getOwnPropertyNames(proxy); // [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;]const ownSymbols = Object.getOwnPropertySymbols(proxy); // [Symbol(foo), Symbol(bar)]const ownKeys = Reflect.ownKeys(proxy); // [&#39;a&#39;, &#39;c&#39;, Symbol(foo), &#39;b&#39;, Symbol(bar)]</code></pre><h2 id="Vue-use-做了什么"><a href="#Vue-use-做了什么" class="headerlink" title="Vue.use 做了什么"></a>Vue.use 做了什么</h2><ol><li>检查插件是否注册，若已注册，则直接跳出</li><li>处理入参，将第一个参数之后的参数收集，并将首部塞入 this 上下文</li><li>执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>优化方向</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E4%BC%98%E5%8C%96%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>前端性能优化分为两个方向，一是工程化方向，另一个是细节方向。</p><h2 id="工程化方向"><a href="#工程化方向" class="headerlink" title="工程化方向"></a>工程化方向</h2><ol><li>客户端 Gzip 离线包、服务器资源 Gzip 压缩</li><li>JS 瘦身、tree-shaking、ES Module、动态 import，动态 Polyfill</li><li>图片加载优化、Webp、考虑兼容性、提前加载一些图片</li><li>延迟加载不用长内容。通过打点，看某些弹窗内或者子内容是否要初始化加载。</li><li>服务器渲染、客户端预渲染</li><li>CDN 静态资源</li><li>Webpack DLL，通用优先打包抽离，利用浏览器缓存</li><li>骨架图</li><li>数据预取，包括接口数据，和加载详情页图片。</li><li>Webpack 本身提供的优化，Base64，资源压缩，Tree shaking，拆包 chunk。</li><li>减少重定向</li></ol><h2 id="细节方向"><a href="#细节方向" class="headerlink" title="细节方向"></a>细节方向</h2><ol><li>图片，图片占位，图片懒加载。雪碧图</li><li>使用 prefetch / preload 预加载等新特性</li><li>服务器合理设置缓存策略</li><li>async（加载完当前 js 立即执行）/defer(所有资源加载完之后执行 js)</li><li>减少 Dom 的操作，减少重排重绘</li><li>从客户端层面，首屏减少和客户端交互，合并接口请求。</li><li>数据缓存。</li><li>首页不加载不可视组件。</li><li>防止渲染抖动，控制时序。</li><li>减少组件层级。</li><li>优先使用 Flex 布局。</li></ol><h2 id="卡顿问题解决"><a href="#卡顿问题解决" class="headerlink" title="卡顿问题解决"></a>卡顿问题解决</h2><ol><li>CSS 动画效率比 JS 高，css 可以用 GPU 加速，3d 加速。如果非要用 JS 动画，可以用 requestAnimationFrame。</li><li>批量进行 DOM 操作，固定图片容器大小，避免屏幕抖动。</li><li>减少重绘重排。</li><li>节流和防抖。</li><li>减少临时大对象产生，利用对象缓存，主要是减少内存碎片。</li><li>异步操作，IntersectionObserver，PostMessage，RequestIdleCallback。</li></ol><h2 id="性能优化-API"><a href="#性能优化-API" class="headerlink" title="性能优化 API"></a>性能优化 API</h2><ol><li>Performance。performance.now()与 new Date()区别，它是高精度的，且是相对时间，相对于页面加载的那一刻。但是不一定适合单页面场景。</li><li>window.addEventListener(&quot;load&quot;, &quot;&quot;); window.addEventListener(&quot;domContentLoaded&quot;, &quot;&quot;);</li><li>Img 的 onload 事件，监听首屏内的图片是否加载完成，判断首屏事件。</li><li>RequestFrameAnmation 和 RequestIdleCallback。</li><li>IntersectionObserver. MutationObserver，PostMessage。</li><li>Web Worker，耗时任务放在里面执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/JS/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/JS/</url>
      
        <content type="html"><![CDATA[<h2 id="从-0-到-1-搭建项目的思考"><a href="#从-0-到-1-搭建项目的思考" class="headerlink" title="从 0 到 1 搭建项目的思考"></a>从 0 到 1 搭建项目的思考</h2><ul><li>开发工具</li><li>技术选型</li><li>构建工具</li><li>构建仓库</li><li>依赖选择</li><li>测试策略</li><li>技术架构</li><li>环境信息</li><li>编码规则</li></ul><h2 id="前端项目的性能指标"><a href="#前端项目的性能指标" class="headerlink" title="前端项目的性能指标"></a>前端项目的性能指标</h2><ul><li>白屏时间</li><li>首屏时间</li><li>用户可操作时间</li><li>页面总下载时间</li></ul><h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><p>可以自由操作容器中子元素的排列方式</p><ul><li>flex-flow: 是 flex-direction 和 flex-wrap 的集合，默认属性为: row nowrap</li><li>align-content: 用于控制多行项目的对齐方式，如果项目只有一行则不会启作用</li><li>order: 默认为 0, 用于决定项目排列顺序，数值越小，项目排列越靠前</li><li>flex-grow: 默认 0，用于决定项目在有剩余空间的情况下是否放大，默认不放大；注意，即便设置了固定宽度，也会放大。</li><li>flex-shrink: 默认 1，用于决定项目在空间不足时是否缩小，默认项目都是 1，即空间不足时大家一起等比缩小；注意，即便设置了固定宽度，也会缩小。</li><li>flex-basics: 默认 auto，用于设置项目宽度，默认 auto 时，项目会保持默认宽度，或者以 width 为自身的宽度，但如果设置了 flex-basis，权重会比 width 属性高，因此会覆盖 width 属性。</li><li>flex: 默认 0 1 auto，flex 属性是 flex-grow，flex-shrink 与 flex-basis 三个属性的简写，用于定义项目放大，缩小与宽度。</li><li>align-self: 表示继承父容器的 align-items 属性。如果没父元素，则默认 stretch。 用于让个别项目拥有与其它项目不同的对齐方式，各值的表现与父容器 的 align-items 属性完全一致。</li></ul><h2 id="css-优先级顺序"><a href="#css-优先级顺序" class="headerlink" title="css 优先级顺序"></a>css 优先级顺序</h2><ol><li>!important</li><li>行内样式</li><li>ID 选择器</li><li>类选择器、属性选择器、伪类选择器</li><li>元素选择器、关系选择器、伪元素选择器</li><li>通配符 *</li></ol><h2 id="js-原型"><a href="#js-原型" class="headerlink" title="js 原型"></a>js 原型</h2><ul><li>在 js 中，我们使用构造函数新建一个对象，每个构造函数内部都有一个 prototype 属性值，该属性值是一个对象，该对象包含了可以被该构造函数的所有实例所共享的属性和方法。</li><li>在我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性值，即这个对象的原型。</li></ul><h2 id="js-原型链"><a href="#js-原型链" class="headerlink" title="js 原型链"></a>js 原型链</h2><p>当我们访问一个对象的属性时，若对象内部不存在这一属性，便会去它的原型对象里去找这个属性，同时这个原型对象又会有自己的原型，然后这样一直找下去，便形成了原型链</p><blockquote><p>个人理解: 原型链就是链表, this 就是连标当前指向的那个原型, bind call apply 就是改变链表的 next 指向</p></blockquote><h2 id="js-原型特点"><a href="#js-原型特点" class="headerlink" title="js 原型特点"></a>js 原型特点</h2><p>javascript 对象使用过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变</p><h2 id="js-的几种继承方式"><a href="#js-的几种继承方式" class="headerlink" title="js 的几种继承方式"></a>js 的几种继承方式</h2><ul><li>原型链继承</li></ul><blockquote><p>缺点: 引用类型数据会被所有实例所共享，会造成修改数据混乱; 创建子类时无法向超类型传参</p></blockquote><ul><li>借用构造函数继承</li></ul><blockquote><p>通过在子类函数中调用超类型的构造函数实现。解决了无法向超类传参数的缺点，但是无法实现函数方法的复用，同时超类定义的方法子类也无法访问。</p></blockquote><ul><li>组合式继承</li></ul><blockquote><p>将原型链继承和借用构造函继承组合使用，通过借用构造函数的方式来实现类型属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。缺点是调用了两次超类构造函数。</p></blockquote><ul><li>原型式继承</li></ul><blockquote><p>基于已有的对象创建新的对象。向函数中传递一个对象，然后返回一个以这个对象为原型的对象。Object.create() 方法就是原型式继承的实现，缺点同原型继承</p></blockquote><ul><li>寄生式继承</li></ul><blockquote><p>通过 Object.create 创建副本，对副本进行扩展，最后将副本返回</p></blockquote><ul><li>寄生组合式继承</li></ul><blockquote><p>缺点: 使用超类实例做子类型原型，多了不必要的属性。</p></blockquote><h2 id="js-的栈和堆"><a href="#js-的栈和堆" class="headerlink" title="js 的栈和堆"></a>js 的栈和堆</h2><ul><li>栈(基本数据类型: number, string, boolean, undefined, null, symbol, bigInt)</li></ul><blockquote><p>占据空间小，大小固定，频繁使用。</p></blockquote><ul><li>堆(应用数据类型: object, array, function)</li></ul><blockquote><p>占据空间大，大小不固定</p></blockquote><h2 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h2><ul><li>事件冒泡: 自底向上</li></ul><pre><code class="js">window.addEventListener(&quot;click&quot;, () =&gt; &#123;  // 事件触发顺序为冒泡顺序&#125;);</code></pre><ul><li>事件捕获: 自顶向下</li></ul><pre><code class="js">window.addEventListener(  &quot;click&quot;,  () =&gt; &#123;    // 事件触发顺序为捕获顺序  &#125;,  true);</code></pre><h2 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h2><ul><li>先事件捕获(从 window -&gt; document 依次往下执行)</li><li>再是对目标事件的处理</li><li>最后是事件冒泡</li></ul><h2 id="事件冒泡和事件捕获的应用场景"><a href="#事件冒泡和事件捕获的应用场景" class="headerlink" title="事件冒泡和事件捕获的应用场景"></a>事件冒泡和事件捕获的应用场景</h2><ol><li>事件委托</li></ol><h2 id="var、let、const-对比"><a href="#var、let、const-对比" class="headerlink" title="var、let、const 对比"></a>var、let、const 对比</h2><ul><li>var 定义的变量会进行变量提升; let 和 const 定义的变量不存在变量提升(不存在变量提升)<ul><li>对于 var 来说，如果变量定义在函数内部，则会将变量提升到函数的开头</li><li>对于 var 来说，如果变量声明是一个全局变量，则会将变量声明提升到全局作用域的开头</li></ul></li><li>var 的作用域是函数级; let 和 const 的作用域是块级(声明的变量只在声明的代码块内有效)</li><li>var 和 let 声明变量时不需要初始值; const 声明变量需要初始值</li><li>let 声明的变量存在暂时性死区(只要块级作用域内部存在 let 命令，它所声明的变量就会绑定这个区域，不再受外部影响)</li><li>var 定义的变量可以重复进行定义; let 和 const 声明的变量不可以重复进行定义(不能够重复声明)</li></ul><h2 id="实现-new-关键字-new-的过程-new-操作符做了什么"><a href="#实现-new-关键字-new-的过程-new-操作符做了什么" class="headerlink" title="实现 new 关键字 (new 的过程/new 操作符做了什么)"></a>实现 new 关键字 (new 的过程/new 操作符做了什么)</h2><ul><li>创建一个新的空对象</li><li>设置原型，将对象的原型设置为函数的 prototype 对象</li><li>绑定 this 指向，执行构造函数</li><li>返回新对象</li></ul><pre><code class="js">function ObjectFactory() &#123;  let obj = &#123;&#125;;  let constructor = Array.prototype.shift.call(arguments);  obj.__proto__ = constructor.prototype;  constructor.apply(obj, arguments);  return obj;&#125;</code></pre><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><ul><li>全局作用域下的 this =&gt; window</li><li>普通函数 =&gt; 非严格模式 window; 严格模式 undefined</li><li>箭头函数 =&gt; 指向外层的 this</li><li>对象内部函数 =&gt; 当前对象</li><li>构造函数 =&gt; 指向当前构造函数创建的对象实例</li><li>call/apply/bind =&gt; 通过设置第一个参数上下文来改变 this 指向</li></ul><h2 id="实现-call、apply、bind"><a href="#实现-call、apply、bind" class="headerlink" title="实现 call、apply、bind"></a>实现 call、apply、bind</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><pre><code class="js">Function.prototype.call2 = function (ctx, ...args) &#123;  let context = ctx || window;  context.fn = this;  let result = context.fn(args);  delete context.fn;  return result;&#125;;</code></pre><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><pre><code class="js">Function.prototype.apply2 = function (ctx, ...args) &#123;  let context = ctx || window;  context.fn = this;  if (!args[0].length) return context.fn();  let result = context.fn(...args[0]);  delete context.fn;  return result;&#125;;</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code class="js">Function.prototype.bind2 = function (ctx, ...args) &#123;  let _self = this;  function Fn() &#123;&#125;  let f = function (...fArgs) &#123;    return _self.apply(this instanceof Fn ? this : ctx, args.concat(fArgs));  &#125;;  Fn.prototype = this.prototype;  f.prototype = new Fn();  return f;&#125;;</code></pre><h2 id="js-闭包"><a href="#js-闭包" class="headerlink" title="js 闭包"></a>js 闭包</h2><p>闭包指的是有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内创建另一个函数(本质就是函数的作用域链中保存着外部函数变量对象的引用)</p><h2 id="weakMap-weakSet"><a href="#weakMap-weakSet" class="headerlink" title="weakMap/weakSet"></a>weakMap/weakSet</h2><p>对于 weakMap 和 weakSet 来说不会计入垃圾回收</p><p>weakMap 的键名只能是对象</p><p>weakSet 成员只能是对象</p><h2 id="什么是-JavaScript-事件循环"><a href="#什么是-JavaScript-事件循环" class="headerlink" title="什么是 JavaScript 事件循环"></a>什么是 JavaScript 事件循环</h2><ul><li>因为 js 是单线程执行的(两个线程同时操作 dom, 会发生冲突)，在代码执行的过程中，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件暂时挂起，继续执行执行栈中的其他任务。</li><li>当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li><li>任务队列分为<ul><li>宏任务队列<blockquote><p>script 脚本的执行<br>setTimeout/setInterval/setImmediate<br>I/O 操作<br>UI 渲染</p></blockquote></li><li>微任务队列<blockquote><p>promise 的回调 (必须有 resolve/reject 结果, 同一块作用域内多个 resolve 中其中一个执行完后其他不再执行)<br>node 中的 process.nextTick<br>对 DOM 变化监听的 MutationObserver</p></blockquote></li></ul></li><li>当当前执行栈中的事件执行完毕后，js 引擎会首先判断微任务队列中是否有任务可以执行。如果有就将微任务队列的队首事件压入执行栈中执行。当微任务队列中的任务都执行完成后，再去判断宏任务队列中的任务。</li></ul><h2 id="node-中的事件循环和浏览器中的事件循环有什么区别"><a href="#node-中的事件循环和浏览器中的事件循环有什么区别" class="headerlink" title="node 中的事件循环和浏览器中的事件循环有什么区别"></a>node 中的事件循环和浏览器中的事件循环有什么区别</h2><p>node 中宏任务的执行顺序:</p><ol><li>timers 定时器: 执行已经安排的 setTimeout 和 setInterval 的回调函数</li><li>pending callback 待定回调: 执行延迟到下一个循环迭代的 I/O 回调</li><li>idle, prepare: 仅系统内部使用</li><li>poll: 检索新的 I/O 事件，执行与 I/O 相关的回调</li><li>check: 执行 setImmediate() 回调函数</li><li>close callbacks: socket 的关闭的回调(socket.on(&#39;close&#39;, () =&gt; {}))</li></ol><p>微任务和宏任务在 node 中的执行顺序:</p><ul><li><p>Node V10 及以前:</p><ul><li>执行完一个阶段中的所有任务(1-6)</li><li>执行 nextTick 队列里的内容</li><li>最后执行微任务队列里的内容</li></ul></li><li><p>Node V10 后:</p><ul><li>与浏览器行为保持一致</li></ul></li></ul><h2 id="什么是事件队列"><a href="#什么是事件队列" class="headerlink" title="什么是事件队列"></a>什么是事件队列</h2><p>事件队列是一个存储着待执行任务的队列，其中的任务严格按照事件顺序执行，队头的任务率先执行，队尾的任务后执行。每次仅执行一个任务。</p><h2 id="执行栈是什么"><a href="#执行栈是什么" class="headerlink" title="执行栈是什么"></a>执行栈是什么</h2><p>执行栈是类似函数调用栈的运行容器，执行栈为空，js 引擎检查事件队列是否为空，不为空则将第一个任务压入执行栈执行。</p><h2 id="js-判断数据类型"><a href="#js-判断数据类型" class="headerlink" title="js 判断数据类型"></a>js 判断数据类型</h2><h3 id="准确判断数据类型"><a href="#准确判断数据类型" class="headerlink" title="准确判断数据类型"></a>准确判断数据类型</h3><pre><code class="js">Object.prototype.toString.call(1); // [&quot;object Number&quot;]Object.prototype.toString.call(&quot;1&quot;); // [&quot;object String&quot;]Object.prototype.toString.call(false); // [&quot;object Boolean&quot;]Object.prototype.toString.call(undefined); // [&quot;object Undefined&quot;]Object.prototype.toString.call(null); // [&quot;object Null&quot;]Object.prototype.toString.call([1, 2, 3]); // [&quot;object Array&quot;]Object.prototype.toString.call(&#123;&#125;&#125;); // [&quot;object Object&quot;]Object.prototype.toString.call(NaN); // [&quot;object Number&quot;]</code></pre><h3 id="利用-typeof-判断基本数据类型"><a href="#利用-typeof-判断基本数据类型" class="headerlink" title="利用 typeof 判断基本数据类型"></a>利用 typeof 判断基本数据类型</h3><pre><code class="js">typeof 1; // &quot;number&quot;typeof &quot;1&quot;; // &quot;string&quot;typeof false; // booleantypeof undefined; // undefined</code></pre><h3 id="利用-instanceof-判断引用数据类型"><a href="#利用-instanceof-判断引用数据类型" class="headerlink" title="利用 instanceof 判断引用数据类型"></a>利用 instanceof 判断引用数据类型</h3><pre><code class="js">[1, 2, 3] instanceof Array; // true&#123;&#125; instanceof Object; // true function () &#123;&#125; instanceof Function; // true&#39;1&#39; instanceof String; // false1 instanceof Number; // falsefalse instanceof Boolean; // false</code></pre><h2 id="ajax-理解"><a href="#ajax-理解" class="headerlink" title="ajax 理解"></a>ajax 理解</h2><p>ajax 是一种异步通信方式，直接由 js 脚本向服务器发起 http 通信，根据服务器返回的数据，更新网页响应部分而不刷新网页。</p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p><img src="/images/%E7%BC%93%E5%AD%98.png" class="lazyload" data-srcset="/images/%E7%BC%93%E5%AD%98.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="缓存"></p><h3 id="什么是-Service-worker"><a href="#什么是-Service-worker" class="headerlink" title="什么是 Service worker"></a>什么是 Service worker</h3><p>是一个服务器与浏览器之间的中间人角色，如果网站中注册了 service worker，那么它可以拦截当前网站所有的请求，然后进行判断。<br>如果需要向服务器发起请求，那么就转给服务器，如果可以直接使用缓存就直接返回缓存内容不再转给服务器，从而大大提高浏览体验。</p><h4 id="Service-worker-的生命周期"><a href="#Service-worker-的生命周期" class="headerlink" title="Service worker 的生命周期"></a>Service worker 的生命周期</h4><p>Service Worker 的生命周期与 web 页面完全分离。</p><p>它包含以下几个阶段:</p><ul><li>下载</li></ul><p>这是浏览器下载包含 Service worker 的 .js 文件的时候</p><ul><li>安装</li></ul><p>在安装过程中，通常需要缓存某些静态资产，如果某些资源已成功缓存，那么 Service worker 就安装完毕。如果任何文件下载失败或缓存失败，那么安装步骤将会失败，Service Worker 就无法激活（也就是说, 不会安装）。如果发生这种情况，不必担心，它下次会再试一次。</p><ul><li>激活</li></ul><p>安装成功之后，接下来就是激活步骤，通常会在这个阶段管理旧缓存。要为 web 应用程序安装 Service worker，必须先注册它，这可以在 JavaScript 代码中完成。注册 Service Worker 后，它会提示浏览器在后台启动 Service Worker 安装步骤</p><p><img src="/images/service_worker.png" class="lazyload" data-srcset="/images/service_worker.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Service worker 生命周期"></p><h4 id="Service-worker-经常配合哪种缓存使用"><a href="#Service-worker-经常配合哪种缓存使用" class="headerlink" title="Service worker 经常配合哪种缓存使用"></a>Service worker 经常配合哪种缓存使用</h4><p>经常配合 CacheStorage 离线缓存一起使用</p><pre><code class="js">if (&quot;serviceWorker&quot; in navigator) &#123;  navigator.serviceWorker.register(&quot;./sw.js&quot;);&#125;// sw.jsvar VERSION = &quot;v1&quot;;// 缓存self.addEventListener(&quot;install&quot;, function (event) &#123;  event.waitUntil(    caches.open(VERSION).then(function (cache) &#123;      return cache.addAll([&quot;./start.html&quot;, &quot;./static/jquery.min.js&quot;, &quot;./static/mm1.jpg&quot;]);    &#125;)  );&#125;);// 缓存更新self.addEventListener(&quot;activate&quot;, function (event) &#123;  event.waitUntil(    caches.keys().then(function (cacheNames) &#123;      return Promise.all(        cacheNames.map(function (cacheName) &#123;          // 如果当前版本和缓存版本不一致          if (cacheName !== VERSION) &#123;            return caches.delete(cacheName);          &#125;        &#125;)      );    &#125;)  );&#125;);// 捕获请求并返回缓存数据self.addEventListener(&quot;fetch&quot;, function (event) &#123;  event.respondWith(    caches      .match(event.request)      .catch(function () &#123;        return fetch(event.request);      &#125;)      .then(function (response) &#123;        caches.open(VERSION).then(function (cache) &#123;          cache.put(event.request, response);        &#125;);        return response.clone();      &#125;)      .catch(function () &#123;        return caches.match(&quot;./static/mm1.jpg&quot;);      &#125;)  );&#125;);</code></pre><h3 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h3><ul><li>通过在一段时间内保留已接收到的 web 资源的一个副本，如果在有效时间内，发起了对这个资源的再一次请求，浏览器将直接使用缓存副本，而不是再发起请求。</li><li>可以提高页面的打开速度，减少不必要的带宽消耗.</li></ul><h3 id="浏览器缓存位置"><a href="#浏览器缓存位置" class="headerlink" title="浏览器缓存位置"></a>浏览器缓存位置</h3><ul><li>Service Worker</li></ul><blockquote><p>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是可持续性的。</p></blockquote><ul><li>Memory Cache</li></ul><blockquote><p>Memory Cahce 是内存中的缓存，读取内存中的数据肯定比读取磁盘中的数据快。但是内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放。</p></blockquote><ul><li>Disk Cache</li></ul><blockquote><p>Disk Cache 是存储在硬盘中的缓存，虽然读取速度慢，但是都可以存储到磁盘中，胜在容量和饿存储时效性上。</p></blockquote><ul><li>Push Cache</li></ul><blockquote><p>Push Cache 是 Http/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，并且缓存时间也很短暂，只在 session 会话中存在，一旦会话结束将会被释放</p></blockquote><ul><li>网络请求</li></ul><blockquote><p>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</p></blockquote><h3 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h3><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><ul><li>介绍</li></ul><p>强缓存可以通过设置两种 Http 头来实现，分别是 expries 和 cache-control。强缓存表示在缓存期间不需要发起请求，其 http 状态码为 200。</p><blockquote><p>expries 是 HTTP/1 的产物，表示资源会在设置的时间后过期，需要再次发起请求，因为 expries 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。<br>cache-control 出现于 HTTP/1.1，优先级高于 expries，该属性值表示资源会在 max-age 后贵气，过期后需再次发起请求。</p></blockquote><ul><li>no-cache 和 no-store</li></ul><blockquote><p>Cache-Control: no-cache 可以在本地进行缓存，但每次请求时，都要向服务器进行验证，如果服务器允许，才能够使用本地缓存。</p></blockquote><blockquote><p>Cache-Control: no-store 这个才是响应缓存不被缓存的意思</p></blockquote><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 Http 头实现: Last-Modified 和 Etag。</p><p>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存的有效期。</p><ul><li>Last-Modified/If-Modified-Since</li></ul><blockquote><p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，如果有更新则将新资源发送回，否则返回 304</p></blockquote><blockquote><p>Last-Modified 的弊端:<br>如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源;<br>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端就会任务资源还是命中了，不会返回正确的资源</p></blockquote><ul><li>ETag/If-None-Match</li></ul><blockquote><p>因为 Last-Modified 的弊端，所以在 Http/1.1 出现了 Etag</p></blockquote><blockquote><p>Etag 类似于文件指纹，If-None-Match 会将当前 Etag 发送给服务器，询问该资源 Etag 是否变动，有变动的话就将新的资源发送回来。并且 Etag 优先级 &gt; Last-Modified</p></blockquote><blockquote><p>如果什么缓存策略都没设置，浏览器会采用一个启发式算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间</p></blockquote><h2 id="get-和-post-在缓存方面的区别"><a href="#get-和-post-在缓存方面的区别" class="headerlink" title="get 和 post 在缓存方面的区别"></a>get 和 post 在缓存方面的区别</h2><p>get 类似于查找，可用缓存；post 必须与数据库进行交互，不能使用缓存</p><h2 id="浏览器跨域解决方案"><a href="#浏览器跨域解决方案" class="headerlink" title="浏览器跨域解决方案"></a>浏览器跨域解决方案</h2><ol><li>jsonp</li><li>document.domain + iframe</li><li>location.hash + iframe</li><li>window.name + iframe</li><li>postMessage</li><li>跨域资源共享 cors</li><li>nginx 反向代理</li><li>node.js 中间件代理(proxy)</li><li>websocket 原生支持跨域</li></ol><h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><ul><li>xss 攻击</li></ul><blockquote><p>跨站脚本攻击，是一种代码注入攻击，可以盗取用户的 cookie<br>预防方式: 数据转义、资源白名单</p></blockquote><ul><li>csrf 跨站请求伪造</li></ul><blockquote><p>攻击者诱导用户进入第三方网站，然后向被攻击网站发送跨站请求，如果此时用户处于登陆状态，则可盗用用户信息进行操作。<br>预防方式：进行同源检测，csrf token 进行随即验证</p></blockquote><ul><li>点击劫持</li></ul><blockquote><p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透初一个按钮诱导用户点击。<br>预防方式：通过在 http header 设置 x-frame-options 来防御 iframe 嵌套的点击劫持攻击</p></blockquote><h2 id="观察者模式对比发布订阅模式"><a href="#观察者模式对比发布订阅模式" class="headerlink" title="观察者模式对比发布订阅模式"></a>观察者模式对比发布订阅模式</h2><blockquote><p>发布订阅模式属于广义的观察者模式</p></blockquote><blockquote><p>观察者模式: 直接订阅目标事件</p></blockquote><blockquote><p>发布订阅模式: 中间多了一个调度中心，整体流程为：发布者 -&gt; 调度中心 -&gt; 调度者</p></blockquote><h2 id="从-url-输入到页面渲染整个流程"><a href="#从-url-输入到页面渲染整个流程" class="headerlink" title="从 url 输入到页面渲染整个流程"></a>从 url 输入到页面渲染整个流程</h2><ol><li>解析 host</li><li>dns 查询，通过域名查找 ip</li><li>tcp 握手</li><li>解析文件如何进行解码</li><li>渲染流程，根据 html 代码生成 dom 树，根据 css 代码生成 cssom 树，将 css 与 dom 合并，整合为渲染树最后渲染。</li><li>遇到 script 标签则暂停渲染，优先加载执行 js 代码，完成后继续</li></ol><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h3><p>webSocket 是一种在单个 TCP 连接上进行全双工通信的协议，webSocket 是基于应用层传输控制协议，它们都是全双工的，区别于普通的 http 请求，发起 webScoket 请求时，会增加一个请求头，用来告诉服务器这是<br>webSocket 请求</p><h3 id="http-三次握手"><a href="#http-三次握手" class="headerlink" title="http 三次握手"></a>http 三次握手</h3><ol><li>建立连接时，客户端发送 SYN 包到服务端, 并进入 SYN_SEND 状态</li><li>服务端收到 SYN 包后，向客户端发送 SYN+ACK 包，服务器进入 SYN_RCVD 状态</li><li>客户端收到服务端的 SYN + ACK 包后，向服务器发送 ACK 确认包，发送完后，两边同时进入 establish 状态</li></ol><h3 id="http-四次挥手"><a href="#http-四次挥手" class="headerlink" title="http 四次挥手"></a>http 四次挥手</h3><ol><li>TCP 向客户端发送 FIN 包，用来关闭客户端到服务端之间的传输</li><li>服务端收到 FIN 包，返回一个 ACK 包</li><li>服务器关闭客户端的链接，发送一个 FIN 包给客户端</li><li>客户端发送 ACK 报文进行确认</li></ol><h3 id="http-1-和-http-2-对比"><a href="#http-1-和-http-2-对比" class="headerlink" title="http/1 和 http/2 对比"></a>http/1 和 http/2 对比</h3><ul><li>大幅度提高了网页性能，http/1 最大的请求数为 6，会造成队头阻塞，需等待其他资源请求完成后才能发起请求</li><li>多路复用<blockquote><p>用二进制分帧传输，用帧标识请求，因为一个 TCP 连接可在多条流中，即可以发送多个请求，因此可避免 http1 中队头阻塞问题<br>通信双方都可以给对方发二进制帧，这种二进制帧的双向传输序列，也叫做流。HTTP/2 用流来在一个 TCP 连接上来进行数据帧的通信</p></blockquote></li><li>header 压缩<blockquote><p>采用 HPACK 算法，在客户端和服务端两端建立 &quot;字典&quot;，用索引号表示重复的字符串<br>采用哈夫曼编码来压缩整数和字符串，可以达到 50% ～ 90% 的高压缩率</p></blockquote></li><li>服务端推送<blockquote><p>服务器不再是完全被动地响应请求，也可以新建 &quot;流&quot; 主动向客户端发送消息</p></blockquote></li><li>二进制传输<blockquote><p>http/1 通过文本进行传输，http/2 引入了新的编码机制，所有传输数据都被分割，并采用二进制进行编码。</p></blockquote></li></ul><h3 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h3><p>http/3 重新构建了一个基于 UDP 的 QUIC 协议，解决了 http/2 下多路复用时丢包产生的问题，即解决了 TCP 协议的一些问题</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https 是在 http 基础上和 ssl/tls 证书结合起来的一种协议，保证了传输过程中的安全性，减少了恶意劫持的可能，很好的解决了 http 的多个缺点(被监听、被篡改、被伪装)</p><p>http + 加密 + 认证 + 完整性保护 = https</p><p>http 是铭文传输，即未被加密</p><h2 id="import-和-require-的区别"><a href="#import-和-require-的区别" class="headerlink" title="import 和 require 的区别"></a>import 和 require 的区别</h2><ol><li>模块的加载时机不同(require: 运行时加载，import: 会提升到整个模块的头部，在编译时加载)</li><li>require: 模块就是对象， 输入时必须查找对象属性；import: es6 模块不是对象</li></ol><h2 id="commonjs-和-es6-module-区别"><a href="#commonjs-和-es6-module-区别" class="headerlink" title="commonjs 和 es6 module 区别"></a>commonjs 和 es6 module 区别</h2><ol><li>commonjs 默认采用的是非严格模式</li><li>es6 module 自动采用严格模式</li><li>commonjs 模块输出的是一个值的拷贝，es6 module 输出的是值的引用</li></ol><h2 id="Promise-的一些考点"><a href="#Promise-的一些考点" class="headerlink" title="Promise 的一些考点"></a>Promise 的一些考点</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ul><li>一些特性</li></ul><p>Promise.all 可接受参数可以为常量，也可以为 promise 对象</p><p>Promise.all 执行过程中一旦某个 promise 报错，将直接抛出异常，但同时其余的 prommise 也被执行了，因为 promise 实例在创建之初就被执行了</p><ul><li>实现 Promise.all</li></ul><pre><code class="js">function PromiseAll(promiseArray) &#123;  return new Promise((resolve, reject) =&gt; &#123;    if (!Array.isArray(promiseArray)) &#123;      return reject(new Error(&quot;传入的参数必须是数组!&quot;));    &#125;    const res = [];    const len = promiseArray.length;    let index = 0;    for (let i = 0; i &lt; len; i++) &#123;      Promise.resolve(promiseArray[i])        .then(val =&gt; &#123;          index++;          res[i] = val;          if (index === len) &#123;            resolve(res);          &#125;        &#125;)        .catch(err =&gt; &#123;          reject(err);        &#125;);    &#125;  &#125;);&#125;</code></pre><h3 id="Promise-缓存"><a href="#Promise-缓存" class="headerlink" title="Promise 缓存"></a>Promise 缓存</h3><blockquote><p>为了解决 promise 调用常量，每个页面都会调用这个常量，以解决多次调用接口对服务器造成请求的浪费。<br>可以使用 promise 缓存或者全局状态管理。</p></blockquote><pre><code class="js">const cacheMap = new Map();function enableCache(target, name, descriptor) &#123;  const val = descriptor.value;  descriptor.value = async function (...args) &#123;    const cacheKey = name + JSON.stringify(args);    if (!cacheMap.get(cacheKey)) &#123;      const cacheValue = Promise.resolve(val.apply(this, args)).catch(_ =&gt; &#123;        cacheMap.set(cacheKey, null);      &#125;);      cacheMap.set(cacheKey, cacheValue);    &#125;    return cacheMap.get(cacheKey);  &#125;;  return desciptor;&#125;class PromiseClass &#123;  @enableCache  static async getInfo() &#123;&#125;&#125;PromiseClass.getInfo();PromiseClass.getInfo();PromiseClass.getInfo();PromiseClass.getInfo();</code></pre><h2 id="前端内存处理"><a href="#前端内存处理" class="headerlink" title="前端内存处理"></a>前端内存处理</h2><h3 id="内存的声明周期"><a href="#内存的声明周期" class="headerlink" title="内存的声明周期"></a>内存的声明周期</h3><ul><li>内存分配: 声明变量，函数，对象的时候，js 会自动分配内存</li><li>内存使用: 调用的时候，使用的时候</li><li>内存回收: js 自己的垃圾回收机制</li></ul><h3 id="js-中的垃圾回收机制"><a href="#js-中的垃圾回收机制" class="headerlink" title="js 中的垃圾回收机制"></a>js 中的垃圾回收机制</h3><h4 id="引用计数垃圾回收"><a href="#引用计数垃圾回收" class="headerlink" title="引用计数垃圾回收"></a>引用计数垃圾回收</h4><blockquote><p>a 对象对 b 对象有访问权限，那么称为 a 引用 b 对象，只有当无引用时才会被成为垃圾，然后被回收</p><p>缺陷: 循环引用，造成内存泄漏</p></blockquote><h4 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h4><blockquote><p>对内存中存活对象做标记，标记结束后清除未被标记的</p><p>步骤:</p><ol><li>在运行的时候给存储在内存的所有变量加上标记</li><li>从根部触发，能触及的对象，把标记清除</li><li>哪些有标记的就被视为即将要删除的变量</li></ol></blockquote><h4 id="标记压缩法"><a href="#标记压缩法" class="headerlink" title="标记压缩法"></a>标记压缩法</h4><blockquote><p>使用内存碎片对内存分配</p></blockquote><h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><blockquote><p>垃圾回收时间长所产生，用来交替运行</p></blockquote><h2 id="js-内存泄漏的几种原因"><a href="#js-内存泄漏的几种原因" class="headerlink" title="js 内存泄漏的几种原因"></a>js 内存泄漏的几种原因</h2><ol><li><p>意外的全局变量</p></li><li><p>未清除的定时器或回调函数</p></li><li><p>脱离 DOM 的引用</p><pre><code class="js">const elements = &#123;  image: document.getElementById(&quot;image&quot;);&#125;;document.body.removeChild(document.getElementById(&quot;image&quot;)); // 会造成内存泄漏elements.image = null; // 正确的使用方式</code></pre></li><li><p>不合理地使用闭包</p></li></ol><h2 id="如何减少内存泄漏"><a href="#如何减少内存泄漏" class="headerlink" title="如何减少内存泄漏"></a>如何减少内存泄漏</h2><ol><li>减少不必要的全局变量</li><li>使用完数据后，及时解除引用</li></ol><h2 id="e-target-和-e-currentTarget-的区别"><a href="#e-target-和-e-currentTarget-的区别" class="headerlink" title="e.target 和 e.currentTarget 的区别"></a>e.target 和 e.currentTarget 的区别</h2><ul><li>e.target 就是触发事件的标签，触发谁就是谁</li><li>e.currentTarget 就是绑定事件的标签，绑定哪个事件输出的就是该事件</li></ul><blockquote><p>如果绑定的事件所在的组件没有子元素，那么 e.target === e.currentTarget<br>如果事件绑定在父元素中，且该父元素有子元素。当用 e.currentTarget 时，不管点击父元素所在区域还是子元素(当前事件)，都正确执行；若用 e.target 时，点击父元素所在区域无错，点击子元素区域，执行报错。报错的原因是事件没绑定在子元素上，是在父元素上，子元素要用 e.currentTarget 才正确</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> JS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/React/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/React/</url>
      
        <content type="html"><![CDATA[<h2 id="react-的优势"><a href="#react-的优势" class="headerlink" title="react 的优势"></a>react 的优势</h2><ol><li>前端框架发展说起(业务量的增长)</li><li>react 是用于构建用户界面的 JavaScript 库<ul><li>库: 自己实现功能</li><li>框架：直接使用功能即可</li></ul></li><li>社区</li><li>适用场景，设计理念</li><li>高内聚，低耦合</li></ol><h2 id="React-中-keys-的作用"><a href="#React-中-keys-的作用" class="headerlink" title="React 中 keys 的作用"></a>React 中 keys 的作用</h2><p>在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是最新创建的还是被移动而来的元素，从而减少不必要的元素重渲染</p><h2 id="如何避免组件的重新渲染"><a href="#如何避免组件的重新渲染" class="headerlink" title="如何避免组件的重新渲染"></a>如何避免组件的重新渲染</h2><p>React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用</p><ul><li>React.memo(): 这可以防止不必要地重新渲染函数组件</li><li>PureComponent: 这可以防止不必要地重新渲染类组件</li></ul><p>这两种方法都依赖于对传递给组件的 props 的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。</p><h2 id="react-组件通信如何实现"><a href="#react-组件通信如何实现" class="headerlink" title="react 组件通信如何实现"></a>react 组件通信如何实现</h2><ul><li>父 -&gt; 子: props</li><li>子 -&gt; 父: props + 回调</li><li>兄弟组件之间通信: 找到两个兄弟节点共同的父节点，结合 props</li><li>跨层级通信: Context</li><li>发布订阅模式: 发布者发布事件，订阅者监听事件并做出回应，通过引入 event 模块进行通信</li><li>全局状态管理工具: 借助 Redux 或 Mobx 等全局状态管理工具进行通信，这种工具会维护一个全局状态中心 Store，并根据不同的事件产生新的状态</li></ul><h2 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h2><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul><li>constructor: 通常用来初始化 state 和绑定 this</li><li>getDerivedStateFromProps: 静态方法, 接收新属性想去修改 state(配合 componentDidUpdate，可覆盖 componentWillReveiveProps 所有用法</li><li>render: 返回只需要渲染的内容</li><li>componentDidMount: 组件装载后调用，可以获取 DOM 节点并操作</li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul><li>getDerivedStateFromProps(在更新各挂载阶段都会调用)</li><li>shouldComponentUpdate: 是否触发重渲染，返回一个 boolean，通常用来优化性能</li><li>render: 更新阶段也会触发此生命周期</li><li>getSnapshotBeforeUpdate: 返回值会作为第三个参数传递给 componentDidUpdate (static getSnapshotBeforeUpdate -&gt; 代替 componentWillUpdate (在最终 render 前被调用)))</li><li>componentDidUpdate: 三个参数，prevProps、prevState、snapshot，最后在 componentDidUpdate 中统一触发回调或更新状态</li></ul><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><ul><li>componentWillUnmount: 当组件被卸载或销毁时调用，通常用于清除一些定时器，取消网络请求，清理无效 DOM 元素等垃圾清理工作</li></ul><h2 id="react-项目中有哪些细节可以优化？实际开发中都做过哪些性能优化"><a href="#react-项目中有哪些细节可以优化？实际开发中都做过哪些性能优化" class="headerlink" title="react 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化"></a>react 项目中有哪些细节可以优化？实际开发中都做过哪些性能优化</h2><p>分为: 开发过程中、上线之后的首屏、运行过程的状态</p><h3 id="上线之后的首屏及运行状态"><a href="#上线之后的首屏及运行状态" class="headerlink" title="上线之后的首屏及运行状态:"></a>上线之后的首屏及运行状态:</h3><ul><li><p>首屏优化一般涉及到几个指标 FP、FCP、FMP；要有一个良好的体验是尽可能的把 FCP 提前，需要做一些工程化的处理，去优化资源的加载</p><ul><li>FP: 页面在导航后首次呈现出不同于导航前内容的时间点;</li><li>FCP: 首次绘制任何文本，图像，非空白 canvas 或 SVG 的时间点;</li><li>FMP: 是由 Google 工程师引入的一种现代性能指标，它告诉我们页面何时 <strong>有用</strong>。其本质上是通过一种算法来猜测某个时间点可能是 FMP</li></ul></li><li><p>方式及分包策略，资源的减少是最有效的加快首屏打开的方式</p></li><li><p>对于 CSR 的应用，FCP 的过程一般是首先加载 js 与 css 资源，js 在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以 CSR 可以考虑使用骨架屏及预渲染（部分结构预渲染）、suspence 与 lazy 做懒加载动态组件的方式</p></li><li><p>当然还有另外一种方式就是 SSR 的方式，SSR 对于首屏的优化有一定的优势，但是这种瓶颈一般在 Node 服务端的处理，建议使用 stream 流的方式来处理，对于体验与 node 端的内存管理等，都有优势；</p></li><li><p>不管对于 CSR 或者 SSR，都建议配合使用 Service worker，来控制资源的调配及骨架屏秒开的体验</p></li><li><p>react 项目上线之后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数及耗时的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析</p></li><li><p>由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况之下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理</p></li><li><p>所有的运行状态优化，都是减少不必要的 render，React.useMemo 与 React.useCallback 也是可以做很多优化的地方</p></li><li><p>在很多应用中，都会涉及到使用 redux 以及使用 context，这两个都可能造成许多不必要的 render，所以在使用的时候，也需要谨慎的处理一些数据</p></li><li><p>最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理</p></li></ul><h3 id="实际项目中开发过程中还有很多其他的优化点"><a href="#实际项目中开发过程中还有很多其他的优化点" class="headerlink" title="实际项目中开发过程中还有很多其他的优化点"></a>实际项目中开发过程中还有很多其他的优化点</h3><ul><li>保证数据的不可变性</li><li>使用唯一的键值迭代</li><li>使用 web worker 做密集型的任务处理</li><li>不在 render 中处理数据</li><li>不必要的标签，使用 React.Fragments</li></ul><h2 id="react-最新版本解决了什么问题-加了哪些东西"><a href="#react-最新版本解决了什么问题-加了哪些东西" class="headerlink" title="react 最新版本解决了什么问题 加了哪些东西"></a>react 最新版本解决了什么问题 加了哪些东西</h2><h3 id="React-16-x-的三大新特性-Time-Slicing-Suspense，hooks"><a href="#React-16-x-的三大新特性-Time-Slicing-Suspense，hooks" class="headerlink" title="React 16.x 的三大新特性 Time Slicing, Suspense，hooks"></a>React 16.x 的三大新特性 Time Slicing, Suspense，hooks</h3><ul><li>Time Slicing</li></ul><p>（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能</p><ul><li>Suspense</li></ul><p>（解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式</p><ul><li>componentDidCatch</li></ul><p>此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。</p><h3 id="React16-8"><a href="#React16-8" class="headerlink" title="React16.8"></a>React16.8</h3><ul><li>加入 hooks，让 React 函数式组件更加灵活</li><li>hooks 之前，React 存在很多问题<ul><li>在组件间复用状态逻辑很难</li><li>复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。</li><li>class 组件的 this 指向问题 (如果在 render 中 bind(this)，会造成每次都返回一个新函数，造成对应组件的重渲染; 如果使用 () =&gt; func() 也会每次都造成组件的重渲染)</li><li>难以记忆的生命周期</li></ul></li><li>hooks 很好的解决了上述问题，hooks 提供了很多方法<ul><li>useState 返回有状态值，以及更新这个状态值的函数</li><li>useEffect 接受包含命令式，可能有副作用代码的函数。</li><li>useContext 接受上下文对象（从 React.createContext 返回的值）并返回当前上下文值，</li><li>useReducer useState 的替代方案。接受类型为(state，action) =&gt; newState 的 reducer，并返回与 dispatch 方法配对的当前状态。</li><li>useCallback 返回一个回忆的 memoized 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性</li><li>useMemo 纯的一个记忆函数</li><li>useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。</li><li>useImperativeMethods 自定义使用 ref 时公开给父组件的实例值</li><li>useMutationEffect 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发</li><li>useLayoutEffect DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染</li></ul></li></ul><h2 id="react-事件合成"><a href="#react-事件合成" class="headerlink" title="react 事件合成"></a>react 事件合成</h2><p><img src="/images/%E4%BA%8B%E4%BB%B6%E5%90%88%E6%88%90.png" class="lazyload" data-srcset="/images/%E4%BA%8B%E4%BB%B6%E5%90%88%E6%88%90.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="高阶组件"></p><p>react 根据 w3c 规范定义了每个事件处理函数的参数，即合成事件。react 在合成事件做了两件事，分别为事件委派和自动绑定。</p><ul><li>事件委派</li></ul><ol><li>事件处理程序将会传递 SyntheticEvent(事件合成) 的实例，这是一个跨浏览器原生事件包装器，它具有与浏览器原生事件相同的接口，支持 stopProgation 和 preventDefault，可以通过使用 nativeEvent 属性来访问原生事件对象，同时在所有浏览器中它们的工作方式都相同。</li><li>react 合成的 SyntheticEvent 采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。</li><li>react 并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件放到统一的事件队列中，用监听器做监听。</li><li>通过监听器上的映射来保存所有组件内部的事件监听和处理函数</li><li>组件挂载或卸载时，改变这个监听器，通过对象的方式插入 or 删除</li><li>事件发生时，先被监听器处理，然后通过映射调用真正的事件处理函数</li></ol><ul><li>自动绑定</li></ul><ol><li>在 react 组件中，每个方法的上下文都会指向改组件的实例，即自动绑定 this 为当前组件</li><li>react 会对这种引用做缓存，从而优化 cpu 和 内存</li><li>在使用 类组件或函数组件时，需手动实现 this 绑定</li></ol><h3 id="react-和-原生事件的执行顺序"><a href="#react-和-原生事件的执行顺序" class="headerlink" title="react 和 原生事件的执行顺序"></a>react 和 原生事件的执行顺序</h3><ol><li><p>原生事件，依次冒泡执行</p></li><li><p>react 合成事件，依次冒泡执行</p></li><li><p>document 上挂载的事件执行</p></li></ol><pre><code class="js">/* * 执行结果： * 1. dom child * 2. dom parent * 3. react child * 4. react parent * 5. dom document * */</code></pre><h3 id="react-事件与原生事件可以混用么"><a href="#react-事件与原生事件可以混用么" class="headerlink" title="react 事件与原生事件可以混用么"></a>react 事件与原生事件可以混用么</h3><p>React 事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发</p><h2 id="虚拟-dom-是什么"><a href="#虚拟-dom-是什么" class="headerlink" title="虚拟 dom 是什么"></a>虚拟 dom 是什么</h2><p>在原生的 JavaScript 程序中，我们直接对 DOM 进行创建和更改，而 DOM 元素通过我们监听的事件和我们的应用程序进行通讯。</p><p>而 React 会先将你的代码转换成一个 JavaScript 对象，然后这个 JavaScript 对象再转换成真实 DOM。这个 JavaScript 对象就是所谓的虚拟 DOM。</p><p>当我们需要创建或更新元素时， React 首先会让这个 VitrualDom 对象进行创建和更改，然后再将 VitrualDom 对象渲染成真实 DOM。</p><p>当我们需要对 DOM 进行事件监听时，首先对 VitrualDom 进行事件监听， VitrualDom 会代理原生的 DOM 事件从而做出响应。</p><h2 id="react-如何进行组件-逻辑复用"><a href="#react-如何进行组件-逻辑复用" class="headerlink" title="react 如何进行组件/逻辑复用"></a>react 如何进行组件/逻辑复用</h2><ol><li>HOC(高阶组件)</li><li>react-hooks</li><li>渲染属性(render props): 即通过 render 属性传递渲染内容</li></ol><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p><img src="/images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.png" class="lazyload" data-srcset="/images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="高阶组件"></p><p>高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</p><h3 id="通过属性代理实现高阶组件"><a href="#通过属性代理实现高阶组件" class="headerlink" title="通过属性代理实现高阶组件"></a>通过属性代理实现高阶组件</h3><p>函数返回一个我们自己定义的组件，然后在 render 中返回要包裹的组件，这样我们就可以代理所有传入的 props，并且决定如何渲染</p><pre><code class="jsx">function proxyHOC(WrappedComponent) &#123;  return class extends Component &#123;    render() &#123;      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;    &#125;  &#125;;&#125;</code></pre><p>对比原生组件增强的项:</p><ul><li>可操作所有传入的 props</li><li>可操作组件的生命周期</li><li>可操作组件的 static 方法</li><li>获取 refs</li></ul><h3 id="通过反向继承实现高阶组件"><a href="#通过反向继承实现高阶组件" class="headerlink" title="通过反向继承实现高阶组件"></a>通过反向继承实现高阶组件</h3><p>返回一个组件，继承原组件，在 render 中调用原组件的 render。由于继承了原组件，能通过 this 访问到原组件的 生命周期、props、state、render 等，相比属性代理它能操作更多的属性</p><pre><code class="jsx">function inheritHOC(WrappedComponent) &#123;  return class extends WrappedComponent &#123;    render() &#123;      return super.render();    &#125;  &#125;;&#125;</code></pre><p>对比原生组件增强的项:</p><ul><li>可操作所有传入的 props</li><li>可操作组件的生命周期</li><li>可操作组件的 static 方法</li><li>获取 refs</li><li>可操作 state</li><li>可以渲染劫持</li></ul><h3 id="HOC-在业务场景中有哪些实际应用场景"><a href="#HOC-在业务场景中有哪些实际应用场景" class="headerlink" title="HOC 在业务场景中有哪些实际应用场景"></a>HOC 在业务场景中有哪些实际应用场景</h3><p>HOC 可以实现的功能：</p><ul><li>组合渲染</li><li>条件渲染</li><li>操作 props</li><li>获取 refs</li><li>状态管理</li><li>操作 state</li><li>渲染劫持</li></ul><p>HOC 在业务中的实际应用场景：</p><ul><li>日志打点</li><li>权限控制</li><li>双向绑定</li><li>表单校验</li></ul><h2 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h2><h3 id="使用-react-hooks-好处是什么"><a href="#使用-react-hooks-好处是什么" class="headerlink" title="使用 react hooks 好处是什么"></a>使用 react hooks 好处是什么</h3><p>hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件</p><p>Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像 useEffect 这样的内置钩子。</p><h3 id="React-Hooks-的使用注意事项和问题"><a href="#React-Hooks-的使用注意事项和问题" class="headerlink" title="React Hooks 的使用注意事项和问题"></a>React Hooks 的使用注意事项和问题</h3><ul><li>只能在函数内部的最外层调用 hook，不要在循环、条件判断或者子函数中调用</li></ul><blockquote><p>因为 react hooks 内部是通过单项链表实现的，其内部的顺序是极其关键的，如果不按照规则使用，就会造成取值出现偏移的问题</p></blockquote><ul><li><p>只能在 React 的函数组件中调用 Hook，不要在其他的 js 函数里调用</p></li><li><p>为什么 useEffect 的第二个参数是空数组，就相当于 componentDidMount 只执行一次</p></li><li><p>自定义的 hook 是怎样操作组件的</p></li></ul><h3 id="react-hooks-如何保存状态"><a href="#react-hooks-如何保存状态" class="headerlink" title="react hooks 如何保存状态"></a>react hooks 如何保存状态</h3><ul><li>react hooks 和 类组件的状态值都被挂载在组件实例对象 FiberNode 的 memoizedState 属性中</li><li>react hooks 和 类组件的数据结构完全不同。类组件是直接把 state 属性中挂载的这个开发者自定义的对象给保存到 memoizedState 属性中；而 React Hooks 是用链表来保存状态的，memoizedState 属性保存的实际上是这个链表的头指针。</li><li>所有的 hooks 都以链表的形式挂载在 FiberNode.updateQueue 中</li></ul><h3 id="react-hooks-常用-api"><a href="#react-hooks-常用-api" class="headerlink" title="react hooks 常用 api"></a>react hooks 常用 api</h3><ul><li><p>基础 hooks</p><ol><li>useState: 状态钩子，为函数组件提供内部状态</li><li>useEffect: 副作用钩子，提供了类似于 componentDidMount 等生命周期钩子的功能</li><li>useContext: 共享钩子，在组件之间共享状态，可以解决 react 逐层通过 props 传递数据</li></ol></li><li><p>额外的 hooks</p><ol><li>useReducer: action 钩子，提供了状态管理，其基本原理是通过用户在页面上发起的 action，从而通过 reduce 方法来改变 state，从而实现页面和状态的通信，使用很像 redux</li><li>useCallBack: 把内联回调函数及依赖项数组作为参数传入 useCallback, 它将返回该回调函数的 memoized 版本, 该回调函数仅在某个依赖项改变时才会更新</li><li>useMemo: 把创建函数和依赖项数组作为参数传入 useMemo, 它仅会在某个依赖项改变时重新计算, 可以作为性能优化的手段。</li><li>useRef: 获取组件的实例，返回一个可变的 ref 对象, 返回的 ref 对象在组件的整个生命周期内保持不变</li><li>useLayoutEffect: 它会在所有 DOM 变更后同步调用 effect</li></ol></li></ul><h2 id="react-fiber"><a href="#react-fiber" class="headerlink" title="react fiber"></a>react fiber</h2><h3 id="什么是-fiber"><a href="#什么是-fiber" class="headerlink" title="什么是 fiber"></a>什么是 fiber</h3><ul><li>fiber 是一种基于浏览器的单线程调度算法</li><li>fiber 是一个执行单元, 每次执行完一个执行单元, react 就会检查还剩多少时间, 如果没有时间则将控制权转让。(利用浏览器的 requestIdleCallback api 实现, 其中如果浏览器一直很忙，则会判断 requestIdleCallback 的 timeout 参数，如果超过 timeout 的值，则会在下一帧强制执行)</li><li>fiber 是一种数据结构, react fiber 就是采用链表实现的, 每个虚拟 dom 都可以表示为一个 fiber</li><li>fiber 实现了自己的组件调用栈, 它以链表的形式遍历组件树, 可以灵活的暂停、继续和丢弃执行的任务</li></ul><blockquote><p>利用 requestIdleCallback 的回调可以充分的通过利用浏览器空闲时间来解决任务调度问题。由于 requestIdleCallback 的兼容性很差，所以 react 采用了 messageChannel 模拟实现了这一 api 的功能。</p></blockquote><blockquote><p>当浏览器很忙的时候，如 1000 / 60 ～ 16ms 时间间隔内都有任务执行，则会通过判断 requestIdleCallback 的 timeout 是否超时和该回调中的任务的优先级来强制在下一帧执行回调中的任务，避免卡顿现象。</p></blockquote><blockquote><p>react 里预订了 5 个优先级等级</p><ol><li>Immediate: 最高优先级, 这个优先级的任务应该被马上执行不能中断</li><li>UserBlocking: 这些任务一般是用户交互的结果, 需要即时得到反馈</li><li>Normal: 不需要用户立即就感受到变化, 比如网络请求</li><li>Low: 这些任务可以延后, 但是最终也需要执行</li><li>Idle: 可以被无限期延后</li></ol></blockquote><h3 id="fiber-解决的问题-背景"><a href="#fiber-解决的问题-背景" class="headerlink" title="fiber 解决的问题(背景)"></a>fiber 解决的问题(背景)</h3><ul><li>为了使 react 渲染过程中可以被中断，可以将控制权交还给浏览器, 可以让位给高优先级的任务，浏览器空闲后再恢复渲染。</li><li>对于计算量比较大的 js 计算或 dom 计算，就不会显得特别卡顿，而是一帧一帧的有规律的执行任务。</li><li>react 16 之前采用的是递归 diff, 想要中断递归是很困难的。</li><li>为了解决这个问题，我们将大型的计算拆分成一个个小型的计算，然后按照执行顺序异步调用，这样就不会长时间霸占线程，UI 也能够在两次计算执行的间隙进行更新，从而给用户及时的反馈。</li></ul><h3 id="fiber-实现原理"><a href="#fiber-实现原理" class="headerlink" title="fiber 实现原理"></a>fiber 实现原理</h3><ul><li>拆分：把渲染过程进行拆分成多个小任务</li><li>检查：每次执行完一个小任务，就去队列中检查是否有新的响应需要处理</li><li>继续执行：如果有就执行优化及更高的响应事件，如果没有继续执行后续任务</li></ul><h3 id="fiber-数据结构"><a href="#fiber-数据结构" class="headerlink" title="fiber 数据结构"></a>fiber 数据结构</h3><p>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：</p><pre><code class="js">const fiber = &#123;    stateNode,    // 节点实例    child,        // 子节点    sibling,      // 兄弟节点    return,       // 父节点&#125;;</code></pre><p>fiber 是个链表，有 child 和 sibing 属性，指向第一个子节点和相邻的兄弟节点，从而构成 fiber tree。return 属性指向其父节点</p><ul><li>更新队列，updateQueue，是一个链表，有 first 和 last 两个属性，指向第一个和最后一个 update 对象</li><li>每个 fiber 有一个属性 updateQueue 指向其对应的更新队列。</li><li>每个 fiber（当前 fiber 可以称为 current）有一个属性 alternate，开始时指向一个自己的 clone 体，update 的变化会先更新到 alternate 上，当更新完毕，alternate 替换 current。</li></ul><h3 id="fiber-的基本规则"><a href="#fiber-的基本规则" class="headerlink" title="fiber 的基本规则"></a>fiber 的基本规则</h3><ul><li><p>调和阶段<br>找出需要更新的工作 (Diff Fiber Tree), 就是一个计算阶段，计算结果可以被缓存，也可被打断</p></li><li><p>交付阶段<br>提交所有更新并渲染，为了防止页面抖动，不能被打断</p></li></ul><h3 id="fiber-的执行流程"><a href="#fiber-的执行流程" class="headerlink" title="fiber 的执行流程"></a>fiber 的执行流程</h3><ol><li>用户操作引起 setState 被调用，进而初始化一些数据结构</li><li>根据优先级插入队列相应位置，初始化两个更新的队列</li><li>开始进行任务分片调度，首先更新每个 fiber 的优先级，当 fiber 返回 null 时找到父级节点，然后将所有变化归到 root</li><li>把当前的更新添加到调度队列中，根据当前是否异步渲染，做异步调用</li><li>判断浏览器空闲时，完成下一个分片的工作，如果没有工作完，将会放弃</li><li>执行调和阶段和调度阶段</li></ol><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="setState-到底是异步还是同步"><a href="#setState-到底是异步还是同步" class="headerlink" title="setState 到底是异步还是同步"></a>setState 到底是异步还是同步</h3><p>有时表现出异步，有时表现出同步</p><ul><li>setState 只在合成事件和钩⼦函数中是 &quot;异步&quot; 的，在 原⽣事件 和 setTimeout 中都是同步的</li><li>setState 的 &quot;异步&quot; 并不是说内部由异步代码实现，其实本身执⾏的过程和代码都是同步的，只是 合成事件 和 钩⼦函数 的 调⽤顺序在更新之前，导致在合成事件和钩⼦函数中没法⽴⻢拿到更新后的值，形成了所谓的 &quot;异步&quot;，当然可以通过第⼆个参数 setState(partialState, callback)中的 callback 拿到更新后的结果</li><li>setState 的批量更新优化也是建⽴在 &quot;异步&quot;（合成事件、钩⼦函数）之上的，在 原⽣事件 和 setTimeout 中不会批量更新，在 &quot;异步&quot; 中如果对同⼀个值进⾏多次 setState，setState 的批量更新策略会对其进⾏覆盖，取最后⼀次的执⾏，如果是同时 setState 多个不同的值，在更新时会对其进⾏合并批量更新。</li></ul><h3 id="为什么-setState-不设计成同步的"><a href="#为什么-setState-不设计成同步的" class="headerlink" title="为什么 setState 不设计成同步的"></a>为什么 setState 不设计成同步的</h3><ul><li>保持内部的一致性和状态的安全性</li></ul><p>state, props, refs 一致性</p><ul><li>性能优化</li></ul><p>react 会对依据不同的调用源，给不同的 setState 调用分配不同的优先级</p><p>调用源包括：事件处理、网络请求、动画</p><ul><li>更多可能性</li></ul><p>异步获取数据后，统一渲染页面, 保持一致性</p><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><h3 id="redux-的⼯作流程"><a href="#redux-的⼯作流程" class="headerlink" title="redux 的⼯作流程"></a>redux 的⼯作流程</h3><ul><li>Store：保存数据的地⽅，你可以把它看成⼀个容器，整个应⽤只能有⼀个 Store；</li><li>State：Store 对象包含所有数据，如果想得到某个时点的数据，就要对 Store ⽣成快照，这种时点的数据集合，就叫 State；</li><li>Action： State 的变化， 会导致 View 的变化。但是，⽤户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了；</li><li>Action Creator：View 要发送多少种消息，就会有多少种 Action。如果都⼿写，会很麻烦，所以我们定义⼀个函数来⽣成 Action，这个函数就叫 Action Creator；</li><li>Reducer：Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做 Reducer。Reducer 是⼀个函数，它接受 Action 和当前 State 作为参数，返回⼀个新的 State；</li><li>dispatch：是 View 发出 Action 的唯⼀⽅法。</li></ul><ol><li>首先，用户通过 View 发出 Action，发出方式用到了 dispatch 方法</li><li>Store 调用 Reducer, 传入两个参数: 当前 State 和收到的 Action，Reducer 会返回新的 State</li><li>State ⼀旦有变化，Store 就会调⽤监听函数，来更新 View</li></ol><h3 id="redux-的三个原则"><a href="#redux-的三个原则" class="headerlink" title="redux 的三个原则"></a>redux 的三个原则</h3><ul><li>单个事件来源</li></ul><p>整个应用程序状态存储在单个存储中的对象中</p><ul><li>状态只读</li></ul><p>更改状态的唯一方法就是触发一个动作</p><ul><li>中间件</li></ul><p>action -&gt; reducer =&gt; action -&gt; middlewares -&gt; reducer</p><h2 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h2><h3 id="mobx-的工作流程"><a href="#mobx-的工作流程" class="headerlink" title="mobx 的工作流程"></a>mobx 的工作流程</h3><p><img src="/images/mobx%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="/images/mobx%E6%B5%81%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="mobx工作流程图"></p><h3 id="mobx-数据流向"><a href="#mobx-数据流向" class="headerlink" title="mobx 数据流向"></a>mobx 数据流向</h3><p>触发 action，在 action 中修改 state，通过 computed 拿到 state 的计算值，自动触发对应的 reactions，这里包含 autorun，渲染视图等。</p><blockquote><p>有一点需要注意：相对于 react 来说，mobx 没有一个全局的状态树，状态分散在各个独立的 store 中。</p></blockquote><h3 id="mobx-的工作原理"><a href="#mobx-的工作原理" class="headerlink" title="mobx 的工作原理"></a>mobx 的工作原理</h3><p>使用 Proxy 来拦截对数据的访问，一旦值发生变化，将会调用 react 的 render 方法来实现重新渲染视图的功能或者触发 autorun 等。</p><h3 id="Mobx-的核心原理"><a href="#Mobx-的核心原理" class="headerlink" title="Mobx 的核心原理"></a>Mobx 的核心原理</h3><p>通过 action 触发 state 的变化，进而触发 state 的衍生对象（computed value &amp; Reactions）</p><h2 id="redux-和-mobx-对比"><a href="#redux-和-mobx-对比" class="headerlink" title="redux 和 mobx 对比"></a>redux 和 mobx 对比</h2><ol><li>Redux 要解决的问题是统一数据流，数据流完全可控并可追踪。要实现该目标，便需要进行相关的约束</li><li>Redux 由此引出 dispatch action reducer 等概念，对 state 的概念进行强约束，然而对于一些项目来说，太过强，便失去了灵活性。Mobx 便是填补此空缺的</li><li>redux 将数据保存在单一的 store 中，mobx 将数据保存在分散的多个 store 中</li><li>redux 使用 plain object 保存数据，需要手动处理变化后的操作；mobx 使用 observable 保存数据，数据变化后自动处理响应的操作</li><li>redux 使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx 中的状态是可变的，可以直接对其进行修改</li><li>mobx 相对来说比较简单，在其中有很多的抽象，mobx 更多的使用面向对象的编程思维；redux 会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li><li>mobx 中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而 redux 提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li><li>使用 mobx 的 react 感觉很像 vue</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h3><h4 id="1-操作系统定义"><a href="#1-操作系统定义" class="headerlink" title="1. 操作系统定义"></a>1. 操作系统定义</h4><p>操作系统是运行在内核态的软件，它执行两个基本上独立的任务。</p><ul><li>隐藏计算机底层硬件的实现，为用户及应用程序提供一个资源集的清晰抽象。</li><li>管理计算机硬件资源。</li></ul><p>任何操作系统的核心是它可处理的系统调用集。这些系统带欧阳真实地说明了操作系统做的工作。</p><h4 id="2-计算机运行模式"><a href="#2-计算机运行模式" class="headerlink" title="2. 计算机运行模式"></a>2. 计算机运行模式</h4><p>多数计算机有两种运行模式：内核态和用户态。</p><p>软件中最基础的部分是操作系统，它运行在内核态。这内核态模式下，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下，在用户态下，只能使用机器指令中的一个子集。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-1.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="计算机运行模式"></p><h4 id="3-shell-与-GUI"><a href="#3-shell-与-GUI" class="headerlink" title="3. shell 与 GUI"></a>3. shell 与 GUI</h4><p>用户与之交互的程序，基于文本的通常称为 shell，而基于图标的则称为图形用户界面（GUI）。</p><p>它们并不是操作系统的一部分，它们是运行在用户态最低层次的用户接口程序</p><h4 id="4-对于抽象的理解"><a href="#4-对于抽象的理解" class="headerlink" title="4. 对于抽象的理解"></a>4. 对于抽象的理解</h4><p>现代计算机系统中，大量使用了抽象这一概念。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分为两个可管理的部分。其中第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。</p><p>以抽象的角度看操作系统，它的任务就是创建好的抽象，并实现和管理它所创建的抽象。</p><h4 id="5-多路复用资源方式"><a href="#5-多路复用资源方式" class="headerlink" title="5. 多路复用资源方式"></a>5. 多路复用资源方式</h4><p>在时间上复用：当一种资源在时间上复用时，不同的程序或用户轮流使用它。</p><p>在空间上复用：每个客户得到资源的一部分。</p><h4 id="6-I-O-设备的结构"><a href="#6-I-O-设备的结构" class="headerlink" title="6. I/O 设备的结构"></a>6. I/O 设备的结构</h4><p>I/O 设备一般包括两个部分：设备控制器和设备本身。控制器插在电路板上的一块芯片或一组芯片，这块电路板物理地控制芯片，它从操作系统接收命令。</p><p>控制器的任务是为操作系统提供一个简单的接口。每类设备控制器是不同的，所以需要不同的软件进行控制。专门与控制器对话，发出命令并接收响应的软件，称为设备驱动程序。为了使用设备驱动程序，必须要把设备驱动程序装入到操作系统中，这样它可在核心态中运行。</p><p>每个设备控制器都有少量的用于通信的寄存器，所有的寄存器的集合构成了 I/O 空间。</p><h4 id="7-IDE-概念"><a href="#7-IDE-概念" class="headerlink" title="7. IDE 概念"></a>7. IDE 概念</h4><p>IDE 表示集成驱动电子设备，是许多计算机的磁盘标准。</p><h4 id="8-实现输入输出的三种方式"><a href="#8-实现输入输出的三种方式" class="headerlink" title="8. 实现输入输出的三种方式"></a>8. 实现输入输出的三种方式</h4><p>第一种方式，用户程序发出一个系统调用，内核将其翻译成一个对应设备驱动程序的过程调用。然后设备驱动程序启动 I/O 并在一个连续不断的循环中检查该设备，看该设备是否完成了工作。当 I/O 结束后，设备驱动程序把数据送到指定的地方（若有此需要），并返回。然后操作系统将控制返回给调用者。这种方式称为忙等待（busy waiting），其缺点是要占据 CPU ，CPU 一直轮询设备直到对应的 I/O 操作完成。</p><p>第二种方式，设备驱动程序启动设备并且让该设备在操作完成时发出一个中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备的操作完毕时，它发出一个中断通知操作完成。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-2.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="终端实例"></p><p>第三种方式，为 I/O 使用一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，它可以控制在内存和某些控制器之间的位流，而无须持续的 CPU 干预。</p><h4 id="9-CMOS-存储器"><a href="#9-CMOS-存储器" class="headerlink" title="9. CMOS 存储器"></a>9. CMOS 存储器</h4><p>CMOS 存储器是易失性的。许多计算机利用 CMOS 存储器保持当前时间和日期。 CMOS 存储器和递增时间的时钟电路有一块小电池驱动，所以，即使计算机没有上电，时间也可以正确地更新。</p><h4 id="10-USB-概念"><a href="#10-USB-概念" class="headerlink" title="10. USB 概念"></a>10. USB 概念</h4><p>USB 是通用串行总线，是用来将所有的慢速 I/O 设备，诸如键盘和鼠标，与计算机相连。USB 是一种集中式总线，其根设备每 1ms 轮询一次 I/O 设备，看是否有消息收发。所有的 USB 设备共享一个 USB 设备驱动器，于是就不需要为新的 USB 设备安装新的设备驱动器了。</p><h4 id="11-即插即用概念"><a href="#11-即插即用概念" class="headerlink" title="11. 即插即用概念"></a>11. 即插即用概念</h4><p>在一般的计算机工作环境下，操作系统必须了解有些什么外部设备连接到计算机上，并对它们进行配置。这种需求导致了 Intel 和微软设计了一种名为即插即用的 I/O 系统。</p><p>在即插即用之前，每块 I/O 卡有一个固定的中断请求级别和用于其 I/O 寄存器的固定地址。即插即用所做的工作是，系统自动地收集有关 I/O 设备的信息，集中赋予 I/O 地址，然后通知每块卡所用的数值。</p><h4 id="12-计算机的启动"><a href="#12-计算机的启动" class="headerlink" title="12. 计算机的启动"></a>12. 计算机的启动</h4><p>Pentium 的简要启动过程如下。在每个 Pentium 上有一块母板。在母板上有一个称为基本输入输出系统（Basic Input Output System，BIOS）的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、进行磁盘 I/O 以及其他过程。现在这个程序存放在一块闪速 RAM 中，它是非可易失性的，但是在发现 BIOS 中有错时可以通过操作系统对它进行更新。</p><p>简要过程如下：</p><ol><li>BIOS 开始运行。它首先检查计算机设备的状态信息是否正常。</li><li>扫描并记录总线所连设备。</li><li>依次搜索启动设备，导入操作系统。</li><li>操作系统询问 BIOS ，获得配置信息，获取所有设备的驱动程序并调入内核。</li><li>初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或 GUI。</li></ol><h4 id="13-操作系统分类"><a href="#13-操作系统分类" class="headerlink" title="13. 操作系统分类"></a>13. 操作系统分类</h4><p>大型机操作系统、服务器操作系统、多处理器操作系统、个人计算机操作系统、掌上计算机操作系统、嵌入式操作系统、传感器节点操作系统、实时操作系统、智能卡操作系统</p><h4 id="14-实时操作系统的基本概念"><a href="#14-实时操作系统的基本概念" class="headerlink" title="14. 实时操作系统的基本概念"></a>14. 实时操作系统的基本概念</h4><p>实时操作系统的特征是将时间作为关键参数。通常分为硬实时操作系统和软实时操作系统。</p><p>在硬实时操作系统中，某个规定的动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p><p>在软实时操作系统中，偶尔违反最终时限是不希望的，但可以接受，并且不会引起任何实时性的损害。</p><h4 id="15-UID"><a href="#15-UID" class="headerlink" title="15. UID"></a>15. UID</h4><p>系统管理器授权每个进程使用一个给定的 UID 标识。每个被启动的进程都有一个启动该进程的用户 UID 。子进程与父进程拥有一样 UID。用户可以是某个组的成员，每个组也有一个 GID 标识。</p><h4 id="16-文件路径"><a href="#16-文件路径" class="headerlink" title="16. 文件路径"></a>16. 文件路径</h4><p>在 UNIX 中，绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用正斜线 <code>/</code> 隔开。最开始的正斜线标识这是从根目录开始的绝对路径。</p><p>在 MS-DOS 和 Windows 中，用反斜线 <code>\</code> 作为分隔符。</p><h4 id="17-文件系统安装"><a href="#17-文件系统安装" class="headerlink" title="17. 文件系统安装"></a>17. 文件系统安装</h4><p>UNIX 一个重要概念是安装文件系统。几乎所有的个人计算机都有一个或多个光盘驱动器，可以插入 CD-ROM 和 DV D。它们几乎都有 USB 接口，可以插入 USB 存储棒（实际是固态磁盘驱动器）。为了提供一个出色的方式处理可移动介质，UNIX 允许把在 CD-ROM 或 DVD 上的文件系统接入到主文件树上。 mount 系统调用允许把在 CD-ROM 上的文件系统连接到程序所希望的根文件系统上。</p><h4 id="18-特殊文件"><a href="#18-特殊文件" class="headerlink" title="18. 特殊文件"></a>18. 特殊文件</h4><p>提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可通过同样的系统调用进行读写。</p><p>有两类特殊文件：块特殊文件和字符特殊文件。</p><p>块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读第 4 块，程序可以直接访问设备的第 4 块而不必考虑存放该文件的文件系统结构。</p><p>字符特殊文件用于打印机、调制解调器和其他接收或输出字符流的设备。按照惯例，特殊文件保存在 /dev 目录中。例如，/dev/lp 是打印机。</p><h4 id="19-文件保护"><a href="#19-文件保护" class="headerlink" title="19. 文件保护"></a>19. 文件保护</h4><p>UNIX 操作系统通过对每个文件赋予一个 9 位的二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个 3 位字段，一个用于所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是知名的 rwx 位。</p><h4 id="20-系统调用概念"><a href="#20-系统调用概念" class="headerlink" title="20. 系统调用概念"></a>20. 系统调用概念</h4><p>如果一个进程正在用户态中运行一个用户程序，并且需要一个系统服务，比如从一个文件读数据，那么它就必须执行一个陷阱或系统调用指令，将控制转移到操作系统。操作系统接着通过参数检查，找出所需要的调用进程。然后，它执行系统调用，并把控制返回给在系统调用后面跟随着的指令。在某种意义上，进行系统调用就像进行一个特殊的过程调用，但是只有系统调用可以进入内核，而过程调用则不能。</p><h4 id="21-POSIX"><a href="#21-POSIX" class="headerlink" title="21. POSIX"></a>21. POSIX</h4><p>UNIX 有很多不兼容的版本，从而导致了混乱。为了能使编写的程序能够在任何版本的 UNIX 系统运行，IEEE 提出了一个 UNIX 标准，称为 POSIX，目前大多数 UNIX 版本都支持他。 POSIX 标准定义了凡是 UNIX 必须支持的小型系统调用接口。</p><h4 id="22-Windows-Win32-API"><a href="#22-Windows-Win32-API" class="headerlink" title="22. Windows Win32 API"></a>22. Windows Win32 API</h4><p>Windows 和 UNIX 的主要差别在于编程方式。一个 UNIX 程序包括做各种处理的代码以及从事完成特定服务的系统调用。相反，一个 Windows 程序通常是一个事件驱动程序。其中主程序等待某些事件发生，然后调用一个过程处理该事件。</p><p>在 UNIX 中，系统调用（如 read）和系统调用所使用的库过程（如 read）之间几乎是一一对应的关系。换句话说，对于每个系统调用，差不多就涉及一个被调用的库过程。</p><p>在 Windows 中，情况就大不相同了。首先，库调用和实际的系统调用是几乎不对应的。微软定义了一套过程，称为应用编程接口（Application Program Interface，Win32 API），程序员用这套过程获得操作系统的服务。</p><p>Win32 并不是非常统一的或有一致的接口。其主要原因是由于 Win32 需要与早期的在 Windows 3.x 中使用的 16 位接口向后兼容。</p><p>Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。</p><h4 id="23-操作系统结构"><a href="#23-操作系统结构" class="headerlink" title="23. 操作系统结构"></a>23. 操作系统结构</h4><p>单体结构、层次式结构、微内核、客户机-服务器模式、虚拟机、外核、</p><h4 id="24-微内核的概念"><a href="#24-微内核的概念" class="headerlink" title="24. 微内核的概念"></a>24. 微内核的概念</h4><p>在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。</p><h4 id="25-机制与策略分离原则"><a href="#25-机制与策略分离原则" class="headerlink" title="25. 机制与策略分离原则"></a>25. 机制与策略分离原则</h4><p>策略指的是做什么，机制指的是怎么做。例如一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行在具有最高优先级进程中可以运行的某个进程。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程以优先级）可以由用户态中的进程完成。在这个方式中，机制和策略是分离的，从而使系统内核变得更小。</p><h4 id="26-make-程序"><a href="#26-make-程序" class="headerlink" title="26. make 程序"></a>26. make 程序</h4><p>在 UNIX 系统中，有个名为 make 的程序（其大量的变体如 gmake、pmake 等），它读入 Makefile ，该 Makefile 说明哪个文件与哪个文件相关。make 的作用是，在构建操作系统二进制码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后，是否有任何它依赖（代码和头文件）的文件已经被修改了。如果有，目标文件需要重新编译。在大型项目中，创建 Makefile 是一件容易出错的工作，所以出现了一些工具使该工作能够自动完成。</p><h3 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h3><h4 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h4><h4 id="1-进程模型"><a href="#1-进程模型" class="headerlink" title="1. 进程模型"></a>1. 进程模型</h4><p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p><p>由于 CPU 在各进程之间来回快速切换，所以每个进程执行其运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常也不可再现。所以，在对进程编程时决不能对时序做任何确定的假设。</p><h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><p>有 4 种主要事件导致进程的创建：</p><ul><li><p><strong>系统初始化</strong></p><blockquote><p>启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反，却具有某些专门的功能。停留在后台处理诸如电子邮件、Web 页面、新闻、打印之类活动的进程称为守护进程</p></blockquote></li><li><p><strong>执行了正在运行的进程所调用的进程创建系统调用</strong></p><blockquote><p>一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以容易地划分成若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。</p></blockquote></li><li><p><strong>用户请求创建一个新进程</strong></p><blockquote><p>在交互式系统中，键入一个命令或者点（双）击一个图标就可以启动一个程序。这两个动作中的任何一个都会开始一个新的进程，并在其中运行所选择的程序。</p></blockquote></li><li><p><strong>一个批处理作业的初始化</strong></p><blockquote><p>最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中（可能是远程地）提交批处理作业。在操作系统认为有资源可运行另一个作业时，它创建一个新的进程，并运行其输入队列中的下一个作业。</p></blockquote></li></ul><p>在 UNIX 系统中，只有一个系统调用可以用来创建新进程：fork。在调用了 fork 后，这两个进程（父进程和子进程）拥有相同的存储映像、同样的环境字符串和同样的打开文件。</p><p>在 Windows 中，一个 Win32 函数调用 CreateProcess 既处理进程的创建，也负责把正确的程序装入新的进程。</p><p>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。</p><h4 id="3-进程的终止"><a href="#3-进程的终止" class="headerlink" title="3. 进程的终止"></a>3. 进程的终止</h4><p>进程在创建之后，它开始运行，完成其工作。但永恒是不存在的，进程也一样。迟早这个新的进程会终止，通常由下列条件引起：</p><ul><li><p><strong>正常退出（自愿的）</strong></p><blockquote><p>多数进程是由于完成了它们的工作而终止。在 UNIX 中该调用是 exit，而在 Windows 中，相关的调用是 ExitProcess 。</p></blockquote></li><li><p><strong>出错退出（自愿的）</strong></p><blockquote><p>进程终止的第二个原因是进程发现了严重错误。</p></blockquote></li><li><p><strong>严重错误（非自愿）</strong></p><blockquote><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所致。</p></blockquote></li><li><p><strong>被其他进程杀死（非自愿）</strong></p><blockquote><p>第四种终止进程的原因是，某个进程执行一个系统调用通知操作系统杀死某个其他进程。在 UNIX 中，这个系统调用是 kill 。在 Win32 中对应的函数是 TerminateProcess 。</p></blockquote></li></ul><h4 id="4-进程的层次结构"><a href="#4-进程的层次结构" class="headerlink" title="4. 进程的层次结构"></a>4. 进程的层次结构</h4><p>某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。</p><p>在 UNIX 中，进程和它的所有子女以及后裔共同组成一个进程组。</p><p>在 Windows 中没有进程层次的概念，所有的进程都是地位相同的。惟一类似于进程层次的暗示是在创建进程的时侯，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他进程，这样就不存在进程层次了。</p><h4 id="5-UNIX-启动时的初始化"><a href="#5-UNIX-启动时的初始化" class="headerlink" title="5. UNIX 启动时的初始化"></a>5. UNIX 启动时的初始化</h4><p>一个称为 init 的特殊进程出现在启动映像中。当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登录进程就执行一个 shell 准备接收命令。所接收的这些命令会启动更多的进程，以此类推。这样，在整个系统中，所有的进程都属于以 init 为根的一棵树。</p><h4 id="6-进程的状态"><a href="#6-进程的状态" class="headerlink" title="6. 进程的状态"></a>6. 进程的状态</h4><p>进程存在三种状态：</p><ul><li>运行态（该时刻进程实际占用 CPU）。</li><li>就绪态（可运行，但因为其他进程正在运行而暂时停止）。</li><li>阻塞态（除非某种外部事件发生，否则进程不能运行）。</li></ul><p>状态间的转化关系为</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-3.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="进程间状态转换"></p><h4 id="7-进程的实现"><a href="#7-进程的实现" class="headerlink" title="7. 进程的实现"></a>7. 进程的实现</h4><p>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程占用一个进程表项。（也可称为进程控制块。）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p><h4 id="8-多道程序设计模型"><a href="#8-多道程序设计模型" class="headerlink" title="8. 多道程序设计模型"></a>8. 多道程序设计模型</h4><p>采用多道程序设计可以提高 CPU 的利用率。从概率的角度来看 CPU 的利用率。假设一个进程等待 I/O 操作的时间与其停留在内存中时间的比为 。当内存中同时有 n 个进程时，则所有 n 个进程都在等待 I/O（此时 CPU 空转）的概率是 pⁿ 。CPU 的利用率由下面的公式给出：</p><blockquote><p>CPU 利用率 = 1-pⁿ</p></blockquote><h4 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h4><h4 id="1-线程的使用原因"><a href="#1-线程的使用原因" class="headerlink" title="1. 线程的使用原因"></a>1. 线程的使用原因</h4><p>人们需要多线程的主要原因是，在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得更简单。</p><p>第二个关于需要多线程的理由是，由于线程比进程更轻量级，所以它们比进程更容易（即更快）创建，也更容易撤销。在许多系统中，创建一个线程较创建一个进程要快 10 ～ 100 倍。</p><p>需要多线程的第三个原因涉及性能方面的讨论。若多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。</p><h4 id="2-线程模型"><a href="#2-线程模型" class="headerlink" title="2. 线程模型"></a>2. 线程模型</h4><p>进程拥有一个执行的线程，通常简写为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈，用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的过程。尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在 CPU 上被调度执行的实体。</p><p>线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大独立性的多个线程执行。在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。</p><h4 id="3-在用户空间中实现线程"><a href="#3-在用户空间中实现线程" class="headerlink" title="3. 在用户空间中实现线程"></a>3. 在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。线程在一个运行时系统的顶部运行，这个运行时系统是一个管理线程的过程的集合。我们已经见过其中的四个过程：pthread_create ，pthread_exit ，pthread_join 和 pthread_yield 。不过，一般还会有更多的过程。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-4.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用户线程实现"></p><p>在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和内核中的进程表类似。该线程表由运行时系统管理。当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。</p><p><strong>优点</strong></p><ol><li><p>用户级线程包可以在不支持线程的操作系统上实现。</p></li><li><p>线程的切换可以在几条指令内完成。进行类似于这样的线程切换至少比陷入内核要快一个数量级（或许更多）。</p></li><li><p>保存线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。另一方面，不需要陷阱，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。</p></li><li><p>它允许每个进程有自己定制的调度算法。</p></li></ol><p><strong>缺点</strong></p><ol><li><p>第一个问题是如何实现阻塞系统调用。假设在还没有任何击键之前，一个线程读取键盘。让该线程实际进行该系统调用是不可接受的，因为这会停止所有的线程。</p></li><li><p>页面故障问题。如果有一个线程引起页面故障，内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。</p></li><li><p>如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃 CPU 。</p></li><li><p>通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是 CPU 密集型而且极少有阻塞的应用程序而言，没有很大的意义。</p></li></ol><h4 id="4-在内核中实现线程"><a href="#4-在内核中实现线程" class="headerlink" title="4. 在内核中实现线程"></a>4. 在内核中实现线程</h4><p>在内核中实现线程时，内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。内核的线程表保存了每个线程的寄存器、状态和其他信息。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-5.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="内核线程实现"></p><p>所有能够阻塞线程的调用都以系统调用的形式实现，这与运行时系统过程相比，代价是相当可观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪线程）或者运行另一个进程中的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的 CPU （或者没有可运行的线程存在了）为止。</p><h4 id="5-混合实现"><a href="#5-混合实现" class="headerlink" title="5. 混合实现"></a>5. 混合实现</h4><p>人们已经研究了各种试图将用户级线程的优点和内核级线程的优点结合起来的方法。一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-6.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="混合线程实现"></p><p>采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。</p><h4 id="6-调度程序激活机制"><a href="#6-调度程序激活机制" class="headerlink" title="6. 调度程序激活机制"></a>6. 调度程序激活机制</h4><p>调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。</p><p>使该机制工作的基本思路是，当内核了解到一个线程被阻塞之后，内核通知该进程的运行时系统，。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这个机制称为上行调用。一旦如此激活，运行时系统就重新调度其线程。</p><p><strong>调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。</strong></p><h4 id="7-弹出式线程"><a href="#7-弹出式线程" class="headerlink" title="7. 弹出式线程"></a>7. 弹出式线程</h4><p>一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。</p><p>弹出式线程的关键好处是，由于这种线程相当新，没有历史这样，就有可能快速创建这类线程。对该新线程指定所要处理的消息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。</p><h4 id="三、-进程间通信"><a href="#三、-进程间通信" class="headerlink" title="三、 进程间通信"></a>三、 进程间通信</h4><p>进程间通信需要关注的三个问题：</p><ol><li><p>一个进程如何把信息传递给另一个。</p></li><li><p>如何确保两个或更多的进程在关键活动中不会出现交叉。</p></li><li><p>正确的顺序。</p></li></ol><h4 id="1-竞争条件"><a href="#1-竞争条件" class="headerlink" title="1. 竞争条件"></a>1. 竞争条件</h4><p>两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，称为竞争条件。</p><h4 id="2-临界区"><a href="#2-临界区" class="headerlink" title="2. 临界区"></a>2. 临界区</h4><p>在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作。我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够适当地安排，使得两个进程不可能同时处于临界区中，就能够避免竞争条件。</p><p>对于保证使用共享数据的并发进程能够正确和高效地进行协作，一个好的解决方案，需要满足以下 4 个条件：</p><ul><li>任何两个进程不能同时处于其临界区。</li><li>不应对 CPU 的速度和数量做任何假设。</li><li>临界区外运行的进程不得阻塞其他进程。</li><li>不得使进程无限期等待进入临界区。</li></ul><h4 id="3-忙等待的互斥"><a href="#3-忙等待的互斥" class="headerlink" title="3. 忙等待的互斥"></a>3. 忙等待的互斥</h4><h5 id="（1）-屏蔽中断"><a href="#（1）-屏蔽中断" class="headerlink" title="（1） 屏蔽中断"></a>（1） 屏蔽中断</h5><p>在单处理器系统中，最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。屏蔽中断后，时钟中断也被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换，这样，在屏蔽中断之后 CPU 将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不必担心其他进程介入。</p><p><strong>缺点：</strong></p><ol><li>若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。</li><li>如果系统是多处理器（有两个或可能更多的处理器），则屏蔽中断仅仅对执行 disable 指令的那个 CPU 有效。其他 CPU 仍将继续运行，并可以访问共享内存。</li></ol><p>但是对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。</p><p>所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。</p><h5 id="（2）-锁变量"><a href="#（2）-锁变量" class="headerlink" title="（2） 锁变量"></a>（2） 锁变量</h5><p>设想有一个共享（锁）变量，其初始值为 0。当一个进程想进入其临界区时，它首先测试这把锁。如果该锁的值为 0，则该进程将其设置为 1 并进入临界区。若这把锁的值已经为 1，则该进程将等待直到其值变为 0。于是，0 就表示临界区内没有进程，1 表示已经有某个进程进入临界区。</p><p><strong>缺点：锁变量的读写不是原子操作，可能被其他进程中断</strong></p><p>假设一个进程读出锁变量的值并发现它为 0，而恰好在它将其值设置为 1 之前，另一个进程被调度运行，将该锁变量设置为 1。当第一个进程再次能运行时，它同样也将该锁设置为 1，则此时同时有两个进程进入临界区中。</p><h5 id="（3）严格轮换法"><a href="#（3）严格轮换法" class="headerlink" title="（3）严格轮换法"></a>（3）严格轮换法</h5><p>定义一个整型变量 turn ，初始值为 0，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 turn ，发现其值为 0，于是进入临界区。进程 1 也发现其值为 0，所以在一个等待循环中不停地测试 turn ，看其值何时变为 1。连续测试一个变量直到某个值出现为止，称为忙等待。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-7.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="严格轮换法"></p><p>只有在有理由认为等待时间是非常短的情形下，才使用忙等待。用于忙等待的锁，称为自旋锁（spin lock）。</p><p><strong>缺点：</strong></p><ol><li><p>采用忙等待的方式，会浪费 CPU 时间。</p></li><li><p>该方案要求两个进程严格地轮流进入它们的临界区，会造成一个临界区外运行的进程阻塞其他进程的情况。</p></li></ol><h5 id="（4）Peterson-解法"><a href="#（4）Peterson-解法" class="headerlink" title="（4）Peterson 解法"></a>（4）Peterson 解法</h5><p>在使用共享变量（即进入其临界区）之前，各个进程使用其进程号 0 或 1 作为参数来调用 enter_region 。该调用在需要时将使进程等待，直到能安全地进入临界区。在完成对共享变量的操作之后，进程将调用 leave_region ，表示操作已完成，若其他的进程希望进入临界区，则现在就可以进入。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-8.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Peterson 解法"></p><h5 id="（5）TSL-指令"><a href="#（5）TSL-指令" class="headerlink" title="（5）TSL 指令"></a>（5）TSL 指令</h5><p>TSL 指令是硬件支持的一种方案，称为测试并加锁，它将一个内存字 lock 读到寄存器 RX 中，然后在该内存地址上存一个非零值。</p><p>读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行 TSL 指令的 CPU 将锁住内存总线，以禁止其他 CPU 在本指令结束之前访问内存。因此不会出现前面第二种方法锁变量的问题。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-9.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TSL 指令"></p><p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程用一条普通的 move 指令将 lock 的值重新设置为 0。</p><p>一个可替代 TSL 的指令是 XCHG ，它原子性地交换了两个位置的内容，它本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU 在低层同步中使用 XCHG 指令。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-10.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="XCHG 指令"></p><p><strong>缺点：</strong></p><ol><li>采用忙等待的方式，会浪费 CPU 时间。</li></ol><h4 id="4-睡眠与唤醒"><a href="#4-睡眠与唤醒" class="headerlink" title="4. 睡眠与唤醒"></a>4. 睡眠与唤醒</h4><p>Peterson 解法和 TSL 或 XCHG 解法都是正确的，但它们都有忙等待的缺点。这种方法不仅浪费了 CPU 时间，而且还可能引起预想不到的结果。</p><p>我们可以使用睡眠与唤醒的机制，使它们在无法进入临界区时将阻塞，而不是忙等待。</p><p>最简单的是 sleep 和 wakeup 。 sleep 是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup 调用有一个参数，即要被唤醒的进程。</p><p><strong>缺点：</strong></p><p>参考生产者-消费者问题，发给一个（尚）未睡眠进程的 wakeup 信号会出现丢失，从而出现生产者和消费者同时睡眠的情况。</p><p>一种快速的弥补方法是修改规则，加上一个唤醒等待位。当一个 wakeup 信号发送给一个清醒的进程信号时，将该位置 1。随后，当该进程要睡眠时，如果唤醒等待位为 1，则将该位清除，而该进程仍然保持清醒。但原则上讲，这并没有从根本上解决问题。</p><h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h4><p>信号量是一个整型变量用来累计唤醒次数，供以后使用。一个信号量的取值可以为 0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。</p><p>对信号量一共有两种操作：down 和 up （分别为一般化后的 sleep 和 wakeup ）。</p><p>对一信号量执行 down 操作，则是检查其值是否大于 0。若该值大于 0，则将其值减 1（即用掉一个保存的唤醒信号）并继续；若该值为 0，则进程将睡眠，而且此时 down 操作并未结束。</p><p>对一信号量执行 up 操作，会对信号量的值增 1。如果一个或多个进程在该信号量上睡眠，信号量的值仍旧是 0，但在其上睡眠的进程会被唤醒一个。</p><p>检查数值、修改变量值以及可能发生的睡眠和唤醒操作均作为一个单一的、不可分割的原子操作完成。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么都不执行。</p><h4 id="6-互斥量"><a href="#6-互斥量" class="headerlink" title="6. 互斥量"></a>6. 互斥量</h4><p>如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量（mutex）。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。</p><p>互斥量是一个可以处于两态之一的变量：解锁和加锁。当一个线程（或进程）需要访问临界区时，它调用 mutex_lock 。如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用 mutex_unlock 。如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-11.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="互斥量"></p><p>enter_region 和 mutex_lock 的代码很相似，但有一个关键的区别。</p><p>当 enter_region 进入临界区失败时，它始终重复测试锁（忙等待）。实际上，由于时钟超时的作用，会调度其他进程运行。这样迟早拥有锁的进程会进入运行并释放锁。</p><p>在（用户）线程中，情形有所不同，因为没有时钟停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁。因此当 mutex_lock 取锁失败时，它调用 thread_yield 将 CPU 放弃给另一个线程。这样，就没有忙等待。在该线程下次运行时，它再一次对锁进行测试。</p><h4 id="7-条件变量"><a href="#7-条件变量" class="headerlink" title="7. 条件变量"></a>7. 条件变量</h4><p>条件变量允许线程由于一些未达到的条件而阻塞。</p><p>与条件变量相关的最重要的两个操作是 pthread_cond_wait 和 pthread_cond_signal 。前者阻塞调用线程直到另一其他线程向它发信号（使用后一个调用）。</p><p>条件变量（不像信号量）不会存在内存中。如果将一个信号量传递给一个没有线程在等待的条件变量，那么这个信号就会丢失。</p><h4 id="8-管程"><a href="#8-管程" class="headerlink" title="8. 管程"></a>8. 管程</h4><p>管程是一种高级同步原语，管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。</p><p>当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果</p><p>管程提供了一种实现互斥的简便途径，通过临界区互斥的自动化，管程比信号量更容易保证并行编程的正确性。</p><h4 id="9-消息传递"><a href="#9-消息传递" class="headerlink" title="9. 消息传递"></a>9. 消息传递</h4><p>这种进程间通信的方法使用两条原语 send 和 receive ，它们像信号量而不像管程，是系统调用而不是语言成分。</p><p>前一个调用向一个给定的目标发送一条消息，后一个调用从一个给定的源（或者是任意源，如果接收者不介意的话）接收一条消息。如果没有消息可用，则接收者可能被阻塞，直到一条消息到达，或者，带着一个错误码立即返回。</p><h4 id="10-屏障"><a href="#10-屏障" class="headerlink" title="10. 屏障"></a>10. 屏障</h4><p>在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。可以通过在每个阶段的结尾安置屏障来实现这种行为。当一个进程到达屏障时，它就被屏障阻拦，直到所有进程都到达该屏障为止。</p><h4 id="四、调度"><a href="#四、调度" class="headerlink" title="四、调度"></a>四、调度</h4><p>当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争 CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个 CPU 可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序，该程序使用的算法称为调度算法。</p><h4 id="1-何时调度"><a href="#1-何时调度" class="headerlink" title="1. 何时调度"></a>1. 何时调度</h4><ol><li><p>在创建一个新进程之后，需要决定是运行父进程还是运行子进程。</p></li><li><p>在一个进程退出时必须做出调度决策。</p></li><li><p>当一个进程阻塞在 I/O 和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</p></li><li><p>第四，在一个 I/O 中断发生时，必须做出调度决策。</p></li></ol><h4 id="2-调度算法分类"><a href="#2-调度算法分类" class="headerlink" title="2. 调度算法分类"></a>2. 调度算法分类</h4><ol><li>批处理。</li><li>交互式。</li><li>实时。</li></ol><h4 id="3-调度算法的目标"><a href="#3-调度算法的目标" class="headerlink" title="3. 调度算法的目标"></a>3. 调度算法的目标</h4><p>为了设计调度算法，有必要考虑什么是一个好的调度算法。某些目标取决于环境（批处理、交互式或实时），但是还有一些目标是适用于所有情形的。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-12.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="调度算法的目标"></p><h4 id="4-批处理系统中的调度"><a href="#4-批处理系统中的调度" class="headerlink" title="4. 批处理系统中的调度"></a>4. 批处理系统中的调度</h4><h5 id="（1）先来先服务"><a href="#（1）先来先服务" class="headerlink" title="（1）先来先服务"></a>（1）先来先服务</h5><p>在所有调度算法中，最简单的是非抢占式的先来先服务算法。使用该算法，进程按照它们请求 CPU 的顺序使用 CPU 。</p><p><strong>优点：</strong></p><p>这个算法的主要优点是易于理解并且便于在程序中运用。</p><p><strong>缺点：</strong></p><p>平均等待时间过长。</p><h5 id="（2）最短作业优先"><a href="#（2）最短作业优先" class="headerlink" title="（2）最短作业优先"></a>（2）最短作业优先</h5><p>当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先算法。</p><p>只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的。</p><h5 id="（3）最短剩余时间优先"><a href="#（3）最短剩余时间优先" class="headerlink" title="（3）最短剩余时间优先"></a>（3）最短剩余时间优先</h5><p>最短作业优先的抢占式版本是最短剩余时间优先算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p><h4 id="5-交互式系统中的调度"><a href="#5-交互式系统中的调度" class="headerlink" title="5. 交互式系统中的调度"></a>5. 交互式系统中的调度</h4><h5 id="（1）轮转调度"><a href="#（1）轮转调度" class="headerlink" title="（1）轮转调度"></a>（1）轮转调度</h5><p>一种最古老、最简单、最公平且使用最广的算法是轮转调度。每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。如果在时间片结束时该进程还在运行，则将剥夺 CPU 并分配给另一个进程。如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。</p><p>需要注意的是，时间片设得太短会导致过多的进程切换，降低了 CPU 效率；而设得太长又可能引起对短的交互请求的响应时间变长。将时间片设为 20ms ～ 50 ms 通常是一个比较合理的折中。</p><h4 id="（2）优先级调度"><a href="#（2）优先级调度" class="headerlink" title="（2）优先级调度"></a>（2）优先级调度</h4><p>每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行。为了防止高优先级进程无休止地运行下去，调度程序可以在每个时钟滴答（即每个时钟中断）降低当前进程的优先级。如果这个动作导致该进程的优先级低于次高优先级的进程，则进行进程切换。</p><h4 id="（3）多级队列"><a href="#（3）多级队列" class="headerlink" title="（3）多级队列"></a>（3）多级队列</h4><p>将一组进程按优先级分成若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用其他调度方式。</p><h4 id="（4）最短进程优先"><a href="#（4）最短进程优先" class="headerlink" title="（4）最短进程优先"></a>（4）最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互进程，那将是非常好的。</p><h4 id="（5）保证调度"><a href="#（5）保证调度" class="headerlink" title="（5）保证调度"></a>（5）保证调度</h4><p>向用户作出明确的性能保证，然后去实现它。</p><p>一种很实际并很容易实现的保证是：若用户工作时有 n 个用户登录，则用户将获得 CPU 处理能力的 1/n 。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。看上去足够公平了。</p><h4 id="（6）彩票调度"><a href="#（6）彩票调度" class="headerlink" title="（6）彩票调度"></a>（6）彩票调度</h4><p>向进程提供各种系统资源（如 CPU 时间）的彩票。一旦需要做出一项调度决策时，就随机抽出一张彩票，拥有该彩票的进程获得该资源。在应用到 CPU 调度时，系统可以掌握每秒钟 50 次的一种彩票，作为奖励每个获奖者可以得到 20 ms 的 CPU 时间。</p><h4 id="（7）公平分享调度"><a href="#（7）公平分享调度" class="headerlink" title="（7）公平分享调度"></a>（7）公平分享调度</h4><p>到现在为止，我们假设被调度的都是各个进程自身，并不关注其所有者是谁。</p><p>为了避免这种情形，某些系统在调度处理之前考虑谁拥有进程这一因素。在这种模式中，每个用户分配到 CPU 时间的一部分，而调度程序以一种强制的方式选择进程。这样，如果两个用户都得到获得 50% CPU 时间的保证，那么无论一个用户有多少进程存在，每个用户都会得到应有的 CPU 份额。</p><h4 id="6-策略和机制"><a href="#6-策略和机制" class="headerlink" title="6. 策略和机制"></a>6. 策略和机制</h4><p>我们讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p><p>解决问题的方法是将调度机制与调度策略分离，也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。</p><p>在这里，调度机制位于内核，而调度策略则由用户进程决定。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Html 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Html/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Html/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DOCTYPE-的作用是什么？"><a href="#1-DOCTYPE-的作用是什么？" class="headerlink" title="1. DOCTYPE 的作用是什么？"></a>1. DOCTYPE 的作用是什么？</h3><p>相关知识点：</p><pre><code>IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。&lt;!DOCTYPE&gt;声明位于 HTML 文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</code></pre><p>回答（参考 1-5）：</p><pre><code>&lt;!DOCTYPE&gt;  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。</code></pre><h3 id="2-标准模式与兼容模式各有什么区别？"><a href="#2-标准模式与兼容模式各有什么区别？" class="headerlink" title="2. 标准模式与兼容模式各有什么区别？"></a>2. 标准模式与兼容模式各有什么区别？</h3><pre><code>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</code></pre><h3 id="3-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？"><a href="#3-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？" class="headerlink" title="3. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？"></a>3. HTML5 为什么只需要写 <code>&lt;!DOCTYPE HTML&gt;</code>，而不需要引入 DTD？</h3><pre><code>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</code></pre><h3 id="4-SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#4-SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="4. SGML 、 HTML 、XML 和 XHTML 的区别？"></a>4. SGML 、 HTML 、XML 和 XHTML 的区别？</h3><pre><code>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。HTML 是超文本标记语言，主要是用于规定怎么显示网页。XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML更严格，比如标签必须都用小写，标签都必须有闭合标签等。</code></pre><h3 id="5-DTD-介绍"><a href="#5-DTD-介绍" class="headerlink" title="5. DTD 介绍"></a>5. DTD 介绍</h3><pre><code>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</code></pre><h3 id="6-行内元素定义"><a href="#6-行内元素定义" class="headerlink" title="6. 行内元素定义"></a>6. 行内元素定义</h3><pre><code>HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间。常见的行内元素有 a b span img strong sub sup button input label select textarea</code></pre><h3 id="7-块级元素定义"><a href="#7-块级元素定义" class="headerlink" title="7. 块级元素定义"></a>7. 块级元素定义</h3><pre><code>块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。常见的块级元素有  div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code></pre><h3 id="8-行内元素与块级元素的区别？"><a href="#8-行内元素与块级元素的区别？" class="headerlink" title="8. 行内元素与块级元素的区别？"></a>8. 行内元素与块级元素的区别？</h3><pre><code>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。（1） 格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。（2） 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。（3） 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei     ght），设置 margin 和 padding 的上下不会对其他元素产生影响。</code></pre><h3 id="9-HTML5-元素的分类"><a href="#9-HTML5-元素的分类" class="headerlink" title="9. HTML5 元素的分类"></a>9. HTML5 元素的分类</h3><pre><code>HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive</code></pre><h3 id="10-空元素定义"><a href="#10-空元素定义" class="headerlink" title="10. 空元素定义"></a>10. 空元素定义</h3><pre><code>标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。常见的空元素有：br hr img input link meta</code></pre><h3 id="11-link-标签定义"><a href="#11-link-标签定义" class="headerlink" title="11. link 标签定义"></a>11. link 标签定义</h3><pre><code>link 标签定义文档与外部资源的关系。link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</code></pre><h3 id="12-页面导入样式时，使用-link-和-import-有什么区别？"><a href="#12-页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="12. 页面导入样式时，使用 link 和 @import 有什么区别？"></a>12. 页面导入样式时，使用 link 和 @import 有什么区别？</h3><pre><code>（1）从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加     载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。（2）加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。（3）兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容     性问题。（4）DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @i    mport 的方式插入样式。</code></pre><h3 id="13-你对浏览器的理解？"><a href="#13-你对浏览器的理解？" class="headerlink" title="13. 你对浏览器的理解？"></a>13. 你对浏览器的理解？</h3><pre><code>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些 浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</code></pre><h3 id="14-介绍一下你对浏览器内核的理解？"><a href="#14-介绍一下你对浏览器内核的理解？" class="headerlink" title="14. 介绍一下你对浏览器内核的理解？"></a>14. 介绍一下你对浏览器内核的理解？</h3><pre><code>主要分成两部分：渲染引擎和 JS 引擎。渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。JS 引擎：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</code></pre><h3 id="15-常见的浏览器内核比较"><a href="#15-常见的浏览器内核比较" class="headerlink" title="15. 常见的浏览器内核比较"></a>15. 常见的浏览器内核比较</h3><pre><code>Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</code></pre><p>详细的资料可以参考：<br><a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" target="_blank" rel="noopener external nofollow noreferrer">《浏览器内核的解析和对比》</a><br><a href="https://blog.csdn.net/Summer_15/article/details/71249203" target="_blank" rel="noopener external nofollow noreferrer">《五大主流浏览器内核的源起以及国内各大浏览器内核总结》</a></p><h3 id="16-常见浏览器所用内核"><a href="#16-常见浏览器所用内核" class="headerlink" title="16. 常见浏览器所用内核"></a>16. 常见浏览器所用内核</h3><pre><code> （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核； （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核； （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核； （4） Safari 浏览器内核：Webkit 内核； （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核； （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核； （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）； （8） 百度浏览器、世界之窗内核：IE 内核； （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了； （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说      是基于火狐内核。</code></pre><h3 id="17-浏览器的渲染原理？"><a href="#17-浏览器的渲染原理？" class="headerlink" title="17. 浏览器的渲染原理？"></a>17. 浏览器的渲染原理？</h3><pre><code> （1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。 （2）然后对 CSS 进行解析，生成 CSSOM 规则树。 （3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩     形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM     元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。 （4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也     可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动     重排”。 （5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组     件。  值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的  html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其  余内容。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d" target="_blank" rel="noopener external nofollow noreferrer">《浏览器渲染原理》</a><br><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener external nofollow noreferrer">《浏览器的渲染原理简介》</a><br><a href="https://kb.cnblogs.com/page/129756/" target="_blank" rel="noopener external nofollow noreferrer">《前端必读：浏览器内部工作原理》</a><br><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener external nofollow noreferrer">《深入浅出浏览器渲染原理》</a></p><h3 id="18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h3><pre><code> JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么 它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解 析文档。 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的 原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</code></pre><h3 id="19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h3><pre><code> （1）脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执     行。 （2）defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。     当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。 （3）async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执     行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener external nofollow noreferrer">《defer 和 async 的区别》</a></p><h3 id="20-什么是文档的预解析？（浏览器解析过程）"><a href="#20-什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="20. 什么是文档的预解析？（浏览器解析过程）"></a>20. 什么是文档的预解析？（浏览器解析过程）</h3><pre><code> Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加 载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析 过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</code></pre><h3 id="21-CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#21-CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="21. CSS 如何阻塞文档解析？（浏览器解析过程）"></a>21. CSS 如何阻塞文档解析？（浏览器解析过程）</h3><pre><code> 理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可 能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档 的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript， 最后再继续文档的解析。</code></pre><h3 id="22-渲染页面时常见哪些不良现象？（浏览器渲染过程）"><a href="#22-渲染页面时常见哪些不良现象？（浏览器渲染过程）" class="headerlink" title="22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）"></a>22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）</h3><pre><code> FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示       出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底       部。 白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML      尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面      文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58f867045c497d0058e2ff3a" target="_blank" rel="noopener external nofollow noreferrer">《前端魔法堂：解秘 FOUC》</a><br><a href="https://www.jianshu.com/p/6617efa874b0" target="_blank" rel="noopener external nofollow noreferrer">《白屏问题和 FOUC》</a></p><h3 id="23-如何优化关键渲染路径？（浏览器渲染过程）"><a href="#23-如何优化关键渲染路径？（浏览器渲染过程）" class="headerlink" title="23. 如何优化关键渲染路径？（浏览器渲染过程）"></a>23. 如何优化关键渲染路径？（浏览器渲染过程）</h3><pre><code> 为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素： （1）关键资源的数量。 （2）关键路径长度。 （3）关键字节的数量。 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载， 并且资源越大，下载所需的往返次数就越多。 最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它 们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。 优化关键渲染路径的常规步骤如下： （1）对关键路径进行分析和特性描述：资源数、字节数、长度。 （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。 （3）优化关键字节数以缩短下载时间（往返次数）。 （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</code></pre><p>详细资料可以参考：<br><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn" target="_blank" rel="noopener external nofollow noreferrer">《优化关键渲染路径》</a></p><h3 id="24-什么是重绘和回流？（浏览器绘制过程）"><a href="#24-什么是重绘和回流？（浏览器绘制过程）" class="headerlink" title="24. 什么是重绘和回流？（浏览器绘制过程）"></a>24. 什么是重绘和回流？（浏览器绘制过程）</h3><pre><code> 重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background       -color，我们将这样的操作称为重绘。 回流：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样      的操作我们称为回流。 常见引起回流属性和方法： 任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。 （1）添加或者删除可见的 DOM 元素； （2）元素尺寸改变——边距、填充、边框、宽度和高度 （3）内容变化，比如用户在 input 框中输入文字 （4）浏览器窗口尺寸改变——resize事件发生时 （5）计算 offsetWidth 和 offsetHeight 属性 （6）设置 style 属性的值 （7）当你修改网页的默认字体时。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列 回流。</code></pre><p>常见引起重绘属性和方法：</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="常见引起回流属性和方法"></p><p>常见引起回流属性和方法：</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="常见引起重绘属性和方法"></p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener external nofollow noreferrer">《浏览器的回流与重绘》</a></p><h3 id="25-如何减少回流？（浏览器绘制过程）"><a href="#25-如何减少回流？（浏览器绘制过程）" class="headerlink" title="25. 如何减少回流？（浏览器绘制过程）"></a>25. 如何减少回流？（浏览器绘制过程）</h3><pre><code> （1）使用 transform 替代 top （2）不要把节点的属性值放在一个循环里当成循环里的变量 （3）不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 （4）把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM （5）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</code></pre><h3 id="26-为什么操作-DOM-慢？（浏览器绘制过程）"><a href="#26-为什么操作-DOM-慢？（浏览器绘制过程）" class="headerlink" title="26. 为什么操作 DOM 慢？（浏览器绘制过程）"></a>26. 为什么操作 DOM 慢？（浏览器绘制过程）</h3><pre><code> 一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</code></pre><h3 id="27-DOMContentLoaded-事件和-Load-事件的区别？"><a href="#27-DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="27. DOMContentLoaded 事件和 Load 事件的区别？"></a>27. DOMContentLoaded 事件和 Load 事件的区别？</h3><pre><code> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和 子框架的加载完成。 Load 事件是当所有资源加载完成后触发的。</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/ca8dae435a2c" target="_blank" rel="noopener external nofollow noreferrer">《DOMContentLoaded 事件 和 Load 事件的区别？》</a></p><h3 id="28-HTML5-有哪些新特性、移除了那些元素？"><a href="#28-HTML5-有哪些新特性、移除了那些元素？" class="headerlink" title="28. HTML5 有哪些新特性、移除了那些元素？"></a>28. HTML5 有哪些新特性、移除了那些元素？</h3><pre><code> HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 新增的有： 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术 webworker, websocket; 新的文档属性 document.visibilityState 移除的元素有： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes；</code></pre><h3 id="29-如何处理-HTML5-新标签的浏览器兼容问题？"><a href="#29-如何处理-HTML5-新标签的浏览器兼容问题？" class="headerlink" title="29. 如何处理 HTML5 新标签的浏览器兼容问题？"></a>29. 如何处理 HTML5 新标签的浏览器兼容问题？</h3><pre><code class="html">（1） IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器 支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。 （2）当然也可以直接使用成熟的框架，比如 html5shiv ; `&lt;!--[if lt IE 9]&gt;  &lt;script&gt;    src = &quot;https://cdn.jsdelivr.net/npm/html5shiv/dist/html5shiv.min.js&quot;;  &lt;/script&gt;&lt;![endif]--&gt;` [if lte IE 9]……[endif] 判断 IE 的版本，限定只有 IE9 以下浏览器版本需要执行的语句。</code></pre><h3 id="30-简述一下你对-HTML-语义化的理解？"><a href="#30-简述一下你对-HTML-语义化的理解？" class="headerlink" title="30. 简述一下你对 HTML 语义化的理解？"></a>30. 简述一下你对 HTML 语义化的理解？</h3><p>相关知识点：</p><pre><code> （1） 用正确的标签做正确的事情。 （2） html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; （3） 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; （4） 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ; （5） 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</code></pre><p>回答：</p><pre><code> 我认为 html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构， 一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进 行正确的解读。比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。 对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的 话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会 依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的， 从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、fo oter 这些语义标签，删除了 big 、font 这些没有语义的标签。</code></pre><p>详细资料可以参考：<br><a href="https://www.html.cn/archives/1668" target="_blank" rel="noopener external nofollow noreferrer">《语义化的 HTML 结构到底有什么好处？》</a><br><a href="https://www.zhihu.com/question/20455165" target="_blank" rel="noopener external nofollow noreferrer">《如何理解 Web 语义化？》</a><br><a href="https://juejin.im/post/5a9c8866f265da23741072bf#heading-5" target="_blank" rel="noopener external nofollow noreferrer">《我的 HTML 会说话——从实用出发，谈谈 HTML 的语义化》</a></p><h3 id="31-b-与-strong-的区别和-i-与-em-的区别？"><a href="#31-b-与-strong-的区别和-i-与-em-的区别？" class="headerlink" title="31. b 与 strong 的区别和 i 与 em 的区别？"></a>31. b 与 strong 的区别和 i 与 em 的区别？</h3><pre><code> 从页面显示效果来看，被 &lt;b&gt; 和 &lt;strong&gt; 包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt; 包围的文字将以斜体的形式呈现。 但是 &lt;b&gt; &lt;i&gt; 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 &#123; font-weight: bolder&#125;，仅仅表示「这 里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。 而 &lt;em&gt; 和 &lt;strong&gt; 是语义样式标签。 &lt;em&gt; 表示一般的强调文本，而 &lt;strong&gt; 表示比 &lt;em&gt; 语义更强的强调文本。 使用阅读设备阅读网页时：&lt;strong&gt; 会重读，而 &lt;b&gt; 是展示强调内容。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19551271" target="_blank" rel="noopener external nofollow noreferrer">《HTML5 中的 b/strong，i/em 有什么区别？》</a></p><h3 id="32-前端需要注意哪些-SEO-？"><a href="#32-前端需要注意哪些-SEO-？" class="headerlink" title="32. 前端需要注意哪些 SEO ？"></a>32. 前端需要注意哪些 SEO ？</h3><pre><code> （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超     过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不     同页面 description 有所不同；keywords 列举出重要关键词即可。 （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。 （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被     抓取。 （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容 （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容 （6）非装饰性图片必须加 alt （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</code></pre><h3 id="33-HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#33-HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>33. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h3><pre><code> 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资      源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面      展示。 如何使用： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。     &lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt; （2）在如下 cache.manifest 文件的编写离线存储的资源。       CACHE MANIFEST       #v0.11       CACHE:       js/app.js       css/style.css       NETWORK:       resourse/logo.png       FALLBACK:       / /offline.html     CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出            来。     NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些              资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C              ACHE 的优先级更高。     FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下               任何一个资源失败了，那么就去访问 offline.html 。 （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。 如何更新缓存： （1）更新 manifest 文件 （2）通过 javascript 操作 （3）清除浏览器缓存 注意事项： （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。 （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。 （4）FALLBACK 中的资源必须和 manifest 文件同源。 （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。 （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。 （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</code></pre><p>详细的使用可以参考：<br><a href="https://yanhaijing.com/html/2014/12/28/html5-manifest/" target="_blank" rel="noopener external nofollow noreferrer">《HTML5 离线缓存-manifest 简介》</a><br><a href="https://segmentfault.com/a/1190000000732617" target="_blank" rel="noopener external nofollow noreferrer">《有趣的 HTML5：离线存储》</a></p><h3 id="34-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#34-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>34. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h3><pre><code> 在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器 就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器 就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做 任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。</code></pre><h3 id="35-常见的浏览器端的存储技术有哪些？"><a href="#35-常见的浏览器端的存储技术有哪些？" class="headerlink" title="35. 常见的浏览器端的存储技术有哪些？"></a>35. 常见的浏览器端的存储技术有哪些？</h3><pre><code> 浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。 还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。 IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</code></pre><p>详细的资料可以参考：<br><a href="https://segmentfault.com/a/1190000012578794#articleHeader0" target="_blank" rel="noopener external nofollow noreferrer">《很全很全的前端本地存储讲解》</a></p><h3 id="36-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#36-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>36. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>相关资料：</p><pre><code> SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别 在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户 本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会 在浏览器和服务器间来回传递。 存储大小：       cookie 数据大小不能超过4 k 。       sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 有期时间：       localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。       sessionStorage  数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会                     保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。       cookie          设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 作用域：     sessionStorage  只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。     localStorage    在所有同源窗口中都是共享的。     cookie          在所有同源窗口中都是共享的。</code></pre><p>回答：</p><pre><code> 浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。 cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服 务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。 sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保 存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源 页面所访问共享。 localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。 上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏 览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</code></pre><p>详细的资料可以参考：<br><a href="https://segmentfault.com/a/1190000017423117" target="_blank" rel="noopener external nofollow noreferrer">《请描述一下 cookies，sessionStorage 和 localStorage 的区别？》</a><br><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener external nofollow noreferrer">《浏览器数据库 IndexedDB 入门教程》</a></p><h3 id="37-iframe-有那些缺点？"><a href="#37-iframe-有那些缺点？" class="headerlink" title="37. iframe 有那些缺点？"></a>37. iframe 有那些缺点？</h3><pre><code> iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。 主要缺点有： （1） iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才      会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。 （2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。 （3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 （4） 浏览器的后退按钮失效。 （5） 小型的移动设备无法完全显示框架。</code></pre><p>详细的资料可以参考：<br><a href="https://blog.csdn.net/yintianqin/article/details/72625785" target="_blank" rel="noopener external nofollow noreferrer">《使用 iframe 的优缺点》</a><br><a href="https://segmentfault.com/a/1190000009891683" target="_blank" rel="noopener external nofollow noreferrer">《iframe 简单探索以及 iframe 跨域处理》</a></p><h3 id="38-Label-的作用是什么？是怎么用的？"><a href="#38-Label-的作用是什么？是怎么用的？" class="headerlink" title="38. Label 的作用是什么？是怎么用的？"></a>38. Label 的作用是什么？是怎么用的？</h3><pre><code> label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt; &lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</code></pre><h3 id="39-HTML5-的-form-的自动完成功能是什么？"><a href="#39-HTML5-的-form-的自动完成功能是什么？" class="headerlink" title="39. HTML5 的 form 的自动完成功能是什么？"></a>39. HTML5 的 form 的自动完成功能是什么？</h3><pre><code> autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。 自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</code></pre><h3 id="40-如何实现浏览器内多个标签页之间的通信"><a href="#40-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="40. 如何实现浏览器内多个标签页之间的通信?"></a>40. 如何实现浏览器内多个标签页之间的通信?</h3><p>相关资料：</p><pre><code> （1）使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。 （2）使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标     签页之间的双向通行。 （3）可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触     发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信； （4）如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。</code></pre><p>回答：</p><pre><code> 实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者， 让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。 第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。 标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。 第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使 用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交 换。 第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页 修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。 还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</code></pre><p>详细的资料可以参考：</p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener external nofollow noreferrer">《WebSocket 教程》</a><br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html" target="_blank" rel="noopener external nofollow noreferrer">《WebSocket 协议：5 分钟从入门到精通》</a><br><a href="https://segmentfault.com/a/1190000011538416" target="_blank" rel="noopener external nofollow noreferrer">《WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API" target="_blank" rel="noopener external nofollow noreferrer">《使用 Web Storage API》</a><br><a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 的多线程，Worker 和 SharedWorker》</a><br><a href="https://juejin.im/post/5acdba01f265da23826e5633#heading-1" target="_blank" rel="noopener external nofollow noreferrer">《实现多个标签页之间通信的几种方法》</a></p><h3 id="41-webSocket-如何兼容低版本浏览器？"><a href="#41-webSocket-如何兼容低版本浏览器？" class="headerlink" title="41. webSocket 如何兼容低版本浏览器？"></a>41. webSocket 如何兼容低版本浏览器？</h3><pre><code> Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</code></pre><h3 id="42-页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#42-页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="42. 页面可见性（Page Visibility API） 可以有哪些用途？"></a>42. 页面可见性（Page Visibility API） 可以有哪些用途？</h3><pre><code> 这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户 不看网页，下面这些网页行为都是可以暂停的。 （1）对服务器的轮询 （2）网页动画 （3）正在播放的音频或视频</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html" target="_blank" rel="noopener external nofollow noreferrer">《Page Visibility API 教程》</a></p><h3 id="43-如何在页面上实现一个圆形的可点击区域？"><a href="#43-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="43. 如何在页面上实现一个圆形的可点击区域？"></a>43. 如何在页面上实现一个圆形的可点击区域？</h3><pre><code> （1）纯 html 实现，使用 &lt;area&gt; 来给 &lt;img&gt; 图像标记热点区域的方式，&lt;map&gt; 标签用来定义一个客户端图像映射，&lt;area&gt;     标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击     的圆形区域。 （2）纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的     点击区域。 （3）纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我     们规定的圆形区域内。</code></pre><p>详细资料可以参考：<br><a href="https://maizi93.github.io/2017/08/29/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%EF%BC%9F/" target="_blank" rel="noopener external nofollow noreferrer">《如何在页面上实现一个圆形的可点击区域？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/" target="_blank" rel="noopener external nofollow noreferrer">《HTML <area><map> 标签及在实际开发中的应用》</a></p><h3 id="44-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#44-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>44. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><pre><code class="html">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</code></pre><h3 id="45-title-与-h1-的区别？"><a href="#45-title-与-h1-的区别？" class="headerlink" title="45. title 与 h1 的区别？"></a>45. title 与 h1 的区别？</h3><pre><code> title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</code></pre><h3 id="46-lt-img-gt-的-title-和-alt-有什么区别？"><a href="#46-lt-img-gt-的-title-和-alt-有什么区别？" class="headerlink" title="46. &lt;img&gt; 的 title 和 alt 有什么区别？"></a>46. <code>&lt;img&gt;</code> 的 title 和 alt 有什么区别？</h3><pre><code> title 通常当鼠标滑动到元素上的时候显示 alt 是 &lt;img&gt; 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装 饰图片外都必须设置有意义的值，搜索引擎会重点分析。</code></pre><h3 id="47-Canvas-和-SVG-有什么区别？"><a href="#47-Canvas-和-SVG-有什么区别？" class="headerlink" title="47. Canvas 和 SVG 有什么区别？"></a>47. Canvas 和 SVG 有什么区别？</h3><pre><code> Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时， 会出现锯齿或者失真的情况。 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素 附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19690014" target="_blank" rel="noopener external nofollow noreferrer">《SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？》</a></p><h3 id="48-网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#48-网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="48. 网页验证码是干嘛的，是为了解决什么安全问题？"></a>48. 网页验证码是干嘛的，是为了解决什么安全问题？</h3><pre><code> （1）区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 （2）有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</code></pre><h3 id="49-渐进增强和优雅降级的定义"><a href="#49-渐进增强和优雅降级的定义" class="headerlink" title="49. 渐进增强和优雅降级的定义"></a>49. 渐进增强和优雅降级的定义</h3><pre><code> 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的         用户体验。 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</code></pre><h3 id="50-attribute-和-property-的区别是什么？"><a href="#50-attribute-和-property-的区别是什么？" class="headerlink" title="50. attribute 和 property 的区别是什么？"></a>50. attribute 和 property 的区别是什么？</h3><pre><code> attribute 是 dom 元素在文档中作为 html 标签拥有的属性； property 就是 dom 元素在 js 中作为对象拥有的属性。 对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的。</code></pre><h3 id="51-对-web-标准、可用性、可访问性的理解"><a href="#51-对-web-标准、可用性、可访问性的理解" class="headerlink" title="51. 对 web 标准、可用性、可访问性的理解"></a>51. 对 web 标准、可用性、可访问性的理解</h3><pre><code> 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看 产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。 二是代码是否容易被人理解，是否容易修改和增强功能。</code></pre><h3 id="52-IE-各版本和-Chrome-可以并行下载多少个资源？"><a href="#52-IE-各版本和-Chrome-可以并行下载多少个资源？" class="headerlink" title="52. IE 各版本和 Chrome 可以并行下载多少个资源？"></a>52. IE 各版本和 Chrome 可以并行下载多少个资源？</h3><pre><code> （1）  IE6 2 个并发 （2）  iE7 升级之后的 6 个并发，之后版本也是 6 个 （3）  Firefox，chrome 也是6个</code></pre><h3 id="53-Flash、Ajax-各自的优缺点，在使用中如何取舍？"><a href="#53-Flash、Ajax-各自的优缺点，在使用中如何取舍？" class="headerlink" title="53. Flash、Ajax 各自的优缺点，在使用中如何取舍？"></a>53. Flash、Ajax 各自的优缺点，在使用中如何取舍？</h3><pre><code> Flash： （1） Flash 适合处理多媒体、矢量图形、访问机器 （2） 对 CSS、处理文本上不足，不容易被搜索 Ajax： （1） Ajax 对 CSS、文本支持很好，支持搜索 （2） 多媒体、矢量图形、机器访问不足 共同点： （1） 与服务器的无刷新传递消息 （2） 可以检测用户离线和在线状态 （3） 操作 DOM</code></pre><h3 id="54-怎么重构页面？"><a href="#54-怎么重构页面？" class="headerlink" title="54. 怎么重构页面？"></a>54. 怎么重构页面？</h3><pre><code> （1） 编写 CSS （2） 让页面结构更合理化，提升用户体验 （3） 实现良好的页面效果和提升性能</code></pre><h3 id="55-浏览器架构"><a href="#55-浏览器架构" class="headerlink" title="55. 浏览器架构"></a>55. 浏览器架构</h3><pre><code> * 用户界面   * 主进程   * 内核       * 渲染引擎       * JS 引擎           * 执行栈       * 事件触发线程           * 消息队列               * 微任务               * 宏任务       * 网络异步线程       * 定时器线程</code></pre><h3 id="56-常用的-meta-标签"><a href="#56-常用的-meta-标签" class="headerlink" title="56. 常用的 meta 标签"></a>56. 常用的 meta 标签</h3><pre><code> &lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。 &lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。 &lt;!DOCTYPE html&gt;  H5标准声明，使用 HTML5 doctype，不区分大小写 &lt;head lang=&quot;en&quot;&gt; 标准的 lang 属性写法 &lt;meta charset=&quot;utf-8&quot;&gt;    声明文档使用的字符编码 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;   优先使用 IE 最新版本和 Chrome &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;/&gt;       页面描述 &lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&gt;      页面关键词者 &lt;meta name=&quot;author&quot; content=&quot;name, email@gmail.com&quot;/&gt;    网页作 &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;      搜索引擎抓取 &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no&quot;&gt; 为移动设备添加 viewport &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt; iOS 设备 begin &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;  添加到主屏后的标题（iOS 6 新增） 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;&gt; 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;  设置苹果工具栏颜色 &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;  启用360浏览器的极速模式(webkit) &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;     避免IE使用兼容模式 &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;    不让百度转码 &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;   微软的老式浏览器 &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;   uc强制竖屏 &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;    QQ强制竖屏 &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;              UC强制全屏 &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;       QQ强制全屏 &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;   UC应用模式 &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;    QQ应用模式 &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;    windows phone 点击无高光 设置页面不缓存 &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;</code></pre><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/qiumohanyu/p/5431859.html" target="_blank" rel="noopener external nofollow noreferrer">《Meta 标签用法大全》</a></p><h3 id="57-css-reset-和-normalize-css-有什么区别？"><a href="#57-css-reset-和-normalize-css-有什么区别？" class="headerlink" title="57. css reset 和 normalize.css 有什么区别？"></a>57. css reset 和 normalize.css 有什么区别？</h3><p>相关知识点：</p><pre><code> 为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多 兼容性问题。 reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。 normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。 1.Normalize.css 保护了有价值的默认值 Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css 保持了许多默认的浏 览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali ze.css 会力求让这些样式保持一致并尽可能与现代标准相符合。 2.Normalize.css 修复了浏览器的 bug 它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题 包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中 的与表单相关的 bug。 3.Normalize.css 没有复杂的继承链 使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize.css 中就不会有这样的问题，因为在 我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。 4.Normalize.css 是模块化的 这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己 选择性地移除掉某些永远不会用到部分（比如表单的一般化）。 5.Normalize.css 拥有详细的文档 Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的 说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己 的测试。</code></pre><p>回答：</p><pre><code> css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器 样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成 画蛇添足的效果。 后面出现一种更好的解决浏览器间样式不兼容的方法，就是 normalize.css ，它的思想是尽量的保留浏览器自带的样式，通过在原 有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，normalize.css 的方法保留了有价值的默 认值，并且修复了一些浏览器的 bug，而且使用 normalize.css 不会造成元素复杂的继承链。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000003021766#articleHeader0" target="_blank" rel="noopener external nofollow noreferrer">《关于 CSS Reset 那些事（一）之 历史演变与 Normalize.css》</a><br><a href="https://segmentfault.com/q/1010000000117189" target="_blank" rel="noopener external nofollow noreferrer">《Normalize.css 和 Reset CSS 有什么本质区别没？》</a></p><h3 id="58-用于预格式化文本的标签是？"><a href="#58-用于预格式化文本的标签是？" class="headerlink" title="58. 用于预格式化文本的标签是？"></a>58. 用于预格式化文本的标签是？</h3><pre><code> 预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。 &lt;pre&gt; 定义预格式文本，保持文本原有的格式</code></pre><h3 id="59-DHTML-是什么？"><a href="#59-DHTML-是什么？" class="headerlink" title="59. DHTML 是什么？"></a>59. DHTML 是什么？</h3><pre><code> DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能 够动态地改变 HTML 元素的样式。 DHTML 实现了网页从 Web 服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功 能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链 接目录等。 包括： （1）动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。 （2）动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、     文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样     式”即可以“动态”地改变排版样式。</code></pre><h3 id="60-head-标签中必不少的是？"><a href="#60-head-标签中必不少的是？" class="headerlink" title="60. head 标签中必不少的是？"></a>60. head 标签中必不少的是？</h3><pre><code> &lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供 元信息等等。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数 据都不会真正作为内容显示给读者。 下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。 &lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</code></pre><h3 id="61-HTML5-新增的表单元素有？"><a href="#61-HTML5-新增的表单元素有？" class="headerlink" title="61. HTML5 新增的表单元素有？"></a>61. HTML5 新增的表单元素有？</h3><pre><code> datalist 规定输入域的选项列表，通过 option 创建！ keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！ output 元素用于不同类型的输出！</code></pre><h3 id="62-在-HTML5-中，哪个方法用于获得用户的当前位置？"><a href="#62-在-HTML5-中，哪个方法用于获得用户的当前位置？" class="headerlink" title="62. 在 HTML5 中，哪个方法用于获得用户的当前位置？"></a>62. 在 HTML5 中，哪个方法用于获得用户的当前位置？</h3><pre><code> getCurrentPosition()</code></pre><h3 id="63-文档的不同注释方式？"><a href="#63-文档的不同注释方式？" class="headerlink" title="63. 文档的不同注释方式？"></a>63. 文档的不同注释方式？</h3><pre><code> HTML 的注释方法 &lt;!--注释内容--&gt; CSS 的��释方法 /*注释内容*/ JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式</code></pre><h3 id="64-disabled-和-readonly-的区别？"><a href="#64-disabled-和-readonly-的区别？" class="headerlink" title="64. disabled 和 readonly 的区别？"></a>64. disabled 和 readonly 的区别？</h3><pre><code> disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。 readonly 规定输入字段为只读。input 内容会随着表单提交。 无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</code></pre><h3 id="65-主流浏览器内核私有属性-css-前缀？"><a href="#65-主流浏览器内核私有属性-css-前缀？" class="headerlink" title="65. 主流浏览器内核私有属性 css 前缀？"></a>65. 主流浏览器内核私有属性 css 前缀？</h3><pre><code> mozilla 内核 （firefox,flock 等）    -moz webkit  内核 （safari,chrome 等）   -webkit opera   内核 （opera 浏览器）        -o trident 内核 （ie 浏览器）           -ms</code></pre><h3 id="66-前端性能优化？"><a href="#66-前端性能优化？" class="headerlink" title="66. 前端性能优化？"></a>66. 前端性能优化？</h3><pre><code> 前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。 第一个方面是页面的内容方面 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。 （3）通过设置缓存策略，对常用不变的资源进行缓存。 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。 第二个方面是服务器方面 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie 第三个方面是 CSS 和 JavaScript 方面 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。 （2）避免使用 @import 标签。 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。</code></pre><p>详细的资料可以参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51#heading-10" target="_blank" rel="noopener external nofollow noreferrer">《前端性能优化之雅虎 35 条军规》</a><br><a href="https://juejin.im/entry/58709b9a128fe1006b29cd5d" target="_blank" rel="noopener external nofollow noreferrer">《你真的了解 gzip 吗？》</a><br><a href="https://segmentfault.com/a/1190000012571492" target="_blank" rel="noopener external nofollow noreferrer">《前端性能优化之 gzip》</a></p><h3 id="67-Chrome-中的-Waterfall-？"><a href="#67-Chrome-中的-Waterfall-？" class="headerlink" title="67. Chrome 中的 Waterfall ？"></a>67. Chrome 中的 Waterfall ？</h3><p>详细资料可以参考：<br><a href="https://blog.csdn.net/carian_violet/article/details/84954360" target="_blank" rel="noopener external nofollow noreferrer">《前端性能之 Chrome 的 Waterfall》</a><br><a href="https://blog.csdn.net/csdn_girl/article/details/54911632" target="_blank" rel="noopener external nofollow noreferrer">《教你读懂网络请求的瀑布图》</a> <a href="https://www.zhihu.com/question/27085552/answer/35194131" target="_blank" rel="noopener external nofollow noreferrer">《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》</a></p><h3 id="68-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#68-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>68. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h3><pre><code> 核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 serv er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备 上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。 我的理解 二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid 的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只 有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据 先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后， 服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够 很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成 有效的安全防护。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20368066" target="_blank" rel="noopener external nofollow noreferrer">《微信扫描二维码登录网页》</a></p><h3 id="69-Html-规范中为什么要求引用资源不加协议头http或者https？"><a href="#69-Html-规范中为什么要求引用资源不加协议头http或者https？" class="headerlink" title="69. Html 规范中为什么要求引用资源不加协议头http或者https？"></a>69. Html 规范中为什么要求引用资源不加协议头<code>http</code>或者<code>https</code>？</h3><pre><code> 如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现 警告信息，不同浏览器警告信息展现形式不同。 为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为  protocol-relative URL，暂且可译作协议相对 URL。 如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似 的警告信息，同时还可以节省5字节的数据量。</code></pre><p>详细资料可以参考：<br><a href="https://www.ludou.org/the-protocol-relative-url.html" target="_blank" rel="noopener external nofollow noreferrer">《协议相对 URL》</a><br><a href="https://www.tuicool.com/articles/nEjU7b" target="_blank" rel="noopener external nofollow noreferrer">《Why you need protocol-relative URLs _now_》</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Html </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="https-介绍"><a href="#https-介绍" class="headerlink" title="https 介绍"></a>https 介绍</h2><p>HTTPS 协议 = HTTP 协议 + SSL/TLS 协议, 在数据传输过程中, 需要使用 SSL/TLS 协议对数据进行加密和解密, 需要使用 HTTP 对加密后的数据进行传输</p><ul><li>HTTPS 为了兼顾安全和效率, 同时使用了对称加密和非对称加密</li><li>总的来说, 对数据进行对称加密, 对称加密所需要使用的密钥通过非对称加密传输</li></ul><h3 id="为什么使用对称加密"><a href="#为什么使用对称加密" class="headerlink" title="为什么使用对称加密"></a>为什么使用对称加密</h3><p>非对称加密基于大数运算, 速度慢, 需要更多的位数。相同长度的对称加密要比非对称加密短</p><h2 id="http2-0-优化点"><a href="#http2-0-优化点" class="headerlink" title="http2.0 优化点"></a>http2.0 优化点</h2><ol><li>header 压缩<br>采用 HPACK 算法, 在客户端和服务端两端简历 &quot;字典&quot;, 用索引号表示重复的字符串, 还采用哈夫曼编码来压缩整数和字符串, 可以提高 50% - 90% 的高压缩率</li><li>多路复用<br>采用二进制分帧传输, 不存在先后关系, 因此也就不存在等待排队, 也就没有了 HTTP 队头阻塞问题。<br>通信双方都可以给对分发送二进制帧， 这种二进制帧的双向传输的序列，也叫做流。 HTTP/2 用流来在一个 TCP 连接上来进行数据帧的通信， 这就是多路复用的概念。</li><li>设置请求优先级<br>在二进制帧当中还有其它的一些字段, 实现了优先级和流量控制等功能</li><li>服务器推送<br>服务器不再是完全被动地响应请求，也可以新建 &quot;流&quot; 主动向客户端发送消息。</li></ol><h2 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h2><p>采用 Quic 协议: HTTP/3 选择了一个折中的方法——UDP 协议， 基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议</p><p>HTTP/3 中的 QUIC 协议集合了以下几点功能:</p><ol><li>实现了类似 TCP 的流量控制、传输可靠性的功能</li><li>集成了 TLS 加密功能</li><li>实现了 HTTP/2 中的多路复用功能。</li></ol><p>和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。<br>实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</p><hr><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、<br>有哪些字段等等。</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传<br>输层协议，保证了数据传输的可靠性。</p><p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p><p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护<br>一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP<br>连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a<br>live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持<br>同时建立 6 个持久连接。</p><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 请求报文的格式如下：</p><pre><code class="http">GET / HTTP/1.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</code></pre><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应<br>中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但<br>更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener external nofollow noreferrer">文档</a>。</p><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>HTTP 报文有两种，一种是请求报文，一种是响应报文。</p><p>HTTP 响应报文的格式如下：</p><pre><code>HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt;  &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;</code></pre><p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</p><p>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</p><p>实体部分是报文的主要部分，它包含了所请求的对象。</p><p>常见的状态有</p><p>200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。</p><p>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</p><p>更多关于状态码的可以查看：</p><p><a href="http://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 状态码》</a></p><h3 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h3><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。</p><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修<br>改时间。</p><p>更多关于首部的资料可以查看：</p><p><a href="https://www.cnblogs.com/jycboy/p/http_head.html" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 首部字段详细介绍》</a></p><p><a href="https://blog.csdn.net/qq_34289537/article/details/52971516" target="_blank" rel="noopener external nofollow noreferrer">《图解 HTTP》</a></p><h3 id="HTTP-1-1-协议缺点"><a href="#HTTP-1-1-协议缺点" class="headerlink" title="HTTP/1.1 协议缺点"></a>HTTP/1.1 协议缺点</h3><p>HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序<br>是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许<br>多请求排队等待的情况，这种情况被称为“队头堵塞”。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他<br>资源请求完成后才能发起请求。</p><p>为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。</p><h3 id="HTTP-2-协议"><a href="#HTTP-2-协议" class="headerlink" title="HTTP/2 协议"></a>HTTP/2 协议</h3><p>2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明<br>可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</p><p>HTTP/2 主要有以下新的特性：</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是<br>二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。<br>帧的概念是它实现多路复用的基础。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回<br>应，而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;的问题。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的<br>请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每<br>个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是<br>重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，<br>客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引<br>号，这样就能提高速度了。</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源<br>，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用<br>SSE 等方式向客户端发送即时数据的推送是不同的。</p><p>详细的资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 协议入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank" rel="noopener external nofollow noreferrer">《HTTP/2 服务器推送（Server Push）教程》</a></p><h3 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h3><p>因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵<br>守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都<br>会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</p><h3 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h3><p>由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC<br>协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/302412059" target="_blank" rel="noopener external nofollow noreferrer">《如何看待 HTTP/3 ？》</a></p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><h3 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h3><ol><li><p>HTTP 报文使用明文方式发送，可能被第三方窃听。</p></li><li><p>HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</p></li><li><p>HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</p></li></ol><h3 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h3><p>HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/<br>SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立<br>刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p><h3 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h3><ol><li><p>第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p></li><li><p>第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p></li><li><p>第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服<br>务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p></li><li><p>第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p></li><li><p>第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥<br>来加密信息。</p></li></ol><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>TLS 的握手过程主要用到了三个方法来保证传输的安全。</p><p>首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就<br>是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。<br>这就要用到非对称加密的方法。</p><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只<br>有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，<br>都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加<br>密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p><p>因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以<br>非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存<br>在的问题。</p><p>但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取<br>了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥<br>解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p><p>为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成<br>一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合<br>在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证<br>处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改<br>了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有<br>这样我们才能保证数据的安全。</p><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA" target="_blank" rel="noopener external nofollow noreferrer">《一个故事讲完 https》</a><br><a href="http://ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener external nofollow noreferrer">《SSL/TLS 协议运行机制的概述》</a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener external nofollow noreferrer">《图解 SSL/TLS 协议》</a><br><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener external nofollow noreferrer">《RSA 算法原理（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html" target="_blank" rel="noopener external nofollow noreferrer">《RSA 算法原理（二）》</a><br><a href="https://juejin.im/post/5ad6ad575188255c272273c4" target="_blank" rel="noopener external nofollow noreferrer">《分分钟让你理解 HTTPS》</a></p><h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><h3 id="概况-1"><a href="#概况-1" class="headerlink" title="概况"></a>概况</h3><p>DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分<br>布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号<br>端口。</p><h3 id="域名的层级结构"><a href="#域名的层级结构" class="headerlink" title="域名的层级结构"></a>域名的层级结构</h3><p>域名的层级结构可以如下</p><pre><code>主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root</code></pre><p>根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。</p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。</p><ol><li>从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的 NS 记录和 A 记录（ IP 地址）。</li><li>从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的 NS 记录和 A 记录（ IP 地址）。</li><li>从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的 IP 地址。</li></ol><p>比如我们如果想要查询 <a href="http://www.baidu.com/" target="_blank" rel="noopener external nofollow noreferrer">www.baidu.com</a> 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务<br>器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名<br>服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com<br>的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服<br>务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p><h3 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p><p>（Name，Value，Type，TTL）</p><p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p><p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</p><ol><li><p>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标<br>准的主机名到 IP 地址的映射。</p></li><li><p>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式<br>查询时，返回下一级需要查询的 DNS 服务器的信息。</p></li><li><p>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名<br>对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供<br>一个便于记忆的简单的别名。</p></li><li><p>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一<br>样的，都是为了解决规范主机名不利于记忆的缺点。</p></li></ol><h3 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h3><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归<br>查询，用户只需要发出一次查询请求。</p><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出<br>多次的查询请求。</p><p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我<br>们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次<br>查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h3><p>DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本<br>地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</p><h3 id="DNS-实现负载平衡"><a href="#DNS-实现负载平衡" class="headerlink" title="DNS 实现负载平衡"></a>DNS 实现负载平衡</h3><p>DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应<br>多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在<br>每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不<br>同的服务器上，这样来实现负载均衡。</p><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener external nofollow noreferrer">《DNS 原理入门》</a><br><a href="http://www.ruanyifeng.com/blog/2018/05/root-domain.html" target="_blank" rel="noopener external nofollow noreferrer">《根域名的知识》</a></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。</p><h3 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p>将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。</p><p>在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。</p><p>无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一<br>个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端<br>口号，那么不同的报文段将会转交到同一个 UDP 套接字中。</p><p>面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了<br>源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个<br>值来将报文段定向到相应的套接字。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差<br>错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。</p><p>特点：</p><ol><li><p>使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手<br>过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。</p></li><li><p>UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</p></li><li><p>UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</p></li><li><p>因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互<br>通信。</p></li><li><p>UDP 首部小，只有 8 个字节。</p></li></ol><h3 id="UDP-报文段结构"><a href="#UDP-报文段结构" class="headerlink" title="UDP 报文段结构"></a>UDP 报文段结构</h3><p>UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长<br>度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。<br>虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="UDP 报文段结构"></p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 协议是面向连接的，提供可靠数据传输服务的传输层协议。</p><p>特点：</p><ol><li><p>TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。</p></li><li><p>TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。</p></li><li><p>TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。</p></li><li><p>TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。</p></li><li><p>TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。</p></li><li><p>TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送<br>速率，避免因为缓存填满而造成的数据包的丢失。</p></li></ol><h3 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h3><p>TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。</p><p>源端口和目的端口号用于报文段的多路复用和分解。</p><p>32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。</p><p>16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。</p><p>4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。</p><p>6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字<br>段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。</p><p>校验和提供了对数据的差错检测。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-17.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP 报文段结构"></p><h3 id="TCP-三次握手的过程"><a href="#TCP-三次握手的过程" class="headerlink" title="TCP 三次握手的过程"></a>TCP 三次握手的过程</h3><p>第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的<br>随机数。它代表的是客户端数据的初始序号。</p><p>第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向<br>客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认，<br>同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加<br>一。</p><p>第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务<br>器端的报文段的确认。第三次握手可以在报文段中携带数据。</p><p>在我看来，TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。<br>第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否<br>已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener external nofollow noreferrer">《TCP 为什么是三次握手，而不是两次或四次？》</a><br><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener external nofollow noreferrer">《TCP 的三次握手与四次挥手》</a></p><h3 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h3><p>因为 TCP 连接是全双工的，也就是说通信的双方都可以向对方发送和接收消息，所以断开连接需要双方的确认。</p><p>第一次挥手，客户端认为没有数据要再发送给服务器端，它就向服务器发送一个 FIN 报文段，申请断开客户端到服务器端的<br>连接。发送后客户端进入 FIN_WAIT_1 状态。</p><p>第二次挥手，服务器端接收到客户端释放连接的请求后，向客户端发送一个确认报文段，表示已经接收到了客户端释放连接的<br>请求，以后不再接收客户端发送过来的数据。但是因为连接是全双工的，所以此时，服务器端还可以向客户端发送数据。服务<br>器端进入 CLOSE_WAIT 状态。客户端收到确认后，进入 FIN_WAIT_2 状态。</p><p>第三次挥手，服务器端发送完所有数据后，向客户端发送 FIN 报文段，申请断开服务器端到客户端的连接。发送后进入 LAS<br>T_ACK 状态。</p><p>第四次挥手，客户端接收到 FIN 请求后，向服务器端发送一个确认应答，并进入 TIME_WAIT 阶段。该阶段会持续一段时间，<br>这个时间为报文段在网络中的最大生存时间，如果该时间内服务端没有重发请求的话，客户端进入 CLOSED 的状态。如果收到<br>服务器的重发请求就重新发送确认报文段。服务器端收到客户端的确认报文段后就进入 CLOSED 状态，这样全双工的连接就被<br>释放了。</p><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代<br>表不能再向对方发送数据，连接处于的是半释放的状态。</p><p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器<br>端不能正常关闭。</p><p>详细资料可以参考：</p><p><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5c447392e51d45524b02eaf5" target="_blank" rel="noopener external nofollow noreferrer">《前端面试之道》</a></p><h3 id="状态转化图"><a href="#状态转化图" class="headerlink" title="状态转化图"></a>状态转化图</h3><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-18.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-18.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="客户端状态图"></p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-19.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-19.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="服务端状态图"></p><h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p>ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的<br>机制。</p><p>它分为停止等待 ARQ 协议和连续 ARQ 协议。</p><p>一、停止等待 ARQ 协议</p><p>停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认<br>回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。</p><p>对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余<br>分组的确认。当收到分组损坏的情况的时候，直接丢弃。</p><p>使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。</p><p>二、连续 ARQ 协议</p><p>连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的<br>确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。</p><ol><li>滑动窗口协议</li></ol><p>使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发<br>送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分<br>组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定<br>时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没<br>有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分<br>组。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那<br>么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了，<br>所以发送窗口可以移动到已确认分组的后面。</p><p>滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况<br>的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。</p><ol start="2"><li>选择重传协议</li></ol><p>因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。</p><p>选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组，<br>已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协<br>议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的<br>定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分<br>组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。</p><p>在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分<br>组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/guoweimelon/article/details/50879588" target="_blank" rel="noopener external nofollow noreferrer">《TCP 连续 ARQ 协议和滑动窗口协议》</a></p><h3 id="TCP-的可靠运输机制"><a href="#TCP-的可靠运输机制" class="headerlink" title="TCP 的可靠运输机制"></a>TCP 的可靠运输机制</h3><p>TCP 的可靠运输机制是基于连续 ARQ 协议和滑动窗口协议的。</p><p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但<br>未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发<br>送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。<br>如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如<br>果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送<br>但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示，<br>说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发<br>送但确认的报文段。</p><p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文<br>段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都<br>已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p><p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文<br>段的发送速率。</p><p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重<br>传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p><h3 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h3><p>TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大<br>于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据<br>接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。</p><h3 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h3><p>TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的<br>速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。</p><p>TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。</p><p>慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探<br>，每次收到一个确认报文，就将发动窗口的长度加一，这样每个 RTT 时间后，发送窗口的长度就会加倍。当发送窗口的大小达<br>到一个阈值的时候就进入拥塞避免算法。</p><p>拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。<br>这样将窗口的增长速率由指数增长，变为加法线性增长。</p><p>快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的<br>丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。</p><p>快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥<br>塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。</p><p>TCP 认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四<br>种机制来达到拥塞控制的目的。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/7d59f9292b03" target="_blank" rel="noopener external nofollow noreferrer">《TCP 的拥塞控制机制》</a><br><a href="http://www.voidcn.com/article/p-vrdkquop-ms.html" target="_blank" rel="noopener external nofollow noreferrer">《网络基本功：TCP 拥塞控制机制》</a></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选<br>择协议。</p><p>IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用<br>32 位来分配地址，还有 IPv6 使用 128 位来分配地址。</p><p>路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址，<br>这是由网络适配器决定的，在全世界都是独一无二的。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质<br>是什么。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e#heading-1" target="_blank" rel="noopener external nofollow noreferrer">《搞定计算机网络面试，看这篇就够了（补充版）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener external nofollow noreferrer">《互联网协议入门（一）》</a><br><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener external nofollow noreferrer">《互联网协议入门（二）》</a></p><h2 id="常考面试题"><a href="#常考面试题" class="headerlink" title="常考面试题"></a>常考面试题</h2><h3 id="1-Post-和-Get-的区别？"><a href="#1-Post-和-Get-的区别？" class="headerlink" title="1. Post 和 Get 的区别？"></a>1. Post 和 Get 的区别？</h3><pre><code>Post 和 Get 是 HTTP 请求的两种方法。（1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。（2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。（3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。（4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。</code></pre><h3 id="2-TLS-SSL-中什么一定要用三个随机数，来生成-quot-会话密钥-quot-？"><a href="#2-TLS-SSL-中什么一定要用三个随机数，来生成-quot-会话密钥-quot-？" class="headerlink" title="2. TLS/SSL 中什么一定要用三个随机数，来生成&quot;会话密钥&quot;？"></a>2. TLS/SSL 中什么一定要用三个随机数，来生成&quot;会话密钥&quot;？</h3><pre><code>客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。使用三个随机数，是因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。通过使用三个随机数的方式，增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。</code></pre><h3 id="3-SSL-连接断开后如何恢复？"><a href="#3-SSL-连接断开后如何恢复？" class="headerlink" title="3. SSL 连接断开后如何恢复？"></a>3. SSL 连接断开后如何恢复？</h3><pre><code>一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</code></pre><h3 id="4-RSA-算法的安全性保障？"><a href="#4-RSA-算法的安全性保障？" class="headerlink" title="4. RSA 算法的安全性保障？"></a>4. RSA 算法的安全性保障？</h3><pre><code>对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。现在1024位的 RSA 密钥基本安全，2048位的密钥极其安全。</code></pre><h3 id="5-DNS-为什么使用-UDP-协议作为传输层协议？"><a href="#5-DNS-为什么使用-UDP-协议作为传输层协议？" class="headerlink" title="5. DNS 为什么使用 UDP 协议作为传输层协议？"></a>5. DNS 为什么使用 UDP 协议作为传输层协议？</h3><pre><code>DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。因为为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一个数据，UDP 只会将多余的数据给截取掉。为了解决这个问题，我们可以使用 TCP 协议去请求报文。DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，所以现在有了 DNS over HTTPS 来解决这个问题。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/310145373" target="_blank" rel="noopener external nofollow noreferrer">《为什么 DNS 使用 UDP 而不是 TCP？》</a></p><h3 id="6-当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#6-当你在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><pre><code>（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。（9）最后一步是 TCP 断开连接的四次挥手过程。</code></pre><p>详细资料可以参考：<br><a href="http://blog.jobbole.com/84870/" target="_blank" rel="noopener external nofollow noreferrer">《当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？》</a></p><h3 id="7-谈谈-CDN-服务？"><a href="#7-谈谈-CDN-服务？" class="headerlink" title="7. 谈谈 CDN 服务？"></a>7. 谈谈 CDN 服务？</h3><pre><code>CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035" target="_blank" rel="noopener external nofollow noreferrer">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h3 id="8-什么是正向代理和反向代理？"><a href="#8-什么是正向代理和反向代理？" class="headerlink" title="8. 什么是正向代理和反向代理？"></a>8. 什么是正向代理和反向代理？</h3><pre><code>我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。</code></pre><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s/ikrI3rmSYs83wdSWqq2QIg" target="_blank" rel="noopener external nofollow noreferrer">《正向代理与反向代理有什么区别》</a><br><a href="https://segmentfault.com/q/1010000017502539/a-1020000017532348" target="_blank" rel="noopener external nofollow noreferrer">《webpack 配置 proxy 反向代理的原理是什么？》</a></p><h3 id="9-负载平衡的两种实现方式？"><a href="#9-负载平衡的两种实现方式？" class="headerlink" title="9. 负载平衡的两种实现方式？"></a>9. 负载平衡的两种实现方式？</h3><pre><code>一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。</code></pre><p>详细资料可以参考：<br><a href="https://mp.weixin.qq.com/s?__biz=MzA5Njc2OTg4NQ==&mid=2247483870&idx=1&sn=bab36544ec62c394c104df699cf85154&chksm=90aa43eca7ddcafa01634cefee12fd8a332250d3f49d8b6647f536c215ac297e4b6a53af8253#rd" target="_blank" rel="noopener external nofollow noreferrer">《负载均衡的原理》</a></p><h3 id="10-http-请求方法-options-方法有什么用？"><a href="#10-http-请求方法-options-方法有什么用？" class="headerlink" title="10. http 请求方法 options 方法有什么用？"></a>10. http 请求方法 options 方法有什么用？</h3><pre><code> OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请 求方法，该方法会用&#39;*&#39;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</code></pre><p>相关资料可以参考：<br><a href="https://itbilu.com/other/relate/EkwKysXIl.html" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 请求方法》</a></p><h3 id="11-http1-1-和-http1-0-之间有哪些区别？"><a href="#11-http1-1-和-http1-0-之间有哪些区别？" class="headerlink" title="11. http1.1 和 http1.0 之间有哪些区别？"></a>11. http1.1 和 http1.0 之间有哪些区别？</h3><pre><code>http1.1 相对于 http1.0 有这样几个区别：（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener external nofollow noreferrer">《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 协议入门》</a><br><a href="https://blog.csdn.net/netdxy/article/details/51195560" target="_blank" rel="noopener external nofollow noreferrer">《网络---一篇文章详解请求头 Host 的概念》</a></p><h3 id="12-网站域名加-www-与不加-www-的区别？"><a href="#12-网站域名加-www-与不加-www-的区别？" class="headerlink" title="12. 网站域名加 www 与不加 www 的区别？"></a>12. 网站域名加 www 与不加 www 的区别？</h3><p>详细资料可以参考：<br><a href="https://www.f9seo.com/post-816.html" target="_blank" rel="noopener external nofollow noreferrer">《为什么域名前要加 www 前缀 www 是什么意思？》</a><br><a href="https://www.zhihu.com/question/20414602" target="_blank" rel="noopener external nofollow noreferrer">《为什么越来越多的网站域名不加「www」前缀？》</a><br><a href="https://blog.csdn.net/andybruse/article/details/7982278" target="_blank" rel="noopener external nofollow noreferrer">《域名有 www 与没有 www 有什么区别？》</a></p><h3 id="13-即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#13-即时通讯的实现，短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>13. 即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><pre><code>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</code></pre><p>详细资料可以参考：<br><a href="https://cloud.tencent.com/developer/article/1076547" target="_blank" rel="noopener external nofollow noreferrer">《轮询、长轮询、长连接、websocket》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener external nofollow noreferrer">《Server-Sent Events 教程》</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener external nofollow noreferrer">《WebSocket 教程》</a></p><h3 id="14-怎么实现多个网站之间共享登录状态"><a href="#14-怎么实现多个网站之间共享登录状态" class="headerlink" title="14. 怎么实现多个网站之间共享登录状态"></a>14. 怎么实现多个网站之间共享登录状态</h3><pre><code>在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将页面重定向会单点登录页面。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/35906139" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 是个无状态协议，怎么保持登录状态？》</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Css 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Css/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Css/</url>
      
        <content type="html"><![CDATA[<h3 id="1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h3><p>相关知识点：</p><pre><code>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分IE盒模型和W3C标准盒模型的区别：（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</code></pre><p>回答：</p><pre><code>盒模型都是由四个部分组成的，分别是margin、border、padding和content。标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</code></pre><p>详细的资料可以参考：<br><a href="https://juejin.im/post/59ef72f5f265da4320026f76" target="_blank" rel="noopener external nofollow noreferrer">《CSS 盒模型详解》</a></p><h3 id="2-CSS-选择符有哪些？"><a href="#2-CSS-选择符有哪些？" class="headerlink" title="2.CSS 选择符有哪些？"></a>2.CSS 选择符有哪些？</h3><pre><code>（1）id选择器（#myid）（2）类选择器（.myclassname）（3）标签选择器（div,h1,p）（4）后代选择器（h1 p）（5）相邻后代选择器（子）选择器（ul&gt;li）（6）兄弟选择器（li~a）（7）相邻兄弟选择器（li+a）（8）属性选择器（a[rel=&quot;external&quot;]）（9）伪类选择器（a:hover,li:nth-child）（10）伪元素选择器（::before、::after）（11）通配符选择器（*）</code></pre><h3 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。" class="headerlink" title="3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。"></a>3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</h3><p>相关知识点：</p><pre><code>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</code></pre><p>回答：</p><pre><code>在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</code></pre><h3 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4.伪类与伪元素的区别"></a>4.伪类与伪元素的区别</h3><pre><code>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</code></pre><p>详细资料可以参考：<br><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener external nofollow noreferrer">《总结伪类与伪元素》</a></p><h3 id="5-CSS-中哪些属性可以继承？"><a href="#5-CSS-中哪些属性可以继承？" class="headerlink" title="5.CSS 中哪些属性可以继承？"></a>5.CSS 中哪些属性可以继承？</h3><p>相关资料：</p><pre><code>每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。有继承性的属性：（1）字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust（2）文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color（3）表格布局属性caption-side border-collapse empty-cells（4）列表属性list-style-type、list-style-image、list-style-position、list-style（5）光标属性cursor（6）元素可见性visibility（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。</code></pre><p>回答：</p><pre><code>每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</code></pre><p>详细的资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/inheritance" target="_blank" rel="noopener external nofollow noreferrer">《继承属性》</a><br><a href="https://www.jianshu.com/p/34044e3c9317" target="_blank" rel="noopener external nofollow noreferrer">《CSS 有哪些属性可以继承？》</a></p><h3 id="6-CSS-优先级算法如何计算？"><a href="#6-CSS-优先级算法如何计算？" class="headerlink" title="6.CSS 优先级算法如何计算？"></a>6.CSS 优先级算法如何计算？</h3><p>相关知识点：</p><pre><code>CSS的优先级是根据样式声明的特殊性值来判断的。选择器的特殊性值分为四个等级，如下：（1）标签内选择符x,0,0,0（2）ID选择符0,x,0,0（3）class选择符/属性选择符/伪类选择符    0,0,x,0（4）元素和伪元素选择符0,0,0,x计算方法：（1）每个等级的初始值为0（2）每个等级的叠加为选择器出现的次数相加（3）不可进位，比如0,99,99,99（4）依次表示为：0,0,0,0（5）每个等级计数之间没关联（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值（7）如果两个优先级相同，则最后出现的优先级高，!important也适用（8）通配符选择器的特殊性值为：0,0,0,0（9）继承样式优先级最低，通配符样式优先级高于继承样式（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。计算实例：（1）#demo a&#123;color: orange;&#125;/*特殊性值：0,1,0,1*/（2）div#demo a&#123;color: red;&#125;/*特殊性值：0,1,0,2*/注意：（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。（2）特殊性值越大的声明优先级越高。（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的） (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑</code></pre><p>回答：</p><pre><code>判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。</code></pre><p>对于组合声明的特殊性值计算可以参考：<br><a href="https://www.jianshu.com/p/1c4e639ff7d5" target="_blank" rel="noopener external nofollow noreferrer">《CSS 优先级计算及应用》</a><br><a href="http://www.cnblogs.com/wangmeijian/p/4207433.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS 优先级计算规则》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/08/256-class-selector-beat-id-selector/" target="_blank" rel="noopener external nofollow noreferrer">《有趣：256 个 class 选择器可以干掉 1 个 id 选择器》</a></p><h3 id="7-关于伪类-LVHA-的解释"><a href="#7-关于伪类-LVHA-的解释" class="headerlink" title="7.关于伪类 LVHA 的解释?"></a>7.关于伪类 LVHA 的解释?</h3><pre><code>a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；当链接未访问过时：（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。当链接访问过时，情况基本同上，只不过需要将:link换成:visited。这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</code></pre><h3 id="8-CSS3-新增伪类有那些？"><a href="#8-CSS3-新增伪类有那些？" class="headerlink" title="8.CSS3 新增伪类有那些？"></a>8.CSS3 新增伪类有那些？</h3><pre><code>（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。（3）elem:last-child选中最后一个子元素。（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。（6）elem:first-of-type选中父元素下第一个elem类型元素。（7）elem:last-of-type选中父元素下最后一个elem类型元素。（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。（9）elem:empty选中不包含子元素和内容的elem类型元素。（10）elem:target选择当前活动的elem元素。（11）:not(elem)选择非elem元素的每个元素。（12）:enabled 控制表单控件的禁用状态。（13）:disabled    控制表单控件的禁用状态。(14):checked单选框或复选框被选中。</code></pre><p>详细的资料可以参考：<br><a href="https://www.cnblogs.com/SKLthegoodman/p/css3.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS3 新特性总结(伪类)》</a><br><a href="https://blog.csdn.net/zhouziyu2011/article/details/58605705" target="_blank" rel="noopener external nofollow noreferrer">《浅谈 CSS 伪类和伪元素及 CSS3 新增伪类》</a></p><h3 id="9-如何居中-div？"><a href="#9-如何居中-div？" class="headerlink" title="9.如何居中 div？"></a>9.如何居中 div？</h3><p>-水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性</p><pre><code class="css">div &#123;  width: 200px;  margin: 0 auto;&#125;</code></pre><p>-水平居中，利用 text-align:center 实现</p><pre><code class="css">.container &#123;  background: rgba(0, 0, 0, 0.5);  text-align: center;  font-size: 0;&#125;.box &#123;  display: inline-block;  width: 500px;  height: 400px;  background-color: pink;&#125;</code></pre><p>-让绝对定位的 div 居中</p><pre><code class="css">div &#123;  position: absolute;  width: 300px;  height: 300px;  margin: auto;  top: 0;  left: 0;  bottom: 0;  right: 0;  background-color: pink; /*方便看效果*/&#125;</code></pre><p>-水平垂直居中一</p><pre><code class="css">/*确定容器的宽高宽500高300的层设置层的外边距*/div &#123;  position: absolute; /*绝对定位*/  width: 500px;  height: 300px;  top: 50%;  left: 50%;  margin: -150px00-250px; /*外边距为自身宽高的一半*/  background-color: pink; /*方便看效果*/&#125;</code></pre><p>-水平垂直居中二</p><pre><code class="css">/*未知容器的宽高，利用`transform`属性*/div &#123;  position: absolute; /*相对定位或绝对定位均可*/  width: 500px;  height: 300px;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  background-color: pink; /*方便看效果*/&#125;</code></pre><p>-水平垂直居中三</p><pre><code class="css">/*利用flex布局实际使用时应考虑兼容性*/.container &#123;  display: flex;  align-items: center; /*垂直居中*/  justify-content: center; /*水平居中*/&#125;.containerdiv &#123;  width: 100px;  height: 100px;  background-color: pink; /*方便看效果*/&#125;</code></pre><p>-水平垂直居中四</p><pre><code class="css">/*利用text-align:center和vertical-align:middle属性*/.container &#123;  position: fixed;  top: 0;  right: 0;  bottom: 0;  left: 0;  background: rgba(0, 0, 0, 0.5);  text-align: center;  font-size: 0;  white-space: nowrap;  overflow: auto;&#125;.container::after &#123;  content: &quot;&quot;;  display: inline-block;  height: 100%;  vertical-align: middle;&#125;.box &#123;  display: inline-block;  width: 500px;  height: 400px;  background-color: pink;  white-space: normal;  vertical-align: middle;&#125;</code></pre><p>回答：</p><pre><code>一般常见的几种居中的方法有：对于宽高固定的元素（1）我们可以利用margin:0 auto来实现元素的水平居中。（2）利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。（3）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。（4）利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。（5）使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</code></pre><h3 id="10-display-有哪些值？说明他们的作用。"><a href="#10-display-有哪些值？说明他们的作用。" class="headerlink" title="10.display 有哪些值？说明他们的作用。"></a>10.display 有哪些值？说明他们的作用。</h3><pre><code>block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none    元素不显示，并从文档流中移除。inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。list-item    像块类型元素一样显示，并添加样式列表标记。table    此元素会作为块级表格来显示。inherit    规定应该从父元素继承display属性的值。</code></pre><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/css/pr_class_display.asp" target="_blank" rel="noopener external nofollow noreferrer">《CSS display 属性》</a></p><h3 id="11-position-的值-relative-和-absolute-定位原点是？"><a href="#11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="11.position 的值 relative 和 absolute 定位原点是？"></a>11.position 的值 relative 和 absolute 定位原点是？</h3><p>相关知识点：</p><pre><code>absolute生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。inherit规定从父元素继承position属性的值。</code></pre><p>回答：</p><pre><code>relative定位的元素，是相对于元素本身的正常位置来进行定位的。absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</code></pre><h3 id="12-CSS3-有哪些新特性？（根据项目回答）"><a href="#12-CSS3-有哪些新特性？（根据项目回答）" class="headerlink" title="12.CSS3 有哪些新特性？（根据项目回答）"></a>12.CSS3 有哪些新特性？（根据项目回答）</h3><pre><code>新增各种CSS选择器    （:not(.input)：所有class不是“input”的节点）圆角        （border-radius:8px）多列布局    （multi-column layout）阴影和反射    （Shadow\Reflect）文字特效        （text-shadow）文字渲染        （Text-decoration）线性渐变        （gradient）旋转            （transform）缩放，定位，倾斜，动画，多背景例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</code></pre><h3 id="13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>13.请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h3><p>相关知识点：</p><pre><code>Flex是FlexibleBox的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿主轴排列。以下6个属性设置在容器上。flex-direction属性决定主轴的方向（即项目的排列方向）。flex-wrap属性定义，如果一条轴线排不下，如何换行。flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。justify-content属性定义了项目在主轴上的对齐方式。align-items属性定义项目在交叉轴上如何对齐。align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。以下6个属性设置在项目上。order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</code></pre><p>回答：</p><pre><code>flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener external nofollow noreferrer">《Flex 布局教程：语法篇》</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener external nofollow noreferrer">《Flex 布局教程：实例篇》</a></p><h3 id="14-用纯-CSS-创建一个三角形的原理是什么？"><a href="#14-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="14.用纯 CSS 创建一个三角形的原理是什么？"></a>14.用纯 CSS 创建一个三角形的原理是什么？</h3><pre><code class="css">采用的是相邻边框连接处的均分原理。 将元素的宽高设为0，只设置 border ，把任意三条边隐藏掉（颜色设为 transparent），剩下的就是一个三角形。 #demo &#123;  width: 0;  height: 0;  border-width: 20px;  border-style: solid;  border-color: transparent transparent red transparent;&#125;</code></pre><h3 id="15-一个满屏品字布局如何设计"><a href="#15-一个满屏品字布局如何设计" class="headerlink" title="15.一个满屏品字布局如何设计?"></a>15.一个满屏品字布局如何设计?</h3><pre><code>简单的方式：    上面的div宽100%，    下面的两个div分别宽50%，    然后用float或者inline使其不换行即可</code></pre><h3 id="16-CSS-多列等高如何实现？"><a href="#16-CSS-多列等高如何实现？" class="headerlink" title="16.CSS 多列等高如何实现？"></a>16.CSS 多列等高如何实现？</h3><pre><code>（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度的特性，来实现多列等高。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0fb34151882515662238fd" target="_blank" rel="noopener external nofollow noreferrer">《前端应该掌握的 CSS 实现多列等高布局》</a><br><a href="https://codepen.io/yangbo5207/post/equh" target="_blank" rel="noopener external nofollow noreferrer">《CSS：多列等高布局》</a></p><h3 id="17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h3><pre><code>（1）png24位的图片在iE6浏览器上出现背景解决方案：做成PNG8，也可以引用一段脚本处理。（2）浏览器默认的margin和padding不同解决方案：加一个全局的*&#123;margin:0;padding:0;&#125;来统一。（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。#box&#123;float:left;width:10px;margin:0 0 0 10px;&#125;这种情况之下IE会产生20px的距离解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)（4）渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用&quot;\9&quot;这一标记，将IE游览器从所有情况中分离出来。接着，再次使用&quot;+&quot;将IE8和IE7、IE6分离开来，这样IE8已经独立识别。.bb&#123;background-color:#f1ee18;/*所有识别*/.background-color:#00deff\9;/*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/&#125;（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性解决方法：统一通过getAttribute()获取自定义属性。（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示解决方法：1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了解决方法：改变CSS属性的排列顺序L-V-H-A（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</code></pre><h3 id="18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><pre><code>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。解决办法：（1）为&lt;li&gt;设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。（2）将所有&lt;li&gt;写在同一行。不足：代码不美观。（3）将&lt;ul&gt;内的字符尺寸直接设为0，即font-size:0。不足：&lt;ul&gt;中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。（4）消除&lt;ul&gt;的字符间隔letter-spacing:-8px，不足：这也设置了&lt;li&gt;内的字符间隔，因此需要将&lt;li&gt;内的字符间隔设为默认letter-spacing:normal。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/sjinsa/article/details/70919546" target="_blank" rel="noopener external nofollow noreferrer">《li 与 li 之间有看不见的空白间隔是什么原因引起的？》</a></p><h3 id="19-为什么要初始化-CSS-样式？"><a href="#19-为什么要初始化-CSS-样式？" class="headerlink" title="19.为什么要初始化 CSS 样式？"></a>19.为什么要初始化 CSS 样式？</h3><pre><code>-因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。-当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法：*&#123;padding:0;margin:0;&#125;（强烈不建议）淘宝的样式初始化代码：body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td&#123;margin:0;padding:0;&#125;body,button,input,select,textarea&#123;font:12px/1.5tahoma,arial,\5b8b\4f53;&#125;h1,h2,h3,h4,h5,h6&#123;font-size:100%;&#125;address,cite,dfn,em,var&#123;font-style:normal;&#125;code,kbd,pre,samp&#123;font-family:couriernew,courier,monospace;&#125;small&#123;font-size:12px;&#125;ul,ol&#123;list-style:none;&#125;a&#123;text-decoration:none;&#125;a:hover&#123;text-decoration:underline;&#125;sup&#123;vertical-align:text-top;&#125;sub&#123;vertical-align:text-bottom;&#125;legend&#123;color:#000;&#125;fieldset,img&#123;border:0;&#125;button,input,select,textarea&#123;font-size:100%;&#125;table&#123;border-collapse:collapse;border-spacing:0;&#125;</code></pre><h3 id="20-什么是包含块，对于包含块的理解"><a href="#20-什么是包含块，对于包含块的理解" class="headerlink" title="20.什么是包含块，对于包含块的理解?"></a>20.什么是包含块，对于包含块的理解?</h3><pre><code>包含块（containing block）就是元素用来计算和定位的一个框。（1）根元素（很多场景下可以看成是&lt;html&gt;）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。（3）如果元素position:fixed，则“包含块”是“初始包含块”。（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：如果该祖先元素是纯inline元素，则规则略复杂：•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</code></pre><h3 id="21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</h3><pre><code>（1）对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。（2）但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。在不同浏览器下的区别：在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</code></pre><p>详细资料可以参考：<br><a href="http://www.webhek.com/post/visibility-collapse.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS 里的 visibility 属性有个鲜为人知的属性值：collapse》</a></p><h3 id="22-width-auto-和-width-100-的区别"><a href="#22-width-auto-和-width-100-的区别" class="headerlink" title="22.width:auto 和 width:100%的区别"></a>22.width:auto 和 width:100%的区别</h3><pre><code>一般而言width:100%会使元素box的宽度等于父元素的content box的宽度。width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</code></pre><h3 id="23-绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#23-绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="23.绝对定位元素与非绝对定位元素的百分比计算的区别"></a>23.绝对定位元素与非绝对定位元素的百分比计算的区别</h3><pre><code>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</code></pre><h3 id="24-简单介绍使用图片-base64-编码的优点和缺点。"><a href="#24-简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="24.简单介绍使用图片 base64 编码的优点和缺点。"></a>24.简单介绍使用图片 base64 编码的优点和缺点。</h3><pre><code>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。使用base64的优点是：（1）减少一个图片的HTTP请求使用base64的缺点是：（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要差很多。（3）兼容性的问题，ie8以前的浏览器不支持。一般一些网站的小图标可以使用base64图片来引入。</code></pre><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="noopener external nofollow noreferrer">《玩转图片 base64 编码》</a><br><a href="https://www.zhihu.com/question/31155574" target="_blank" rel="noopener external nofollow noreferrer">《前端开发中，使用 base64 图片的弊端是什么？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener external nofollow noreferrer">《小 tip:base64:URL 背景图片与 web 页面性能优化》</a></p><h3 id="25-39-display-39-、-39-position-39-和-39-float-39-的相互关系？"><a href="#25-39-display-39-、-39-position-39-和-39-float-39-的相互关系？" class="headerlink" title="25.&#39;display&#39;、&#39;position&#39;和&#39;float&#39;的相互关系？"></a>25.&#39;display&#39;、&#39;position&#39;和&#39;float&#39;的相互关系？</h3><pre><code>（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。总的来说，可以把它看作是一个类似优先级的机制，&quot;position:absolute&quot;和&quot;position:fixed&quot;优先级最高，有它存在的时候，浮动不起作用，&#39;display&#39;的值也需要调整；其次，元素的&#39;float&#39;特性的值不是&quot;none&quot;的时候或者它是根元素的时候，调整&#39;display&#39;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#39;display&#39;特性值同设置值。</code></pre><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/jackyWHJ/p/3756087.html" target="_blank" rel="noopener external nofollow noreferrer">《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》</a></p><h3 id="26-margin-重叠问题的理解。"><a href="#26-margin-重叠问题的理解。" class="headerlink" title="26.margin 重叠问题的理解。"></a>26.margin 重叠问题的理解。</h3><p>相关知识点：</p><pre><code>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。产生折叠的必备条件：margin必须是邻接的!而根据w3c规范，两个margin是邻接的必须满足以下条件：•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。•没有线盒，没有空隙，没有padding和border将他们分隔开•都属于垂直方向上相邻的外边距，可以是下面任意一种情况•元素的margin-top与其第一个常规文档流的子元素的margin-top•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottommargin合并的3种场景：（1）相邻兄弟元素margin合并。解决办法：•设置块状格式化上下文元素（BFC）（2）父级和第一个/最后一个子元素的margin合并。解决办法：对于margin-top合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-top值；•父元素设置padding-top值；•父元素和第一个子元素之间添加内联元素进行分隔。对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：•父元素设置为块状格式化上下文元素；•父元素设置border-bottom值；•父元素设置padding-bottom值；•父元素和最后一个子元素之间添加内联元素进行分隔；•父元素设置height、min-height或max-height。（3）空块级元素的margin合并。解决办法：•设置垂直方向的border；•设置垂直方向的padding；•里面添加内联元素（直接Space键空格是没用的）；•设置height或者min-height。</code></pre><p>回答：</p><pre><code>margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。一般来说可以分为四种情形：第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC来解决。第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC来解决。第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、padding或者高度来解决这个问题。</code></pre><h3 id="27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？"><a href="#27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？" class="headerlink" title="27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？"></a>27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</h3><p>相关知识点：</p><pre><code>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。通俗来讲•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。创建BFC（1）根元素或包含根元素的元素（2）浮动元素float＝left|right或inherit（≠none）（3）绝对定位元素position＝absolute或fixed（4）display＝inline-block|flex|inline-flex|table-cell或table-caption（5）overflow＝hidden|auto或scroll(≠visible)</code></pre><p>回答：</p><pre><code>BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。还有就是元素的overflow的值不为visible时都会创建BFC。</code></pre><p>详细资料可以参考：<br><a href="https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html" target="_blank" rel="noopener external nofollow noreferrer">《深入理解 BFC 和 MarginCollapse》</a><br><a href="https://segmentfault.com/a/1190000013647777" target="_blank" rel="noopener external nofollow noreferrer">《前端面试题-BFC（块格式化上下文）》</a></p><h3 id="28-IFC-是什么？"><a href="#28-IFC-是什么？" class="headerlink" title="28.IFC 是什么？"></a>28.IFC 是什么？</h3><pre><code>IFC指的是行级格式化上下文，它有这样的一些布局规则：（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。（2）当一行不够的时候会自动切换到下一行。（3）行级上下文的高度由内部最高的内联盒子的高度决定。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004466536#articleHeader5" target="_blank" rel="noopener external nofollow noreferrer">《[译]:BFC 与 IFC》</a><br><a href="https://blog.csdn.net/paintandraw/article/details/80401741" target="_blank" rel="noopener external nofollow noreferrer">《BFC 和 IFC 的理解（布局）》</a></p><h3 id="29-请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#29-请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="29.请解释一下为什么需要清除浮动？清除浮动的方式"></a>29.请解释一下为什么需要清除浮动？清除浮动的方式</h3><pre><code>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。清除浮动的方式（1）使用clear属性清除浮动。参考28。（2）使用BFC块级格式化上下文来清除浮动。参考26。因为BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违BFC元素的子元素不会影响外部元素的设定。</code></pre><h3 id="30-使用-clear-属性清除浮动的原理？"><a href="#30-使用-clear-属性清除浮动的原理？" class="headerlink" title="30.使用 clear 属性清除浮动的原理？"></a>30.使用 clear 属性清除浮动的原理？</h3><pre><code>使用clear属性清除浮动，其语法如下：clear:none|left|right|both如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。一般使用伪元素的方式清除浮动.clear::after&#123;content:&#39;&#39;;display:table;//也可以是&#39;block&#39;，或者是&#39;list-item&#39;clear:both;&#125;clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</code></pre><h3 id="31-zoom-1-的清除浮动原理"><a href="#31-zoom-1-的清除浮动原理" class="headerlink" title="31.zoom:1 的清除浮动原理?"></a>31.zoom:1 的清除浮动原理?</h3><pre><code>清除浮动，触发hasLayout；zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在CSS3.0规范草案中。目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。</code></pre><h3 id="32-移动端的布局用过媒体查询吗？"><a href="#32-移动端的布局用过媒体查询吗？" class="headerlink" title="32.移动端的布局用过媒体查询吗？"></a>32.移动端的布局用过媒体查询吗？</h3><pre><code>假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</code></pre><p>详细资料可以参考：<br><a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS3@media 查询》</a><br><a href="http://caibaojian.com/356.html" target="_blank" rel="noopener external nofollow noreferrer">《响应式布局和自适应布局详解》</a></p><h3 id="33-使用-CSS-预处理器吗？喜欢哪个？"><a href="#33-使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="33.使用 CSS 预处理器吗？喜欢哪个？"></a>33.使用 CSS 预处理器吗？喜欢哪个？</h3><pre><code>SASS（SASS、LESS没有本质区别，只因为团队前端都是用的SASS）</code></pre><h3 id="34-CSS-优化、提高性能的方法有哪些？"><a href="#34-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="34.CSS 优化、提高性能的方法有哪些？"></a>34.CSS 优化、提高性能的方法有哪些？</h3><pre><code>加载性能：（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。选择器性能：（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。（3）避免使用通配规则，如*&#123;&#125;计算次数惊人！只对需要用到的元素进行选择。（4）尽量少的去对标签进行选择，而是用class。（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。渲染性能：（1）慎重使用高性能属性：浮动、定位。（2）尽量减少页面重排、重绘。（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。（4）属性值为0时，不加单位。（5）属性值为浮动小数0.**，可以省略小数点之前的0。（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。（7）不使用@import前缀，它会影响css的加载速度。（8）选择器优化嵌套，尽量避免层级过深。（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。可维护性、健壮性：（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。（2）样式与内容分离：将css代码定义到外部css中。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19886806" target="_blank" rel="noopener external nofollow noreferrer">《CSS 优化、提高性能的方法有哪些？》</a><br><a href="https://www.jianshu.com/p/4e673bf24a3b" target="_blank" rel="noopener external nofollow noreferrer">《CSS 优化，提高性能的方法》</a></p><h3 id="35-浏览器是怎样解析-CSS-选择器的？"><a href="#35-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="35.浏览器是怎样解析 CSS 选择器的？"></a>35.浏览器是怎样解析 CSS 选择器的？</h3><pre><code>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5a123c55f265da432240cc90" target="_blank" rel="noopener external nofollow noreferrer">《探究 CSS 解析原理》</a></p><h3 id="36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="36.在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>36.在网页中应该使用奇数还是偶数的字体？为什么呢？</h3><pre><code>（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jian_xi/article/details/79346477" target="_blank" rel="noopener external nofollow noreferrer">《谈谈网页中使用奇数字体和偶数字体》</a><br><a href="https://www.zhihu.com/question/20440679" target="_blank" rel="noopener external nofollow noreferrer">《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》</a></p><h3 id="37-margin-和-padding-分别适合什么场景使用？"><a href="#37-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="37.margin 和 padding 分别适合什么场景使用？"></a>37.margin 和 padding 分别适合什么场景使用？</h3><pre><code>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干。padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。何时应当使用margin：•需要在border外侧添加空白时。•空白处不需要背景（色）时。•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。何时应当时用padding：•需要在border内测添加空白时。•空白处需要背景（色）时。•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</code></pre><h3 id="38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题"><a href="#38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题" class="headerlink" title="38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]"></a>38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h3><pre><code>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。</code></pre><p>详细资料可以参考：<br><a href="http://nec.netease.com/standard/css-sort.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS 规范-分类方法》</a></p><h3 id="39-简单说一下-css3-的-all-属性。"><a href="#39-简单说一下-css3-的-all-属性。" class="headerlink" title="39.简单说一下 css3 的 all 属性。"></a>39.简单说一下 css3 的 all 属性。</h3><pre><code>all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/" target="_blank" rel="noopener external nofollow noreferrer">《简单了解 CSS3 的 all 属性》</a></p><h3 id="40-为什么不建议使用统配符初始化-css-样式。"><a href="#40-为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="40.为什么不建议使用统配符初始化 css 样式。"></a>40.为什么不建议使用统配符初始化 css 样式。</h3><pre><code>采用*&#123;padding:0;margin:0;&#125;这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可，并不需使用通配符*来初始化。</code></pre><h3 id="41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h3><pre><code>（1）内联元素也可以作为“包含块”所在的元素；（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；（3）边界是padding box而不是content box。</code></pre><h3 id="42-对于-hasLayout-的理解？"><a href="#42-对于-hasLayout-的理解？" class="headerlink" title="42.对于 hasLayout 的理解？"></a>42.对于 hasLayout 的理解？</h3><pre><code>hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000010883974" target="_blank" rel="noopener external nofollow noreferrer">《CSS 基础篇--CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》</a><br><a href="https://segmentfault.com/a/1190000004632071" target="_blank" rel="noopener external nofollow noreferrer">《CSS 魔法堂：hasLayout 原来是这样的！》</a></p><h3 id="43-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#43-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="43.元素竖向的百分比设定是相对于容器的高度吗？"></a>43.元素竖向的百分比设定是相对于容器的高度吗？</h3><pre><code>如果是height的话，是相对于包含块的高度。如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</code></pre><h3 id="44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）"><a href="#44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）" class="headerlink" title="44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）"></a>44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</h3><pre><code>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。overflow：hidden；transition：all 1000 ms ease；</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/liona_koukou/article/details/52680409" target="_blank" rel="noopener external nofollow noreferrer">《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》</a><br><a href="https://juejin.im/post/5aeef41cf265da0ba0630de0" target="_blank" rel="noopener external nofollow noreferrer">《用 ES6 写全屏滚动插件》</a></p><h3 id="45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）"><a href="#45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）" class="headerlink" title="45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）"></a>45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</h3><pre><code>响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/dreamerframework/article/details/8994741" target="_blank" rel="noopener external nofollow noreferrer">《响应式布局原理》</a><br><a href="http://www.mahaixiang.cn/wzsj/278.html" target="_blank" rel="noopener external nofollow noreferrer">《响应式布局的实现方法和原理》</a></p><h3 id="46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"><a href="#46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）" class="headerlink" title="46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"></a>46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</h3><pre><code>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20990029" target="_blank" rel="noopener external nofollow noreferrer">《如何实现视差滚动效果的网页？》</a></p><h3 id="47-如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#47-如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="47.如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</h3><pre><code>chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：&#123;background-color:rgb(250,255,189)!important;background-image:none!important;color:rgb(0,0,0)!important;&#125;对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill&#123;-webkit-box-shadow:000px 1000px white inset;border:1px solid #CCC !important;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/zsl_955200/article/details/78276209" target="_blank" rel="noopener external nofollow noreferrer">《去掉 chrome 记住密码后的默认填充样式》</a><br><a href="https://blog.csdn.net/M_agician/article/details/73381706" target="_blank" rel="noopener external nofollow noreferrer">《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》</a></p><h3 id="48-怎么让-Chrome-支持小于-12px-的文字？"><a href="#48-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="48.怎么让 Chrome 支持小于 12px 的文字？"></a>48.怎么让 Chrome 支持小于 12px 的文字？</h3><pre><code>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。解决办法：（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/...；（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</code></pre><p>详细资料可以参考：<br><a href="https://570109268.iteye.com/blog/2406562" target="_blank" rel="noopener external nofollow noreferrer">《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》</a></p><h3 id="49-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#49-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="49.让页面里的字体变清晰，变细用 CSS 怎么做？"></a>49.让页面里的字体变清晰，变细用 CSS 怎么做？</h3><pre><code>webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/huo_bao/article/details/50251585" target="_blank" rel="noopener external nofollow noreferrer">《让字体变的更清晰 CSS 中-webkit-font-smoothing》</a></p><h3 id="50-font-style-属性中-italic-和-oblique-的区别？"><a href="#50-font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="50.font-style 属性中 italic 和 oblique 的区别？"></a>50.font-style 属性中 italic 和 oblique 的区别？</h3><pre><code>italic和oblique这两个关键字都表示“斜体”的意思。它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。</code></pre><h3 id="51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h3><pre><code>设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</code></pre><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/libin-1/p/7148377.html" target="_blank" rel="noopener external nofollow noreferrer">《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》</a><br><a href="https://www.jianshu.com/p/af6dad66e49a" target="_blank" rel="noopener external nofollow noreferrer">《前端工程师需要明白的「像素」》</a><br><a href="https://github.com/jawil/blog/issues/21" target="_blank" rel="noopener external nofollow noreferrer">《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》</a><br><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15" target="_blank" rel="noopener external nofollow noreferrer">《前端开发中像素的概念》</a></p><h3 id="52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="52.layout viewport、visual viewport 和 ideal viewport 的区别？"></a>52.layout viewport、visual viewport 和 ideal viewport 的区别？</h3><p>相关知识点：</p><pre><code>如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做layout viewport。layout viewport的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，ppk把这个viewport叫做visual viewport。ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。</code></pre><p>回答：</p><pre><code>移动端一共需要理解三个viewport的概念的理解。第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visual viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</code></pre><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="noopener external nofollow noreferrer">《移动前端开发之 viewport 的深入理解》</a><br><a href="https://www.html.cn/archives/5975" target="_blank" rel="noopener external nofollow noreferrer">《说说移动前端中 viewport（视口）》</a><br><a href="https://juejin.im/post/5b6d21daf265da0f9d1a2ed7#heading-14" target="_blank" rel="noopener external nofollow noreferrer">《移动端适配知识你到底知多少》</a></p><h3 id="53-position-fixed-在-android-下无效怎么处理？"><a href="#53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="53.position:fixed;在 android 下无效怎么处理？"></a>53.position:fixed;在 android 下无效怎么处理？</h3><pre><code>因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;/&gt;</code></pre><h3 id="54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3><pre><code>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</code></pre><h3 id="55-如何让去除-inline-block-元素间间距？"><a href="#55-如何让去除-inline-block-元素间间距？" class="headerlink" title="55.如何让去除 inline-block 元素间间距？"></a>55.如何让去除 inline-block 元素间间距？</h3><pre><code>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</code></pre><p>详细资料可以参考：<br><a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="noopener external nofollow noreferrer">《去除 inline-block 元素间间距的 N 种方法》</a></p><h3 id="56-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#56-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="56.overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>56.overflow:scroll 时不能平滑滚动的问题怎么处理？</h3><pre><code>以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流畅。</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/1f4693d0ad2d" target="_blank" rel="noopener external nofollow noreferrer">《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》</a></p><h3 id="57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。"><a href="#57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。" class="headerlink" title="57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。"></a>57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</h3><pre><code>（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;left:0;right:0;（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/xutongbao/article/details/79408522" target="_blank" rel="noopener external nofollow noreferrer">《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》</a></p><h3 id="58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h3><p>相关知识点：</p><pre><code>（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</code></pre><p>回答：</p><pre><code>我了解到的一共有七种常见的图片的格式。（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比较大。（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般适合于用来制作一些网站logo或者图标之类的图片。（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</code></pre><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/xinzhao/p/5130410.html" target="_blank" rel="noopener external nofollow noreferrer">《图片格式那么多，哪种更适合你？》</a></p><h3 id="59-浏览器如何判断是否支持-webp-格式图片"><a href="#59-浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="59.浏览器如何判断是否支持 webp 格式图片"></a>59.浏览器如何判断是否支持 webp 格式图片</h3><pre><code>（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jesslu/article/details/82495061" target="_blank" rel="noopener external nofollow noreferrer">《判断浏览器是否支持 WebP 图片》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL" target="_blank" rel="noopener external nofollow noreferrer">《toDataURL()》</a></p><h3 id="60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h3><pre><code>网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/36514327?rf=37353035" target="_blank" rel="noopener external nofollow noreferrer">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h3 id="61-style-标签写在-body-后与-body-前有什么区别？"><a href="#61-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="61.style 标签写在 body 后与 body 前有什么区别？"></a>61.style 标签写在 body 后与 body 前有什么区别？</h3><pre><code>页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</code></pre><h3 id="62-什么是-CSS-预处理器-后处理器？"><a href="#62-什么是-CSS-预处理器-后处理器？" class="headerlink" title="62.什么是 CSS 预处理器/后处理器？"></a>62.什么是 CSS 预处理器/后处理器？</h3><pre><code>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/yushuangyushuang/article/details/79209752" target="_blank" rel="noopener external nofollow noreferrer">《CSS 预处理器和后处理器》</a></p><h3 id="63-阐述一下-CSSSprites"><a href="#63-阐述一下-CSSSprites" class="headerlink" title="63.阐述一下 CSSSprites"></a>63.阐述一下 CSSSprites</h3><pre><code>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites能减少图片的字节。优点：减少HTTP请求数，极大地提高页面加载速度增加图片信息重复度，提高压缩比，减少图片大小更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现缺点：图片合并麻烦维护麻烦，修改一个图片可能需要重新布局整个图片，样式</code></pre><h3 id="64-使用-rem-布局的优缺点？"><a href="#64-使用-rem-布局的优缺点？" class="headerlink" title="64.使用 rem 布局的优缺点？"></a>64.使用 rem 布局的优缺点？</h3><pre><code>优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21504656" target="_blank" rel="noopener external nofollow noreferrer">《css3 的字体大小单位 rem 到底好在哪？》</a><br><a href="https://www.jianshu.com/p/e8ae1c3861dc" target="_blank" rel="noopener external nofollow noreferrer">《VW:是时候放弃 REM 布局了》</a><br><a href="https://blog.csdn.net/Honeymao/article/details/76795089" target="_blank" rel="noopener external nofollow noreferrer">《为什么设计稿是 750px》</a><br><a href="https://github.com/amfe/article/issues/17" target="_blank" rel="noopener external nofollow noreferrer">《使用 Flexible 实现手淘 H5 页面的终端适配》</a></p><h3 id="65-几种常见的-CSS-布局"><a href="#65-几种常见的-CSS-布局" class="headerlink" title="65.几种常见的 CSS 布局"></a>65.几种常见的 CSS 布局</h3><p>详细的资料可以参考：<br><a href="https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12" target="_blank" rel="noopener external nofollow noreferrer">《几种常见的 CSS 布局》</a></p><h3 id="66-画一条-0-5px-的线"><a href="#66-画一条-0-5px-的线" class="headerlink" title="66.画一条 0.5px 的线"></a>66.画一条 0.5px 的线</h3><pre><code>采用meta viewport的方式采用border-image的方式采用transform:scale()的方式</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab65f40f265da2384408a95" target="_blank" rel="noopener external nofollow noreferrer">《怎么画一条 0.5px 的边（更新）》</a></p><h3 id="67-transition-和-animation-的区别"><a href="#67-transition-和-animation-的区别" class="headerlink" title="67.transition 和 animation 的区别"></a>67.transition 和 animation 的区别</h3><pre><code>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19749045" target="_blank" rel="noopener external nofollow noreferrer">《CSSanimation 与 CSStransition 有何区别？》</a><br><a href="https://blog.csdn.net/cddcj/article/details/53582334" target="_blank" rel="noopener external nofollow noreferrer">《CSS3Transition 和 Animation 区别及比较》</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS 动画简介》</a><br><a href="https://juejin.im/post/5b137e6e51882513ac201dfb" target="_blank" rel="noopener external nofollow noreferrer">《CSS 动画：animation、transition、transform、translate》</a></p><h3 id="68-什么是首选最小宽度？"><a href="#68-什么是首选最小宽度？" class="headerlink" title="68.什么是首选最小宽度？"></a>68.什么是首选最小宽度？</h3><pre><code>“首选最小宽度”，指的是元素最适合的最小宽度。东亚文字（如中文）最小宽度为每个汉字的宽度。西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</code></pre><h3 id="69-为什么-height-100-会无效？"><a href="#69-为什么-height-100-会无效？" class="headerlink" title="69.为什么 height:100%会无效？"></a>69.为什么 height:100%会无效？</h3><pre><code>对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</code></pre><h3 id="70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h3><pre><code>（1）max-width会覆盖width，即使width是行类样式或者设置了!important。（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</code></pre><h3 id="71-内联盒模型基本概念"><a href="#71-内联盒模型基本概念" class="headerlink" title="71.内联盒模型基本概念"></a>71.内联盒模型基本概念</h3><pre><code>（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。（4）包含块（containing box），由一行一行的“行框盒子”组成。</code></pre><h3 id="72-什么是幽灵空白节点？"><a href="#72-什么是幽灵空白节点？" class="headerlink" title="72.什么是幽灵空白节点？"></a>72.什么是幽灵空白节点？</h3><pre><code>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</code></pre><h3 id="73-什么是替换元素？"><a href="#73-什么是替换元素？" class="headerlink" title="73.什么是替换元素？"></a>73.什么是替换元素？</h3><pre><code>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;或者表单元素&lt;textarea&gt;和&lt;input&gt;和&lt;select&gt;都是典型的替换元素。替换元素除了内容可替换这一特性以外，还有以下一些特性。（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口，（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如&lt;video&gt;、&lt;iframe&gt;或者&lt;canvas&gt;等，也有少部分替换元素为0像素，如&lt;img&gt;图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</code></pre><h3 id="74-替换元素的计算规则？"><a href="#74-替换元素的计算规则？" class="headerlink" title="74.替换元素的计算规则？"></a>74.替换元素的计算规则？</h3><pre><code>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括&lt;img&gt;的width和height属性、&lt;input&gt;的size属性、&lt;textarea&gt;的cols和rows属性等。（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。这3层结构的计算规则具体如下（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</code></pre><h3 id="75-content-与替换元素的关系？"><a href="#75-content-与替换元素的关系？" class="headerlink" title="75.content 与替换元素的关系？"></a>75.content 与替换元素的关系？</h3><pre><code>content属性生成的对象称为“匿名替换元素”。（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。（2）content生成的内容不能左右:empty伪类。（3）content动态生成值无法获取。</code></pre><h3 id="76-margin-auto-的填充规则？"><a href="#76-margin-auto-的填充规则？" class="headerlink" title="76.margin:auto 的填充规则？"></a>76.margin:auto 的填充规则？</h3><pre><code>margin的&#39;auto&#39;可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。（1）如果一侧定值，一侧auto，则auto为剩余空间大小。（2）如果两侧均是auto，则平分剩余空间。</code></pre><h3 id="77-margin-无效的情形"><a href="#77-margin-无效的情形" class="headerlink" title="77.margin 无效的情形"></a>77.margin 无效的情形</h3><pre><code>（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。（2）表格中的&lt;tr&gt;和&lt;td&gt;元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。（3）绝对定位元素非定位方位的margin值“无效”。（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</code></pre><h3 id="78-border-的特殊性？"><a href="#78-border-的特殊性？" class="headerlink" title="78.border 的特殊性？"></a>78.border 的特殊性？</h3><pre><code>（1）border-width却不支持百分比。（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。（4）border-color默认颜色就是color色值。（5）默认background背景图片是相对于padding box定位的。</code></pre><h3 id="79-什么是基线和-x-height？"><a href="#79-什么是基线和-x-height？" class="headerlink" title="79.什么是基线和 x-height？"></a>79.什么是基线和 x-height？</h3><pre><code>字母x的下边缘（线）就是我们的基线。x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</code></pre><h3 id="80-line-height-的特殊性？"><a href="#80-line-height-的特殊性？" class="headerlink" title="80.line-height 的特殊性？"></a>80.line-height 的特殊性？</h3><pre><code>（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。（3）行距=line-height-font-size。（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</code></pre><h3 id="81-vertical-align-的特殊性？"><a href="#81-vertical-align-的特殊性？" class="headerlink" title="81.vertical-align 的特殊性？"></a>81.vertical-align 的特殊性？</h3><pre><code>（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成&lt;td&gt;元素，则和&lt;tr&gt;元素上边缘对齐。（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</code></pre><h3 id="82-overflow-的特殊性？"><a href="#82-overflow-的特殊性？" class="headerlink" title="82.overflow 的特殊性？"></a>82.overflow 的特殊性？</h3><pre><code>（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素&lt;html&gt;，另一个是文本域&lt;textarea&gt;。（3）滚动条会占用容器的可用宽度或高度。（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</code></pre><h3 id="83-无依赖绝对定位是什么？"><a href="#83-无依赖绝对定位是什么？" class="headerlink" title="83.无依赖绝对定位是什么？"></a>83.无依赖绝对定位是什么？</h3><pre><code>没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</code></pre><h3 id="84-absolute-与-overflow-的关系？"><a href="#84-absolute-与-overflow-的关系？" class="headerlink" title="84.absolute 与 overflow 的关系？"></a>84.absolute 与 overflow 的关系？</h3><pre><code>（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</code></pre><h3 id="85-clip-裁剪是什么？"><a href="#85-clip-裁剪是什么？" class="headerlink" title="85.clip 裁剪是什么？"></a>85.clip 裁剪是什么？</h3><pre><code>所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</code></pre><h3 id="86-relative-的特殊性？"><a href="#86-relative-的特殊性？" class="headerlink" title="86.relative 的特殊性？"></a>86.relative 的特殊性？</h3><pre><code>（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</code></pre><h3 id="87-什么是层叠上下文？"><a href="#87-什么是层叠上下文？" class="headerlink" title="87.什么是层叠上下文？"></a>87.什么是层叠上下文？</h3><pre><code>层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。层叠上下文元素有如下特性：（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。（2）层叠上下文可以阻断元素的混合模式。（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。层叠上下文的创建：（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是&lt;html&gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。（3）其他一些CSS3属性，比如元素的opacity值不是1。</code></pre><h3 id="88-什么是层叠水平？"><a href="#88-什么是层叠水平？" class="headerlink" title="88.什么是层叠水平？"></a>88.什么是层叠水平？</h3><pre><code>层叠水平，英文称作stacking level，决定了同一个层叠上下文中元素在z轴上的显示顺序。显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。</code></pre><h3 id="89-元素的层叠顺序？"><a href="#89-元素的层叠顺序？" class="headerlink" title="89.元素的层叠顺序？"></a>89.元素的层叠顺序？</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。</p><p><img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png" class="lazyload" data-srcset="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="层叠顺序"></p><h3 id="90-层叠准则？"><a href="#90-层叠准则？" class="headerlink" title="90.层叠准则？"></a>90.层叠准则？</h3><pre><code>（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</code></pre><h3 id="91-font-weight-的特殊性？"><a href="#91-font-weight-的特殊性？" class="headerlink" title="91.font-weight 的特殊性？"></a>91.font-weight 的特殊性？</h3><pre><code>如果使用数值作为font-weight属性值，必须是100～900的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。</code></pre><h3 id="92-text-indent-的特殊性？"><a href="#92-text-indent-的特殊性？" class="headerlink" title="92.text-indent 的特殊性？"></a>92.text-indent 的特殊性？</h3><pre><code>（1）text-indent仅对第一行内联盒子内容有效。（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。（3）&lt;input&gt;标签按钮text-indent值无效。（4）&lt;button&gt;标签按钮text-indent值有效。（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</code></pre><h3 id="93-letter-spacing-与字符间距？"><a href="#93-letter-spacing-与字符间距？" class="headerlink" title="93.letter-spacing 与字符间距？"></a>93.letter-spacing 与字符间距？</h3><pre><code>letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。letter-spacing具有以下一些特性。（1）继承性。（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。（5）支持小数值，即使0.1px也是支持的。（6）暂不支持百分比值。</code></pre><h3 id="94-word-spacing-与单词间距？"><a href="#94-word-spacing-与单词间距？" class="headerlink" title="94.word-spacing 与单词间距？"></a>94.word-spacing 与单词间距？</h3><pre><code>letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。</code></pre><h3 id="95-white-space-与换行和空格的控制？"><a href="#95-white-space-与换行和空格的控制？" class="headerlink" title="95.white-space 与换行和空格的控制？"></a>95.white-space 与换行和空格的控制？</h3><pre><code>white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。其属性值包括下面这些。•normal：合并空白字符和换行符。•pre：空白字符不合并，并且内容只在有换行符的地方换行。•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</code></pre><h3 id="96-隐藏元素的-background-image-到底加不加载？"><a href="#96-隐藏元素的-background-image-到底加不加载？" class="headerlink" title="96.隐藏元素的 background-image 到底加不加载？"></a>96.隐藏元素的 background-image 到底加不加载？</h3><p>相关知识点：</p><pre><code>根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使用的。如果不是background-image，而是&lt;img&gt;元素，则设置display:none在所有浏览器下依旧都会请求图片资源。还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。</code></pre><p>回答：</p><p>-（1）元素的背景图片</p><p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>-:hover 样式下，触发时请求</p><p>-（2）img 标签图片任何情况下都会请求图片</p><p>详细资料可以参考：<br><a href="https://www.jb51.net/css/469033.html" target="_blank" rel="noopener external nofollow noreferrer">《CSS 控制前端图片 HTTP 请求的各种情况示例》</a></p><h3 id="97-如何实现单行／多行文本溢出的省略（-）？"><a href="#97-如何实现单行／多行文本溢出的省略（-）？" class="headerlink" title="97.如何实现单行／多行文本溢出的省略（...）？"></a>97.如何实现单行／多行文本溢出的省略（...）？</h3><pre><code class="css">/*单行文本溢出*/p &#123;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;&#125;/*多行文本溢出*/p &#123;  position: relative;  line-height: 1.5em;  /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/  height: 3em;  overflow: hidden;&#125;p:after &#123;  content: &quot;...&quot;;  position: absolute;  bottom: 0;  right: 0;  background-color: #fff;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/30707916" target="_blank" rel="noopener external nofollow noreferrer">《【CSS/JS】如何实现单行／多行文本溢出的省略》</a><br><a href="https://juejin.im/entry/587f453e1b69e60058555a5f" target="_blank" rel="noopener external nofollow noreferrer">《CSS 多行文本溢出省略显示》</a></p><h3 id="98-常见的元素隐藏方式？"><a href="#98-常见的元素隐藏方式？" class="headerlink" title="98.常见的元素隐藏方式？"></a>98.常见的元素隐藏方式？</h3><p>-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</p><p>-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</p><p>-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</p><p>-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</p><p>-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</p><p>-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p><p>-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</p><p>详细资料可以参考：<br><a href="https://juejin.im/post/584b645a128fe10058a0d625#heading-2" target="_blank" rel="noopener external nofollow noreferrer">《CSS 隐藏元素的八种方法》</a></p><h3 id="99-css-实现上下固定中间自适应布局？"><a href="#99-css-实现上下固定中间自适应布局？" class="headerlink" title="99.css 实现上下固定中间自适应布局？"></a>99.css 实现上下固定中间自适应布局？</h3><pre><code class="css">利用绝对定位实现body &#123;  padding: 0;  margin: 0;&#125;.header &#123;  position: absolute;  top: 0;  width: 100%;  height: 100px;  background: red;&#125;.container &#123;  position: absolute;  top: 100px;  bottom: 100px;  width: 100%;  background: green;&#125;.footer &#123;  position: absolute;  bottom: 0;  height: 100px;  width: 100%;  background: red;&#125;利用flex布局实现html,body &#123;  height: 100%;&#125;body &#123;  display: flex;  padding: 0;  margin: 0;  flex-direction: column;&#125;.header &#123;  height: 100px;  background: red;&#125;.container &#123;  flex-grow: 1;  background: green;&#125;.footer &#123;  height: 100px;  background: red;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/30bc9751e3e8" target="_blank" rel="noopener external nofollow noreferrer">《css 实现上下固定中间自适应布局》</a></p><h3 id="100-css-两栏布局的实现？"><a href="#100-css-两栏布局的实现？" class="headerlink" title="100.css 两栏布局的实现？"></a>100.css 两栏布局的实现？</h3><p>相关资料：</p><pre><code class="css">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*//*以左边宽度固定为200px为例*//*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/.outer &#123;  height: 100px;&#125;.left &#123;  float: left;  height: 100px;  width: 200px;  background: tomato;&#125;.right &#123;  margin-left: 200px;  width: auto;  height: 100px;  background: gold;&#125;/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/.outer &#123;  display: flex;  height: 100px;&#125;.left &#123;  flex-shrink: 0;  flex-grow: 0;  flex-basis: 200px;  background: tomato;&#125;.right &#123;  flex: auto;  /*11auto*/  background: gold;&#125;/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。*/.outer &#123;  position: relative;  height: 100px;&#125;.left &#123;  position: absolute;  width: 200px;  height: 100px;  background: tomato;&#125;.right &#123;  margin-left: 200px;  height: 100px;  background: gold;&#125;/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/.outer &#123;  position: relative;  height: 100px;&#125;.left &#123;  width: 200px;  height: 100px;  background: tomato;&#125;.right &#123;  position: absolute;  top: 0;  right: 0;  bottom: 0;  left: 200px;  background: gold;&#125;</code></pre><p><a href="http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html" target="_blank" rel="noopener external nofollow noreferrer">《两栏布局 demo 展示》</a></p><p>回答：</p><p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为 200px 为例</p><p>-（1）利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</p><p>-（2）第二种是利用 flex 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。</p><p>-（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</p><p>-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p><h3 id="101-css-三栏布局的实现？"><a href="#101-css-三栏布局的实现？" class="headerlink" title="101.css 三栏布局的实现？"></a>101.css 三栏布局的实现？</h3><p>相关资料：</p><pre><code class="css">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。*//*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/.outer &#123;  position: relative;  height: 100px;&#125;.left &#123;  position: absolute;  width: 100px;  height: 100px;  background: tomato;&#125;.right &#123;  position: absolute;  top: 0;  right: 0;  width: 200px;  height: 100px;  background: gold;&#125;.center &#123;  margin-left: 100px;  margin-right: 200px;  height: 100px;  background: lightgreen;&#125;/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/.outer &#123;  display: flex;  height: 100px;&#125;.left &#123;  flex: 00100px;  background: tomato;&#125;.right &#123;  flex: 00200px;  background: gold;&#125;.center &#123;  flex: auto;  background: lightgreen;&#125;/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/.outer &#123;  height: 100px;&#125;.left &#123;  float: left;  width: 100px;  height: 100px;  background: tomato;&#125;.right &#123;  float: right;  width: 200px;  height: 100px;  background: gold;&#125;.center &#123;  height: 100px;  margin-left: 100px;  margin-right: 200px;  background: lightgreen;&#125;/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/.outer &#123;  height: 100px;  padding-left: 100px;  padding-right: 200px;&#125;.left &#123;  position: relative;  left: -100px;  float: left;  margin-left: -100%;  width: 100px;  height: 100px;  background: tomato;&#125;.right &#123;  position: relative;  left: 200px;  float: right;  margin-left: -200px;  width: 200px;  height: 100px;  background: gold;&#125;.center &#123;  float: left;  width: 100%;  height: 100px;  background: lightgreen;&#125;/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/.outer &#123;  height: 100px;&#125;.left &#123;  float: left;  margin-left: -100%;  width: 100px;  height: 100px;  background: tomato;&#125;.right &#123;  float: left;  margin-left: -200px;  width: 200px;  height: 100px;  background: gold;&#125;.wrapper &#123;  float: left;  width: 100%;  height: 100px;  background: lightgreen;&#125;.center &#123;  margin-left: 100px;  margin-right: 200px;  height: 100px;&#125;</code></pre><p><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html" target="_blank" rel="noopener external nofollow noreferrer">《三栏布局 demo 展示》</a></p><p>回答：</p><pre><code>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。这里以左边宽度固定为100px，右边宽度固定为200px为例。（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</code></pre><h3 id="102-实现一个宽高自适应的正方形"><a href="#102-实现一个宽高自适应的正方形" class="headerlink" title="102.实现一个宽高自适应的正方形"></a>102.实现一个宽高自适应的正方形</h3><pre><code class="css">/*1.第一种方式是利用vw来实现*/.square &#123;  width: 10%;  height: 10vw;  background: tomato;&#125;/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/.square &#123;  width: 20%;  height: 0;  padding-top: 20%;  background: orange;&#125;/*3.第三种方式是利用子元素的margin-top的值来实现的*/.square &#123;  width: 30%;  overflow: hidden;  background: yellow;&#125;.square::after &#123;  content: &quot;&quot;;  display: block;  margin-top: 100%;&#125;</code></pre><p><a href="http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html" target="_blank" rel="noopener external nofollow noreferrer">《自适应正方形 demo 展示》</a></p><h3 id="103-实现一个三角形"><a href="#103-实现一个三角形" class="headerlink" title="103.实现一个三角形"></a>103.实现一个三角形</h3><pre><code class="css">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/.triangle &#123;  width: 0;  height: 0;  border-width: 100px;  border-style: solid;  border-color: tomatotransparenttransparenttransparent;&#125;</code></pre><p><a href="http://cavszhouyou.top/Demo-Display/Triangle/index.html" target="_blank" rel="noopener external nofollow noreferrer">《三角形 demo 展示》</a></p><h3 id="104-一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#104-一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="104.一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</h3><pre><code class="css">/*实现原理参考自适应正方形和水平居中方式*/.box &#123;  position: absolute;  top: 0;  right: 0;  left: 0;  bottom: 0;  margin: auto;  width: 10%;  height: 0;  padding-top: 20%;  background: tomato;&#125;</code></pre><h3 id="105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？"><a href="#105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？" class="headerlink" title="105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？"></a>105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</h3><pre><code>公式：当前元素某CSS属性值 = 基准 * 对应的百分比元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）元素的 border-width，不支持百分比元素的 text-indent，基准为包含块的 width元素的 border-radius，基准为分别为自身的height、width元素的 background-size，基准为分别为自身的height、width元素的 translateX、translateY，基准为分别为自身的height、width元素的 line-height，基准为自身的 font-size元素的 font-size，基准为父元素字体</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/JavaScript/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/JavaScript/</url>
      
        <content type="html"><![CDATA[<h3 id="1-介绍-js-的基本数据类型。"><a href="#1-介绍-js-的基本数据类型。" class="headerlink" title="1. 介绍 js 的基本数据类型。"></a>1. 介绍 js 的基本数据类型。</h3><pre><code>js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</code></pre><h3 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><pre><code>两种类型的区别是：存储位置不同。原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</code></pre><p>回答：</p><pre><code>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。基本数据类型....（参考1）复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/lxcao/article/details/52749421" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 有几种类型的值？》</a><br><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p><h3 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h3><pre><code>堆和栈的概念存在于数据结构中和操作系统内存中。在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19729973" target="_blank" rel="noopener external nofollow noreferrer">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p><h3 id="4-内部属性-Class-是什么？"><a href="#4-内部属性-Class-是什么？" class="headerlink" title="4. 内部属性 Class 是什么？"></a>4. 内部属性 Class 是什么？</h3><pre><code>所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：Object.prototype.toString.call( [1,2,3] );// &quot;[object Array]&quot;Object.prototype.toString.call( /regex-literal/i );// &quot;[object RegExp]&quot;// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签// 默认情况类的[[Class]]返回[object Object]class Class1 &#123;&#125;Object.prototype.toString.call(new Class1()); // &quot;[object Object]&quot;// 需要定制[[Class]]class Class2 &#123;  get [Symbol.toStringTag]() &#123;    return &quot;Class2&quot;;  &#125;&#125;Object.prototype.toString.call(new Class2()); // &quot;[object Class2]&quot;</code></pre><h3 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h3><p>涉及知识点：</p><pre><code>全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。标准内置对象的分类（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等（10）控制抽象对象例如 Promise、Generator 等（11）反射例如 Reflect、Proxy（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等（13）WebAssembly（14）其他例如 arguments</code></pre><p>回答：</p><pre><code>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener external nofollow noreferrer">《标准内置对象的分类》</a><br><a href="https://segmentfault.com/a/1190000011467723#articleHeader24" target="_blank" rel="noopener external nofollow noreferrer">《JS 所有内置对象属性和方法汇总》</a></p><h3 id="6-undefined-与-undeclared-的区别？"><a href="#6-undefined-与-undeclared-的区别？" class="headerlink" title="6. undefined 与 undeclared 的区别？"></a>6. undefined 与 undeclared 的区别？</h3><pre><code>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 &quot;undefined&quot;。</code></pre><h3 id="7-null-和-undefined-的区别？"><a href="#7-null-和-undefined-的区别？" class="headerlink" title="7. null 和 undefined 的区别？"></a>7. null 和 undefined 的区别？</h3><pre><code>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之 undefined 与 null》</a></p><h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><pre><code>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。按惯例我们用 void 0 来获得 undefined。</code></pre><h3 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h3><pre><code>在平常项目开发中，我们遵守一些这样的基本规范，比如说：（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。（2）代码中出现地址、时间等字符串时需要使用常量代替。（3）在进行比较的时候吧，尽量使用&#39;===&#39;, &#39;!==&#39;代替&#39;==&#39;, &#39;!=&#39;。（4）不要在内置对象的原型上添加方法，如 Array, Date。（5）switch 语句必须带有 default 分支。（6）for 循环必须使用大括号。（7）if 语句必须使用大括号。</code></pre><h3 id="10-JavaScript-原型，原型链？-有什么特点？"><a href="#10-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链？ 有什么特点？"></a>10. JavaScript 原型，原型链？ 有什么特点？</h3><pre><code>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。特点：JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之原型与原型链》</a></p><h3 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h3><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h3 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h3><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h3 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h3><pre><code>安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER。如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</code></pre><h3 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a>14. typeof NaN 的结果是什么？</h3><pre><code>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。typeof NaN; // &quot;number&quot;NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。</code></pre><h3 id="15-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15. isNaN 和 Number.isNaN 函数的区别？"></a>15. isNaN 和 Number.isNaN 函数的区别？</h3><pre><code>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</code></pre><h3 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h3><pre><code>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。</code></pre><h3 id="17-其他值到字符串的转换规则？"><a href="#17-其他值到字符串的转换规则？" class="headerlink" title="17. 其他值到字符串的转换规则？"></a>17. 其他值到字符串的转换规则？</h3><pre><code>规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换。（1）Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，（2）Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）    来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会    调用该方法并使用其返回值。</code></pre><h3 id="18-其他值到数字值的转换规则？"><a href="#18-其他值到数字值的转换规则？" class="headerlink" title="18. 其他值到数字值的转换规则？"></a>18. 其他值到数字值的转换规则？</h3><pre><code>有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。（1）Undefined 类型的值转换为 NaN。（2）Null 类型的值转换为 0。（3）Boolean 类型的值，true 转换为 1，false 转换为 0。（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。（5）Symbol 类型的值不能转换为数字，会报错。（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</code></pre><h3 id="19-其他值到布尔类型的值的转换规则？"><a href="#19-其他值到布尔类型的值的转换规则？" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？"></a>19. 其他值到布尔类型的值的转换规则？</h3><pre><code>ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。以下这些是假值：• undefined• null• false• +0、-0 和 NaN• &quot;&quot;假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</code></pre><h3 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><pre><code>&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</code></pre><h3 id="21-什么是假值对象？"><a href="#21-什么是假值对象？" class="headerlink" title="21. 什么是假值对象？"></a>21. 什么是假值对象？</h3><pre><code>浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。</code></pre><h3 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h3><pre><code>~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。~x 大致等同于 -(x+1)。</code></pre><h3 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h3><pre><code>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。</code></pre><h3 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><pre><code>根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</code></pre><h3 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h3><pre><code>（1） if (..) 语句中的条件判断表达式。（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。（3） while (..) 和 do..while(..) 循环中的条件判断表达式。（4） ? : 中的条件判断表达式。（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</code></pre><h3 id="26-和-amp-amp-操作符的返回值？"><a href="#26-和-amp-amp-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h3><pre><code>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</code></pre><h3 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h3><pre><code>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。</code></pre><h3 id="28-操作符的强制类型转换规则？"><a href="#28-操作符的强制类型转换规则？" class="headerlink" title="28. == 操作符的强制类型转换规则？"></a>28. == 操作符的强制类型转换规则？</h3><pre><code>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。（3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。（5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</code></pre><p>详细资料可以参考：<br><a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 字符串间的比较》</a></p><h3 id="29-如何将字符串转化为数字，例如-39-12-3b-39"><a href="#29-如何将字符串转化为数字，例如-39-12-3b-39" class="headerlink" title="29. 如何将字符串转化为数字，例如 &#39;12.3b&#39;?"></a>29. 如何将字符串转化为数字，例如 &#39;12.3b&#39;?</h3><pre><code>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。（4）使用 + 操作符的隐式转换。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/m0_38099607/article/details/72638678" target="_blank" rel="noopener external nofollow noreferrer">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p><h3 id="30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h3><pre><code class="js">// 方法一function format(number) &#123;  return number &amp;&amp; number.replace(/(?!^)(?=(\d&#123;3&#125;)+\.)/g, &quot;,&quot;);&#125;// 方法二function format1(number) &#123;  return Intl.NumberFormat().format(number);&#125;// 方法三function format2(number) &#123;  return number.toLocaleString(&quot;en&quot;);&#125;</code></pre><h3 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h3><pre><code class="js">// （1）匹配 16 进制颜色值var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;// （2）匹配日期，如 yyyy-mm-dd 格式var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;// （3）匹配 qq 号var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;// （4）手机号码正则var regex = /^1[34578]\d&#123;9&#125;$/g;// （5）用户名正则var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/;</code></pre><p>详细资料可以参考：<br><a href="http://caibaojian.com/form-regexp.html" target="_blank" rel="noopener external nofollow noreferrer">《前端表单验证常用的 15 个 JS 正则表达式》</a><br><a href="https://www.jianshu.com/p/1cb5229325a7" target="_blank" rel="noopener external nofollow noreferrer">《JS 常用正则汇总》</a></p><h3 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h3><p><a href="http://www.hangge.com/blog/cache/detail_1872.html" target="_blank" rel="noopener external nofollow noreferrer">《JS - 生成随机数的方法汇总（不同范围、类型的随机数）》</a></p><h3 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h3><pre><code class="js">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。function randomSort(a, b) &#123;  return Math.random() &gt; 0.5 ? -1 : 1;&#125;//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。// （2）随机从原数组抽取一个元素，加入到新数组function randomSort(arr) &#123;  var result = [];  while (arr.length &gt; 0) &#123;    var randomIndex = Math.floor(Math.random() * arr.length);    result.push(arr[randomIndex]);    arr.splice(randomIndex, 1);  &#125;  return result;&#125;// （3）随机交换数组内的元素（洗牌算法类似）function randomSort(arr) &#123;  var index,    randomIndex,    temp,    len = arr.length;  for (index = 0; index &lt; len; index++) &#123;    randomIndex = Math.floor(Math.random() * (len - index)) + index;    temp = arr[index];    arr[index] = arr[randomIndex];    arr[randomIndex] = temp;  &#125;  return arr;&#125;// es6function randomSort(array) &#123;  let length = array.length;  if (!Array.isArray(array) || length &lt;= 1) return;  for (let index = 0; index &lt; length - 1; index++) &#123;    let randomIndex = Math.floor(Math.random() * (length - index)) + index;    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];  &#125;  return array;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top" target="_blank" rel="noopener external nofollow noreferrer">《Fisher and Yates 的原始版》</a><br><a href="https://www.zhihu.com/question/32303195" target="_blank" rel="noopener external nofollow noreferrer">《javascript 实现数组随机排序?》</a><br><a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 学习笔记：数组随机排序》</a></p><h3 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h3><pre><code>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。嗯我目前了解到的就是这么几种方式。</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之对象创建》</a></p><h3 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h3><pre><code>我了解的 js 中实现继承的几种方式有：（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之继承》</a></p><h3 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h3><pre><code class="js">function Person(name) &#123;  this.name = name;&#125;Person.prototype.sayName = function () &#123;  console.log(&quot;My name is &quot; + this.name + &quot;.&quot;);&#125;;function Student(name, grade) &#123;  Person.call(this, name);  this.grade = grade;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.sayMyGrade = function () &#123;  console.log(&quot;My grade is &quot; + this.grade + &quot;.&quot;);&#125;;</code></pre><h3 id="37-Javascript-的作用域链？"><a href="#37-Javascript-的作用域链？" class="headerlink" title="37. Javascript 的作用域链？"></a>37. Javascript 的作用域链？</h3><pre><code>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。作用域链的创建过程跟执行上下文的建立有关....</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之作用域链》</a></p><h3 id="38-谈谈-This-对象的理解。"><a href="#38-谈谈-This-对象的理解。" class="headerlink" title="38. 谈谈 This 对象的理解。"></a>38. 谈谈 This 对象的理解。</h3><pre><code>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</code></pre><ul><li><p>1.第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</p></li><li><p>2.第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p></li><li><p>3.第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p></li><li><p>4.第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</p></li></ul><pre><code>这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</code></pre><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之 this 详解》</a></p><h3 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h3><pre><code>它的功能是把对应的字符串解析成 JS 代码并运行。应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener external nofollow noreferrer">《eval()》</a></p><h3 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h3><pre><code>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/33453164" target="_blank" rel="noopener external nofollow noreferrer">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp" target="_blank" rel="noopener external nofollow noreferrer">《Window 对象》</a><br><a href="https://www.zhihu.com/question/20724662" target="_blank" rel="noopener external nofollow noreferrer">《DOM 与 BOM 分别是什么，有何关联？》</a><br><a href="https://segmentfault.com/a/1190000000654274#articleHeader21" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p><h3 id="41-写一个通用的事件侦听器函数。"><a href="#41-写一个通用的事件侦听器函数。" class="headerlink" title="41. 写一个通用的事件侦听器函数。"></a>41. 写一个通用的事件侦听器函数。</h3><pre><code class="js">const EventUtils = &#123;  // 视能力分别使用dom0||dom2||IE方式 来绑定事件  // 添加事件  addEvent: function (element, type, handler) &#123;    if (element.addEventListener) &#123;      element.addEventListener(type, handler, false);    &#125; else if (element.attachEvent) &#123;      element.attachEvent(&quot;on&quot; + type, handler);    &#125; else &#123;      element[&quot;on&quot; + type] = handler;    &#125;  &#125;,  // 移除事件  removeEvent: function (element, type, handler) &#123;    if (element.removeEventListener) &#123;      element.removeEventListener(type, handler, false);    &#125; else if (element.detachEvent) &#123;      element.detachEvent(&quot;on&quot; + type, handler);    &#125; else &#123;      element[&quot;on&quot; + type] = null;    &#125;  &#125;,  // 获取事件目标  getTarget: function (event) &#123;    return event.target || event.srcElement;  &#125;,  // 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event  getEvent: function (event) &#123;    return event || window.event;  &#125;,  // 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）  stopPropagation: function (event) &#123;    if (event.stopPropagation) &#123;      event.stopPropagation();    &#125; else &#123;      event.cancelBubble = true;    &#125;  &#125;,  // 取消事件的默认行为  preventDefault: function (event) &#123;    if (event.preventDefault) &#123;      event.preventDefault();    &#125; else &#123;      event.returnValue = false;    &#125;  &#125;&#125;;</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader6" target="_blank" rel="noopener external nofollow noreferrer">《JS 事件模型》</a></p><h3 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><ul><li><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p></li><li><p>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p></li><li><p>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html" target="_blank" rel="noopener external nofollow noreferrer">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493" target="_blank" rel="noopener external nofollow noreferrer">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h3 id="43-三种事件模型是什么？"><a href="#43-三种事件模型是什么？" class="headerlink" title="43. 三种事件模型是什么？"></a>43. 三种事件模型是什么？</h3><pre><code>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/u013217071/article/details/77613706" target="_blank" rel="noopener external nofollow noreferrer">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h3 id="44-事件委托是什么？"><a href="#44-事件委托是什么？" class="headerlink" title="44. 事件委托是什么？"></a>44. 事件委托是什么？</h3><pre><code>事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</code></pre><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/26536815" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 事件委托详解》</a></p><h3 id="45-quot-1-quot-quot-2-quot-quot-3-quot-map-parseInt-答案是多少？"><a href="#45-quot-1-quot-quot-2-quot-quot-3-quot-map-parseInt-答案是多少？" class="headerlink" title="45. [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少？"></a>45. [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少？</h3><pre><code>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 &quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/justjavac/article/details/19473199" target="_blank" rel="noopener external nofollow noreferrer">《为什么 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h3 id="46-什么是闭包，为什么要用它？"><a href="#46-什么是闭包，为什么要用它？" class="headerlink" title="46. 什么是闭包，为什么要用它？"></a>46. 什么是闭包，为什么要用它？</h3><pre><code>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。闭包有两个常用的用途。闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之闭包》</a></p><h3 id="47-javascript-代码中的-quot-use-strict-quot-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-quot-use-strict-quot-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 &quot;use strict&quot;; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 &quot;use strict&quot;; 是什么意思 ? 使用它区别是什么？</h3><p>相关知识点：</p><pre><code>use strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立&quot;严格模式&quot;的目的，主要有以下几个：</code></pre><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>1.禁止使用 with 语句。</li><li>2.禁止 this 关键字指向全局对象。</li><li>3.对象不能有重名的属性。</li></ul><p>回答：</p><pre><code>use strict 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="noopener external nofollow noreferrer">《Javascript 严格模式详解》</a></p><h3 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h3><pre><code>第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/haitunmin/article/details/78418522" target="_blank" rel="noopener external nofollow noreferrer">《js 判断一个对象是否属于某一类》</a></p><h3 id="49-instanceof-的作用？"><a href="#49-instanceof-的作用？" class="headerlink" title="49. instanceof 的作用？"></a>49. instanceof 的作用？</h3><pre><code class="js">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。// 实现：function myInstanceof(left, right) &#123;  let proto = Object.getPrototypeOf(left), // 获取对象的原型    prototype = right.prototype; // 获取构造函数的 prototype 对象  // 判断构造函数的 prototype 对象是否在对象的原型链上  while (true) &#123;    if (!proto) return false;    if (proto === prototype) return true;    proto = Object.getPrototypeOf(proto);  &#125;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener external nofollow noreferrer">《instanceof》</a></p><h3 id="50-new-操作符具体干了什么呢？如何实现？"><a href="#50-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50. new 操作符具体干了什么呢？如何实现？"></a>50. new 操作符具体干了什么呢？如何实现？</h3><pre><code class="js">// （1）首先创建了一个新的空对象// （2）设置原型，将对象的原型设置为函数的 prototype 对象。// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。// 实现:function objectFactory() &#123;  let newObject = null,    constructor = Array.prototype.shift.call(arguments),    result = null;  // 参数判断  if (typeof constructor !== &quot;function&quot;) &#123;    console.error(&quot;type error&quot;);    return;  &#125;  // 新建一个空对象，对象的原型为构造函数的 prototype 对象  newObject = Object.create(constructor.prototype);  // 将 this 指向新建对象，并执行函数  result = constructor.apply(newObject, arguments);  // 判断返回对象  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);  // 判断返回结果  return flag ? result : newObject;&#125;// 使用方法// objectFactory(构造函数, 初始化参数);</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000008576048" target="_blank" rel="noopener external nofollow noreferrer">《new 操作符具体干了什么？》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入之 new 的模拟实现》</a></p><h3 id="51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</h3><pre><code>hasOwnProperty所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener external nofollow noreferrer">《Object.prototype.hasOwnProperty()》</a></p><h3 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h3><p>相关知识点：</p><pre><code>JSON 是一种数据交换格式，基于文本，优于轻量，用于交换数据。JSON 可以表示数字、布尔值、字符串、null、数组（值的有序序列），以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</code></pre><p>回答：</p><pre><code>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，我们使用 JSON 作为前后端数据交换的方式。在前端我们通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是我们应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，一个是 JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 JSON 格式的字符串。另一个函数 JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当我们从后端接收到 JSON 格式的字符串时，我们可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</code></pre><p>详细资料可以参考：<br><a href="https://my.oschina.net/u/3284240/blog/874368" target="_blank" rel="noopener external nofollow noreferrer">《深入了解 JavaScript 中的 JSON 》</a></p><h3 id="53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#53-forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="53. [].forEach.call($$(&quot;&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. [].forEach.call($$(&quot;<em>&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</h3><pre><code>（1）选取页面所有 DOM 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。（2）循环遍历 DOM 元素（3）给元素添加 outline 。由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。（4）生成随机颜色函数。Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</code></pre><p>详细资料可以参考：<br><a href="https://2008winstar.iteye.com/blog/2128290" target="_blank" rel="noopener external nofollow noreferrer">《通过一行代码学 JavaScript》</a></p><h3 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a>54. js 延迟加载的方式有哪些？</h3><p>相关知识点：</p><pre><code>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</code></pre><p>一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p>回答：</p><pre><code>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。我了解到的几种方式是：第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/meijory/article/details/76389762" target="_blank" rel="noopener external nofollow noreferrer">《JS 延迟加载的几种方式》</a><br><a href="http://www.w3school.com.cn/html5/att_script_async.asp" target="_blank" rel="noopener external nofollow noreferrer">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h3 id="55-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55. Ajax 是什么? 如何创建一个 Ajax？"></a>55. Ajax 是什么? 如何创建一个 Ajax？</h3><p>相关知识点：</p><p>2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的<br>异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>3.设置响应 HTTP 请求状态变化的函数</li><li>4.发送 HTTP 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 JavaScript 和 DOM 实现局部刷新</li></ul><p>一般实现：</p><pre><code class="js">const SERVER_URL = &quot;/server&quot;;let xhr = new XMLHttpRequest();// 创建 Http 请求xhr.open(&quot;GET&quot;, SERVER_URL, true);// 设置状态监听函数xhr.onreadystatechange = function () &#123;  if (this.readyState !== 4) return;  // 当请求成功时  if (this.status === 200) &#123;    handle(this.response);  &#125; else &#123;    console.error(this.statusText);  &#125;&#125;;// 设置请求失败时的监听函数xhr.onerror = function () &#123;  console.error(this.statusText);&#125;;// 设置请求头信息xhr.responseType = &quot;json&quot;;xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);// 发送 Http 请求xhr.send(null);// promise 封装实现：function getJSON(url) &#123;  // 创建一个 promise 对象  let promise = new Promise(function (resolve, reject) &#123;    let xhr = new XMLHttpRequest();    // 新建一个 http 请求    xhr.open(&quot;GET&quot;, url, true);    // 设置状态的监听函数    xhr.onreadystatechange = function () &#123;      if (this.readyState !== 4) return;      // 当请求成功或失败时，改变 promise 的状态      if (this.status === 200) &#123;        resolve(this.response);      &#125; else &#123;        reject(new Error(this.statusText));      &#125;    &#125;;    // 设置错误监听函数    xhr.onerror = function () &#123;      reject(new Error(this.statusText));    &#125;;    // 设置响应的数据类型    xhr.responseType = &quot;json&quot;;    // 设置请求头信息    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);    // 发送 http 请求    xhr.send(null);  &#125;);  return promise;&#125;</code></pre><p>回答：</p><pre><code>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。创建一个 ajax 有这样几个步骤首先是创建一个 XMLHttpRequest 对象。然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</code></pre><p>详细资料可以参考：<br><a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html" target="_blank" rel="noopener external nofollow noreferrer">《XMLHttpRequest 对象》</a><br><a href="https://juejin.im/post/5acde23c5188255cb32e7e76" target="_blank" rel="noopener external nofollow noreferrer">《从 ajax 到 fetch、axios》</a><br><a href="https://juejin.im/post/5c160937f265da61180199b2" target="_blank" rel="noopener external nofollow noreferrer">《Fetch 入门》</a><br><a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener external nofollow noreferrer">《传统 Ajax 已死，Fetch 永生》</a></p><h3 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h3><pre><code>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 web 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 no-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000012573337" target="_blank" rel="noopener external nofollow noreferrer">《浅谈浏览器缓存》</a><br><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3" target="_blank" rel="noopener external nofollow noreferrer">《前端优化：浏览器缓存技术介绍》</a><br><a href="https://www.web-tinker.com/article/21221.html" target="_blank" rel="noopener external nofollow noreferrer">《请求头中的 Cache-Control》</a><br><a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08" target="_blank" rel="noopener external nofollow noreferrer">《Cache-Control 字段值详解》</a></p><h3 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h3><ul><li><p>1.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。</p></li><li><p>2.在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。</p></li><li><p>3.在 URL 后面加上一个随机数： &quot;fresh=&quot; + Math.random();。</p></li><li><p>4.在 URL 后面加上时间戳：&quot;nowtime=&quot; + new Date().getTime();。</p></li><li><p>5.如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。</p></li></ul><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html" target="_blank" rel="noopener external nofollow noreferrer">《Ajax 中浏览器的缓存问题解决方法》</a><br><a href="https://segmentfault.com/a/1190000012573337" target="_blank" rel="noopener external nofollow noreferrer">《浅谈浏览器缓存》</a></p><h3 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h3><p>相关知识点：</p><pre><code>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </code></pre><p>回答：</p><pre><code>同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/tennysonsky/article/details/45111623" target="_blank" rel="noopener external nofollow noreferrer">《同步和异步的区别》</a></p><h3 id="59-什么是浏览器的同源政策？"><a href="#59-什么是浏览器的同源政策？" class="headerlink" title="59. 什么是浏览器的同源政策？"></a>59. 什么是浏览器的同源政策？</h3><pre><code>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。同源政策主要限制了三个方面第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。第三个是当前域下 ajax 无法发送跨域请求。同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</code></pre><h3 id="60-如何解决跨域问题？"><a href="#60-如何解决跨域问题？" class="headerlink" title="60. 如何解决跨域问题？"></a>60. 如何解决跨域问题？</h3><p>相关知识点：</p><ul><li><ol><li>通过 jsonp 跨域</li></ol></li><li><ol start="2"><li>document.domain + iframe 跨域</li></ol></li><li><ol start="3"><li>location.hash + iframe</li></ol></li><li><ol start="4"><li>window.name + iframe 跨域</li></ol></li><li><ol start="5"><li>postMessage 跨域</li></ol></li><li><ol start="6"><li>跨域资源共享（CORS)</li></ol></li><li><ol start="7"><li>nginx 代理跨域</li></ol></li><li><ol start="8"><li>nodejs 中间件代理跨域</li></ol></li><li><ol start="9"><li>WebSocket 协议跨域</li></ol></li></ul><p>回答：</p><pre><code>解决跨域的方法我们可以根据我们想要实现的目的来划分。首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 document.domain 来解决。（1）将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe 的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者 postMessage 来解决。（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。（4）使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。（5）使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script  标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get 请求。（6）使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。（7）使用 websocket 协议，这个协议没有同源限制。（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener external nofollow noreferrer">《前端常见跨域解决方案（全）》</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener external nofollow noreferrer">《浏览器同源政策及其规避方法》</a><br><a href="https://juejin.im/entry/59feae9df265da43094488f6" target="_blank" rel="noopener external nofollow noreferrer">《跨域，你需要知道的全在这里》</a><br><a href="https://www.zhihu.com/question/31592553" target="_blank" rel="noopener external nofollow noreferrer">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p><h3 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h3><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/5eab0f83e3b4" target="_blank" rel="noopener external nofollow noreferrer">《深入浅出 Nginx》</a></p><h3 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h3><pre><code>我的理解是 cookie 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 cookie 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。cookie 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener external nofollow noreferrer">《HTTP cookies》 </a><br><a href="https://segmentfault.com/a/1190000004556040" target="_blank" rel="noopener external nofollow noreferrer">《聊一聊 cookie》 </a></p><h3 id="63-模块化开发怎么做？"><a href="#63-模块化开发怎么做？" class="headerlink" title="63. 模块化开发怎么做？"></a>63. 模块化开发怎么做？</h3><pre><code>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f" target="_blank" rel="noopener external nofollow noreferrer">《浅谈模块化开发》</a><br><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener external nofollow noreferrer">《Javascript 模块化编程（一）：模块的写法》</a><br><a href="https://juejin.im/post/5aaa37c8f265da23945f365c" target="_blank" rel="noopener external nofollow noreferrer">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener external nofollow noreferrer">《Module 的语法》</a></p><h3 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h3><pre><code>js 中现在比较成熟的有四种模块加载方案。第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考60第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 61。</code></pre><h3 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h3><p>它们之间的主要区别有两个方面。</p><p>（1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇<br>就近依赖，只有在用到某个模块的时候再去 require。</p><p>（2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于<br>模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD<br>在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句<br>的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p><pre><code class="js">// CMDdefine(function (require, exports, module) &#123;  var a = require(&quot;./a&quot;);  a.doSomething();  // 此处略去 100 行  var b = require(&quot;./b&quot;); // 依赖可以就近书写  b.doSomething();  // ...&#125;);// AMD 默认推荐define([&quot;./a&quot;, &quot;./b&quot;], function (a, b) &#123;  // 依赖必须一开始就写好  a.doSomething();  // 此处略去 100 行  b.doSomething();  // ...&#125;);</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a422b036fb9a045211ef789" target="_blank" rel="noopener external nofollow noreferrer">《前端模块化，AMD 与 CMD 的区别》</a></p><h3 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h3><ul><li><p>1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p></li><li><p>2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ul><h3 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h3><pre><code>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</code></pre><p>详细资料可以参考：<br><a href="https://github.com/HRFE/blog/issues/10" target="_blank" rel="noopener external nofollow noreferrer">《requireJS 的用法和原理分析》</a><br><a href="https://zhuanlan.zhihu.com/p/55039478" target="_blank" rel="noopener external nofollow noreferrer">《requireJS 的核心原理是什么？》</a><br><a href="https://www.cnblogs.com/dong-xu/p/7160919.html" target="_blank" rel="noopener external nofollow noreferrer">《从 RequireJs 源码剖析脚本加载原理》</a><br><a href="https://www.jianshu.com/p/5a39535909e4" target="_blank" rel="noopener external nofollow noreferrer">《requireJS 原理分析》</a></p><h3 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h3><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21157540" target="_blank" rel="noopener external nofollow noreferrer">《JS 模块加载器加载原理是怎么样的？》</a></p><h3 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h3><pre><code>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。在 class 中添加的方法，其实是添加在类的原型上的。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/29789315" target="_blank" rel="noopener external nofollow noreferrer">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener external nofollow noreferrer">《Class 的基本语法》</a></p><h3 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h3><pre><code>document.write 的内容会代替整个文档内容，会重写整个页面。innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</code></pre><p>详细资料可以参考：<br><a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50" target="_blank" rel="noopener external nofollow noreferrer">《简述 document.write 和 innerHTML 的区别。》</a></p><h3 id="71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h3><p>（1）创建新节点</p><pre><code class="js">createDocumentFragment(node);createElement(node);createTextNode(text);</code></pre><p>（2）添加、移除、替换、插入</p><pre><code class="js">appendChild(node)removeChild(node)replaceChild(new,old)insertBefore(new,old)</code></pre><p>（3）查找</p><pre><code class="js">getElementById();getElementsByName();getElementsByTagName();getElementsByClassName();querySelector();querySelectorAll();</code></pre><p>（4）属性操作</p><pre><code class="js">getAttribute(key);setAttribute(key, value);hasAttribute(key);removeAttribute(key);</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces" target="_blank" rel="noopener external nofollow noreferrer">《DOM 概述》</a><br><a href="https://harttle.land/2015/10/01/javascript-dom-api.html" target="_blank" rel="noopener external nofollow noreferrer">《原生 JavaScript 的 DOM 操作汇总》</a><br><a href="https://microzz.com/2017/04/06/jsdom/" target="_blank" rel="noopener external nofollow noreferrer">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h3 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h3><pre><code>对于这样一个 HTML 元素：&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;。innerHTML：内部 HTML，content&lt;br/&gt;；outerHTML：外部 HTML，&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;；innerText：内部文本，content ；outerText：内部文本，content ；</code></pre><h3 id="73-call-和-apply-的区别？"><a href="#73-call-和-apply-的区别？" class="headerlink" title="73. .call() 和 .apply() 的区别？"></a>73. .call() 和 .apply() 的区别？</h3><pre><code>它们的作用一模一样，区别仅在于传入参数的形式的不同。apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae" target="_blank" rel="noopener external nofollow noreferrer">《apply、call 的区别和用途》</a></p><h3 id="74-JavaScript-类数组对象的定义？"><a href="#74-JavaScript-类数组对象的定义？" class="headerlink" title="74. JavaScript 类数组对象的定义？"></a>74. JavaScript 类数组对象的定义？</h3><pre><code>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</code></pre><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><pre><code class="js">Array.prototype.slice.call(arrayLike);</code></pre><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><pre><code class="js">Array.prototype.splice.call(arrayLike, 0);</code></pre><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><pre><code class="js">Array.prototype.concat.apply([], arrayLike);</code></pre><p>（4）通过 Array.from 方法来实现转换</p><pre><code class="js">Array.from(arrayLike);</code></pre><p>详细的资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入之类数组对象与 arguments》</a><br><a href="https://segmentfault.com/a/1190000000415572" target="_blank" rel="noopener external nofollow noreferrer">《javascript 类数组》</a><br><a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/" target="_blank" rel="noopener external nofollow noreferrer">《深入理解 JavaScript 类数组》</a></p><h3 id="75-数组和对象有哪些原生方法，列举一下？"><a href="#75-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75. 数组和对象有哪些原生方法，列举一下？"></a>75. 数组和对象有哪些原生方法，列举一下？</h3><pre><code>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法数组归并方法 reduce() 和 reduceRight() 方法</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之 Array 类型详解》</a></p><h3 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h3><pre><code>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。fill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill" target="_blank" rel="noopener external nofollow noreferrer">《Array.prototype.fill()》</a></p><h3 id="77-的长度？"><a href="#77-的长度？" class="headerlink" title="77. [,,,] 的长度？"></a>77. [,,,] 的长度？</h3><pre><code>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数量。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas" target="_blank" rel="noopener external nofollow noreferrer">《尾后逗号》</a></p><h3 id="78-JavaScript-中的作用域与变量声明提升？"><a href="#78-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78. JavaScript 中的作用域与变量声明提升？"></a>78. JavaScript 中的作用域与变量声明提升？</h3><pre><code>变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</code></pre><p>详细资料可以参考：<br><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入理解之变量对象》</a></p><h3 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h3><ul><li>1.使用位运算代替一些简单的四则运算。</li><li>2.避免使用过深的嵌套循环。</li><li>3.不要使用未定义的变量。</li><li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul><p>详细资料可以参考：<br><a href="https://zhuanlan.zhihu.com/p/34780474" target="_blank" rel="noopener external nofollow noreferrer">《如何编写高性能的 Javascript？》</a></p><h3 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h3><pre><code>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。（2）如果对象不存活，则释放对象的空间。（3）最后将 From 空间和 To 空间角色进行交换。新生代对象晋升到老生代有两个条件：（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/b8ed21e8a4fb" target="_blank" rel="noopener external nofollow noreferrer">《深入理解 V8 的垃圾回收原理》</a><br><a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 中的垃圾回收》</a></p><h3 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h3><p>相关知识点：</p><ul><li>1.意外的全局变量</li><li>2.被遗忘的计时器或回调函数</li><li>3.脱离 DOM 的引用</li><li>4.闭包</li></ul><p>回答：</p><pre><code>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 内存泄漏教程》</a><br><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" target="_blank" rel="noopener external nofollow noreferrer">《4 类 JavaScript 内存泄漏及如何避免》</a><br><a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706" target="_blank" rel="noopener external nofollow noreferrer">《杜绝 js 中四种内存泄漏类型的发生》</a><br><a href="https://segmentfault.com/a/1190000008901861" target="_blank" rel="noopener external nofollow noreferrer">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h3 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h3><pre><code>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</code></pre><p>详细资料可以参考：<br><a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad" target="_blank" rel="noopener external nofollow noreferrer">《pushState + ajax 实现浏览器无刷新前进后退》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API" target="_blank" rel="noopener external nofollow noreferrer">《Manipulating the browser history》</a></p><h3 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h3><pre><code>this === window ? &#39;browser&#39; : &#39;node&#39;;通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。</code></pre><h3 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h3><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20027966" target="_blank" rel="noopener external nofollow noreferrer">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br><a href="https://zhuanlan.zhihu.com/p/30558018" target="_blank" rel="noopener external nofollow noreferrer">《从 Chrome 源码看浏览器如何加载资源》</a></p><h3 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h3><pre><code>移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</code></pre><p>有三种办法来解决这个问题：</p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><pre><code>click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0" target="_blank" rel="noopener external nofollow noreferrer">《移动端 300ms 点击延迟和点击穿透》</a></p><h3 id="86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h3><pre><code>（1）什么是前端路由？前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。（2）什么时候使用前端路由？在单页面应用，大部分页面结构不变，只改变部分内容的使用（3）前端路由有什么优点和缺点？优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/q/1010000005336260" target="_blank" rel="noopener external nofollow noreferrer">《什么是“前端路由”》</a><br><a href="https://github.com/kaola-fed/blog/issues/137" target="_blank" rel="noopener external nofollow noreferrer">《浅谈前端路由》 </a><br><a href="https://www.zhihu.com/question/53064386" target="_blank" rel="noopener external nofollow noreferrer">《前端路由是什么东西？》</a></p><h3 id="87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h3><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b2da89cf265da597f1c7cab" target="_blank" rel="noopener external nofollow noreferrer">《浅谈前端单元测试》</a></p><h3 id="88-检测浏览器版本版本有哪些方式？"><a href="#88-检测浏览器版本版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本版本有哪些方式？"></a>88. 检测浏览器版本版本有哪些方式？</h3><pre><code>检测浏览器版本一共有两种方式：一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/d99f4ca385ac" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 判断浏览器类型》</a></p><h3 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h3><pre><code>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000002593432" target="_blank" rel="noopener external nofollow noreferrer">《Web 开发中的“黑话”》</a><br><a href="https://juejin.im/post/5a579bc7f265da3e38496ba1" target="_blank" rel="noopener external nofollow noreferrer">《Polyfill 为何物》</a></p><h3 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h3><pre><code class="js">// String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。// 对于 &#39;filename&#39; 和 &#39;.hiddenfile&#39; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。function getFileExtension(filename) &#123;  return filename.slice(((filename.lastIndexOf(&quot;.&quot;) - 1) &gt;&gt;&gt; 0) + 2);&#125;</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004993946" target="_blank" rel="noopener external nofollow noreferrer">《如何更有效的获取文件扩展名》</a></p><h3 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h3><p>相关知识点：</p><pre><code class="js">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。// 函数防抖的实现function debounce(fn, wait) &#123;  var timer = null;  return function () &#123;    var context = this,      args = arguments;    // 如果此时存在定时器的话，则取消之前的定时器重新记时    if (timer) &#123;      clearTimeout(timer);      timer = null;    &#125;    // 设置定时器，使事件间隔指定事件后执行    timer = setTimeout(() =&gt; &#123;      fn.apply(context, args);    &#125;, wait);  &#125;;&#125;// 函数节流的实现;function throttle(fn, delay) &#123;  var preTime = Date.now();  return function () &#123;    var context = this,      args = arguments,      nowTime = Date.now();    // 如果两次时间间隔超过了指定时间，则执行函数。    if (nowTime - preTime &gt;= delay) &#123;      preTime = Date.now();      return fn.apply(context, args);    &#125;  &#125;;&#125;</code></pre><p>回答：</p><pre><code>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener external nofollow noreferrer">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4" target="_blank" rel="noopener external nofollow noreferrer">《JS 的防抖与节流》</a></p><h3 id="92-Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？"></a>92. Object.is() 与原来的比较操作符 “===”、“==” 的区别？</h3><p>相关知识点：</p><pre><code>两等号判等，会在比较时进行类型转换。三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</code></pre><p>回答：</p><pre><code>使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</code></pre><h3 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h3><p>相关知识点：</p><pre><code>escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。</code></pre><p>回答：</p><pre><code>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21861899" target="_blank" rel="noopener external nofollow noreferrer">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h3 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h3><pre><code>Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</code></pre><p>详细资料可以参考：<br><a href="https://blog.51cto.com/polaris/377468" target="_blank" rel="noopener external nofollow noreferrer">《字符编码详解》</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener external nofollow noreferrer">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h3 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h3><p>相关知识点：</p><pre><code>事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</code></pre><p>回答：</p><pre><code>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5afbc62151882542af04112d" target="_blank" rel="noopener external nofollow noreferrer">《浏览器事件循环机制（event loop）》</a><br><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener external nofollow noreferrer">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener external nofollow noreferrer">《什么是 Event Loop？》</a><br><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener external nofollow noreferrer">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h3 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h3><p>相关资料：</p><pre><code class="js">// 浅拷贝的实现;function shallowCopy(object) &#123;  // 只拷贝对象  if (!object || typeof object !== &quot;object&quot;) return;  // 根据 object 的类型判断是新建一个数组还是对象  let newObject = Array.isArray(object) ? [] : &#123;&#125;;  // 遍历 object，并且判断是 object 的属性才拷贝  for (let key in object) &#123;    if (object.hasOwnProperty(key)) &#123;      newObject[key] = object[key];    &#125;  &#125;  return newObject;&#125;// 深拷贝的实现;function deepCopy(object) &#123;  if (!object || typeof object !== &quot;object&quot;) return object;  let newObject = Array.isArray(object) ? [] : &#123;&#125;;  for (let key in object) &#123;    if (object.hasOwnProperty(key)) &#123;      newObject[key] = deepCopy(object[key]);    &#125;  &#125;  return newObject;&#125;</code></pre><p>回答：</p><pre><code>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</code></pre><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 专题之深浅拷贝》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6" target="_blank" rel="noopener external nofollow noreferrer">《前端面试之道》</a></p><h3 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h3><p>相关资料：</p><pre><code class="js">// call函数实现Function.prototype.myCall = function (context) &#123;  // 判断调用对象  if (typeof this !== &quot;function&quot;) &#123;    console.error(&quot;type error&quot;);  &#125;  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;&#125;;// apply 函数实现Function.prototype.myApply = function (context) &#123;  // 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) &#123;    throw new TypeError(&quot;Error&quot;);  &#125;  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) &#123;    result = context.fn(...arguments[1]);  &#125; else &#123;    result = context.fn();  &#125;  // 将属性删除  delete context.fn;  return result;&#125;;// bind 函数实现Function.prototype.myBind = function (context) &#123;  // 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) &#123;    throw new TypeError(&quot;Error&quot;);  &#125;  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() &#123;    // 根据调用方式，传入不同绑定值    return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments));  &#125;;&#125;;</code></pre><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe" target="_blank" rel="noopener external nofollow noreferrer">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h3 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h3><pre><code class="js">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。function curry(fn, args) &#123;  // 获取函数需要的参数长度  let length = fn.length;  args = args || [];  return function () &#123;    let subArgs = args.slice(0);    // 拼接得到现有的所有参数    for (let i = 0; i &lt; arguments.length; i++) &#123;      subArgs.push(arguments[i]);    &#125;    // 判断参数的长度是否已经满足函数所需参数的长度    if (subArgs.length &gt;= length) &#123;      // 如果满足，执行函数      return fn.apply(this, subArgs);    &#125; else &#123;      // 如果不满足，递归返回科里化的函数，等待参数的传入      return curry.call(this, fn, subArgs);    &#125;  &#125;;&#125;// es6 实现function curry(fn, ...args) &#123;  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);&#125;</code></pre><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 专题之函数柯里化》</a></p><h3 id="99-为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h3><pre><code>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191" target="_blank" rel="noopener external nofollow noreferrer">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br><a href="https://blog.csdn.net/zhengyanan815/article/details/78550073" target="_blank" rel="noopener external nofollow noreferrer">《十进制浮点数转成二进制》</a><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener external nofollow noreferrer">《浮点数的二进制表示》</a><br><a href="https://juejin.im/post/5b372f106fb9a00e6714aa21" target="_blank" rel="noopener external nofollow noreferrer">《js 浮点数存储精度丢失原理》</a><br><a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624" target="_blank" rel="noopener external nofollow noreferrer">《浮点数精度之谜》</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 浮点数陷阱及解法》</a><br><a href="https://juejin.im/post/5bd2f10a51882555e072d0c4" target="_blank" rel="noopener external nofollow noreferrer">《0.1+0.2 !== 0.3？》</a><br><a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 中奇特的~运算符》</a></p><h3 id="100-原码、反码和补码的介绍"><a href="#100-原码、反码和补码的介绍" class="headerlink" title="100. 原码、反码和补码的介绍"></a>100. 原码、反码和补码的介绍</h3><pre><code>原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。正数的补码和其原码一样；负数的补码为其反码加1。例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html" target="_blank" rel="noopener external nofollow noreferrer">《关于 2 的补码》</a></p><h3 id="101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>101. toPrecision 和 toFixed 和 Math.round 的区别？</h3><pre><code>toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。toFixed 是对小数点后指定位数取整，从小数点开始数起。Math.round 是将一个数字四舍五入到一个整数。</code></pre><h3 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h3><pre><code>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。XSS 一般分为存储型、反射型和 DOM 型。存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bad9140e51d450e935c6d64" target="_blank" rel="noopener external nofollow noreferrer">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p><h3 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h3><pre><code>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;metahttp-equiv=&quot;Content-Security-Policy&quot;&gt;</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener external nofollow noreferrer">《内容安全策略（CSP）》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2" target="_blank" rel="noopener external nofollow noreferrer">《前端面试之道》</a></p><h3 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h3><pre><code>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。一般的 CSRF 攻击类型有三种：第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。CSRF 可以用下面几种方法来防护：第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc009996fb9a05d0a055192" target="_blank" rel="noopener external nofollow noreferrer">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br><a href="https://www.jianshu.com/p/1f9c71850299" target="_blank" rel="noopener external nofollow noreferrer">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p><h3 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h3><pre><code>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</code></pre><h3 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h3><pre><code>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/251704d8ff18" target="_blank" rel="noopener external nofollow noreferrer">《web 安全之--点击劫持攻击与防御技术简介》</a></p><h3 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h3><pre><code>SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bd5b820e51d456f72531fa8" target="_blank" rel="noopener external nofollow noreferrer">《Web 安全漏洞之 SQL 注入》</a><br><a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB" target="_blank" rel="noopener external nofollow noreferrer">《如何防范常见的 Web 攻击》</a></p><h3 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3><pre><code>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/593021272f301e0058273468" target="_blank" rel="noopener external nofollow noreferrer">《浅析前端开发中的 MVC/MVP/MVVM 模式》</a><br><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener external nofollow noreferrer">《MVC，MVP 和 MVVM 的图示》</a><br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf" target="_blank" rel="noopener external nofollow noreferrer">《MVVM》</a><br><a href="https://segmentfault.com/a/1190000015310674" target="_blank" rel="noopener external nofollow noreferrer">《一篇文章了解架构模式：MVC/MVP/MVVM》</a></p><h3 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h3><pre><code>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。首先我们通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。如果遇到元素节点，并且属性值包含 v-model 的话，我们就从 Model 中去获取 v-model 所对应的属性的值，并赋值给元素的 value 值。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。如果遇到了绑定的文本节点，我们使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。</code></pre><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="noopener external nofollow noreferrer">《Vue.js 双向绑定的实现原理》</a></p><h3 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h3><pre><code>Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。一个属性的描述符有四个属性，分别是 value 属性的值，writable 属性是否可写，enumerable 属性是否可枚举，configurable 属性是否可配置修改。</code></pre><p>详细资料可以参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener external nofollow noreferrer">《Object.defineProperty()》</a></p><h3 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><pre><code>有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，vue 内部通过重写函数解决了这个问题。在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 ES6 的语法。</code></pre><h3 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h3><pre><code>我对 Virtual DOM 的理解是，首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后我们将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。当页面的状态发生改变，我们需要对页面的 DOM 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf" target="_blank" rel="noopener external nofollow noreferrer">《Virtual DOM》</a><br><a href="https://github.com/y8n/blog/issues/5" target="_blank" rel="noopener external nofollow noreferrer">《理解 Virtual DOM》</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener external nofollow noreferrer">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br>[《网上都说操作真实 DOM 慢，但测试结果却比</p><p>更快，为什么？》](<a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener external nofollow noreferrer">https://www.zhihu.com/question/31809713/answer/53544875</a>)</p><h3 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h3><pre><code>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。在对列表元素进行对比的时候，由于 TagName 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样我们才能够复用老的 DOM 树上的节点。</code></pre><h3 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h3><p>详细资料可以参考：<br><a href="https://juejin.im/post/5a82f0626fb9a06358657c9c" target="_blank" rel="noopener external nofollow noreferrer">《你需要知道的 requestAnimationFrame》</a><br><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener external nofollow noreferrer">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h3 id="115-谈谈你对-webpack-的看法"><a href="#115-谈谈你对-webpack-的看法" class="headerlink" title="115. 谈谈你对 webpack 的看法"></a>115. 谈谈你对 webpack 的看法</h3><pre><code>我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0" target="_blank" rel="noopener external nofollow noreferrer">《不聊 webpack 配置，来说说它的原理》</a><br><a href="https://juejin.im/entry/5b5724d05188251aa01647fd" target="_blank" rel="noopener external nofollow noreferrer">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br><a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0" target="_blank" rel="noopener external nofollow noreferrer">《浅入浅出 webpack》</a><br><a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e" target="_blank" rel="noopener external nofollow noreferrer">《前端构建工具发展及其比较》</a></p><h3 id="116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>116. offsetWidth/offsetHeight,clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h3><pre><code>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。clientTop 返回的是上边框的宽度。clientLeft 返回的左边框的宽度。offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。scrollLeft 属性返回的是元素滚动条到元素左边的距离。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5bc9366d5188255c4834e75a" target="_blank" rel="noopener external nofollow noreferrer">《最全的获取元素宽高及位置的方法》</a><br><a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html" target="_blank" rel="noopener external nofollow noreferrer">《用 Javascript 获取页面元素的位置》</a></p><h3 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h3><pre><code>简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是&quot;第一等公民&quot;、只用&quot;表达式&quot;。</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener external nofollow noreferrer">《函数式编程初探》</a></p><h3 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h3><p>相关资料：</p><pre><code>回调函数优点：简单、容易理解缺点：不利于维护，代码耦合高事件监听（采用时间驱动模式，取决于某个事件是否发生）：优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数缺点：事件驱动型，流程不够清晰发布/订阅（观察者模式）类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者Promise 对象优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；缺点：编写和理解，相对比较难Generator 函数优点：函数体内外的数据交换、错误处理机制缺点：流程管理不方便async 函数优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。缺点：错误处理机制</code></pre><p>回答：</p><pre><code>js 中的异步机制可以分为以下几种：第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</code></pre><h3 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h3><pre><code>CSS3 的动画的优点在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单缺点在动画控制上不够灵活兼容性不好JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</code></pre><h3 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h3><pre><code>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</code></pre><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h3 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h3><pre><code>URI: Uniform Resource Identifier      指的是统一资源标识符URL: Uniform Resource Location        指的是统一资源定位符URN: Universal Resource Name          指的是统一资源名称URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener external nofollow noreferrer">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br><a href="http://web.jobbole.com/83452/" target="_blank" rel="noopener external nofollow noreferrer">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br><a href="https://segmentfault.com/a/1190000006081973" target="_blank" rel="noopener external nofollow noreferrer">《URI、URL 和 URN 的区别》</a></p><h3 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h3><p>相关知识点：</p><pre><code>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</code></pre><p>回答：</p><pre><code>缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/qq_27093465/article/details/50479289" target="_blank" rel="noopener external nofollow noreferrer">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p><h3 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h3><p>相关知识点：</p><pre><code>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</code></pre><p>回答：</p><pre><code>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0c3b53f265da09253cbed0" target="_blank" rel="noopener external nofollow noreferrer">《懒加载和预加载》</a><br><a href="https://juejin.im/entry/5a73f38cf265da4e99575be3" target="_blank" rel="noopener external nofollow noreferrer">《网页图片加载优化方案》</a><br><a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/" target="_blank" rel="noopener external nofollow noreferrer">《基于用户行为的图片等资源预加载》</a></p><h3 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h3><pre><code>当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 mouseenter 不会冒泡。由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</code></pre><p>详细资料可以参考：<br><a href="https://github.com/qianlongo/zepto-analysis/issues/1" target="_blank" rel="noopener external nofollow noreferrer">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p><h3 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h3><p>相关知识点：</p><pre><code>首先是三个事件，分别是 mousedown，mousemove，mouseup当鼠标点击按下的时候，需要一个 tag 标识此时已经按下，可以执行 mousemove 里面的具体方法。clientX，clientY 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 offsetX 和 offsetY 来表示元素的元素的初始坐标，移动的举例应该是：鼠标移动时候的坐标-鼠标按下去时候的坐标。也就是说定位信息为：鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 offetLeft.</code></pre><p>回答：</p><pre><code>一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。这三步分别对应了三个事件，mousedown 事件，mousemove 事件和 mouseup 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 mousedown 事件中设置一个状态来标识鼠标已经按下，然后在 mouseup 事件中再取消这个状态。在 mousedown 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。然后在 mousemove 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。最后 mouseup 事件触发后，清除状态，结束拖拽事件。</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/LZGS_4/article/details/43523465" target="_blank" rel="noopener external nofollow noreferrer">《原生 js 实现拖拽功能基本思路》</a></p><h3 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h3><p>相关知识点：</p><pre><code class="js">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果function mySetInterval(fn, timeout) &#123;  // 控制器，控制定时器是否继续执行  var timer = &#123;    flag: true  &#125;;  // 设置递归函数，模拟定时器执行。  function interval() &#123;    if (timer.flag) &#123;      fn();      setTimeout(interval, timeout);    &#125;  &#125;  // 启动定时器  setTimeout(interval, timeout);  // 返回控制器  return timer;&#125;</code></pre><p>回答：</p><pre><code>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</code></pre><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851" target="_blank" rel="noopener external nofollow noreferrer">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737" target="_blank" rel="noopener external nofollow noreferrer">《setInterval 有什么缺点？》</a></p><h3 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h3><ul><li>1.声明的变量只在声明时的代码块内有效</li><li>2.不存在声明提升</li><li>3.存在暂时性死区，如果在变量声明前使用，会报错</li><li>4.不允许重复声明，重复声明会报错</li></ul><h3 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h3><pre><code>rest 参数（形式为...变量名），用于获取函数的多余参数。</code></pre><h3 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h3><pre><code>尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</code></pre><h3 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h3><ul><li>1.Symbol 函数前不能使用 new 命令，否则会报错。</li><li>2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>3.Symbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>5.Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>6.Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ul><h3 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h3><ul><li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，</li></ul><h3 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h3><ul><li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h3 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h3><pre><code>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</code></pre><h3 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h3><ul><li>1.将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li><li>2.修改某些 Object 方法的返回结果，让其变得更合理。</li><li>3.让 Object 操作都变成函数行为。</li><li>4.Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li></ul><h3 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h3><pre><code>当 Node 遇到 require(X) 时，按下面的顺序处理。（1）如果 X 是内置模块（比如 require(&#39;http&#39;)）　　a. 返回该模块。　　b. 不再继续执行。（2）如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头　　a. 根据 X 所在的父模块，确定 X 的绝对路径。　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X    X.js    X.json    X.node　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。    X/package.json（main字段）    X/index.js    X/index.json    X/index.node（3）如果 X 不带路径　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。（4）抛出 &quot;not found&quot;</code></pre><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener external nofollow noreferrer">《require() 源码解读》</a></p><h3 id="136-什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises/A+ 规范？</h3><pre><code>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</code></pre><p>详细资料可以参考：<br><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener external nofollow noreferrer">《Promises/A+ 规范》</a><br><a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve" target="_blank" rel="noopener external nofollow noreferrer">《Promise》</a></p><h3 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h3><pre><code class="js">const PENDING = &quot;pending&quot;;const RESOLVED = &quot;resolved&quot;;const REJECTED = &quot;rejected&quot;;function MyPromise(fn) &#123;  // 保存初始化状态  var self = this;  // 初始化状态  this.state = PENDING;  // 用于保存 resolve 或者 rejected 传入的值  this.value = null;  // 用于保存 resolve 的回调函数  this.resolvedCallbacks = [];  // 用于保存 reject 的回调函数  this.rejectedCallbacks = [];  // 状态转变为 resolved 方法  function resolve(value) &#123;    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变    if (value instanceof MyPromise) &#123;      return value.then(resolve, reject);    &#125;    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; &#123;      // 只有状态为 pending 时才能转变，      if (self.state === PENDING) &#123;        // 修改状态        self.state = RESOLVED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.resolvedCallbacks.forEach(callback =&gt; &#123;          callback(value);        &#125;);      &#125;    &#125;, 0);  &#125;  // 状态转变为 rejected 方法  function reject(value) &#123;    // 保证代码的执行顺序为本轮事件循环的末尾    setTimeout(() =&gt; &#123;      // 只有状态为 pending 时才能转变      if (self.state === PENDING) &#123;        // 修改状态        self.state = REJECTED;        // 设置传入的值        self.value = value;        // 执行回调函数        self.rejectedCallbacks.forEach(callback =&gt; &#123;          callback(value);        &#125;);      &#125;    &#125;, 0);  &#125;  // 将两个方法传入函数执行  try &#123;    fn(resolve, reject);  &#125; catch (e) &#123;    // 遇到错误时，捕获错误，执行 reject 函数    reject(e);  &#125;&#125;MyPromise.prototype.then = function (onResolved, onRejected) &#123;  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数  onResolved =    typeof onResolved === &quot;function&quot;      ? onResolved      : function (value) &#123;          return value;        &#125;;  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : function (error) &#123;          throw error;        &#125;;  // 如果是等待状态，则将函数加入对应列表中  if (this.state === PENDING) &#123;    this.resolvedCallbacks.push(onResolved);    this.rejectedCallbacks.push(onRejected);  &#125;  // 如果状态已经凝固，则直接执行对应状态的函数  if (this.state === RESOLVED) &#123;    onResolved(this.value);  &#125;  if (this.state === REJECTED) &#123;    onRejected(this.value);  &#125;&#125;;</code></pre><h3 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h3><pre><code>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</code></pre><h3 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h3><pre><code>error 统计使用浏览器的 window.error 事件。</code></pre><h3 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h3><pre><code>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</code></pre><h3 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h3><pre><code>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。</code></pre><h3 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h3><pre><code> 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</code></pre><h3 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h3><pre><code>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</code></pre><h3 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h3><pre><code>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</code></pre><p>更多关于设计模式的资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b" target="_blank" rel="noopener external nofollow noreferrer">《前端面试之道》</a><br><a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 设计模式》</a><br><a href="https://juejin.im/post/5afe6430518825428630bc4d" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 中常见设计模式整理》</a></p><h3 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h3><pre><code>发布订阅模式其实属于广义上的观察者模式在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</code></pre><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/23486749" target="_blank" rel="noopener external nofollow noreferrer">《观察者模式和发布订阅模式有什么不同？》</a></p><h3 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h3><pre><code>Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</code></pre><h3 id="147-Vue-的各个生命阶段是什么？"><a href="#147-Vue-的各个生命阶段是什么？" class="headerlink" title="147. Vue 的各个生命阶段是什么？"></a>147. Vue 的各个生命阶段是什么？</h3><pre><code>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5aee8fbb518825671952308c" target="_blank" rel="noopener external nofollow noreferrer">《vue 生命周期深入》</a><br><a href="https://cn.vuejs.org/v2/guide/instance.html" target="_blank" rel="noopener external nofollow noreferrer">《Vue 实例》</a></p><h3 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h3><pre><code>（1）父子组件间通信第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。（2）兄弟组件间通信第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。（3）任意组件之间使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345" target="_blank" rel="noopener external nofollow noreferrer">《VUE 组件之间数据传递全集》</a></p><h3 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h3><pre><code>（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7" target="_blank" rel="noopener external nofollow noreferrer">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009" target="_blank" rel="noopener external nofollow noreferrer">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h3 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h3><pre><code>（1）全局的钩子函数 beforeEach 和 afterEachbeforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。</code></pre><p>详细资料可以参考：<br><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener external nofollow noreferrer">《导航守卫》</a></p><h3 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h3><pre><code>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</code></pre><h3 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h3><pre><code>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</code></pre><h3 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h3><pre><code>vue 中 key 值的作用可以分为两种情况来考虑。第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599" target="_blank" rel="noopener external nofollow noreferrer">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119" target="_blank" rel="noopener external nofollow noreferrer">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html" target="_blank" rel="noopener external nofollow noreferrer">《vue 中 key 的作用》</a></p><h3 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h3><pre><code>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</code></pre><h3 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h3><pre><code>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</code></pre><h3 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h3><pre><code>mixin 用于全局混入，会影响到每个组件实例。mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f" target="_blank" rel="noopener external nofollow noreferrer">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener external nofollow noreferrer">《混入》</a></p><h3 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h3><pre><code>（1）application/x-www-form-urlencoded浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。（2）multipart/form-data该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。（3）application/json告诉服务器消息主体是序列化后的 JSON 字符串。（4）text/xml该种方式主要用来提交 XML 格式的数据。</code></pre><p>详细资料可以参考：<br><a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/" target="_blank" rel="noopener external nofollow noreferrer">《常用的几种 Content-Type》</a></p><h3 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h3><pre><code class="js">function getType(value) &#123;  // 判断数据是 null 的情况  if (value === null) &#123;    return value + &quot;&quot;;  &#125;  // 判断数据是引用类型的情况  if (typeof value === &quot;object&quot;) &#123;    let valueClass = Object.prototype.toString.call(value),      type = valueClass.split(&quot; &quot;)[1].split(&quot;&quot;);    type.pop();    return type.join(&quot;&quot;).toLowerCase();  &#125; else &#123;    // 判断数据是基本数据类型的情况和函数的情况    return typeof value;  &#125;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 专题之类型判断(上)》</a></p><h3 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h3><pre><code class="js">function checkNullObj(obj) &#123;  return Object.keys(obj).length === 0 &amp;&amp; Object.getOwnPropertySymbols(obj).length === 0;&#125;</code></pre><p>详细资料可以参考：<br><a href="https://blog.csdn.net/FungLeo/article/details/78113661" target="_blank" rel="noopener external nofollow noreferrer">《js 判断一个 object 对象是否为空》</a></p><h3 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h3><pre><code class="js">// 使用闭包实现for (var i = 0; i &lt; 5; i++) &#123;  (function (i) &#123;    setTimeout(function () &#123;      console.log(i);    &#125;, i * 1000);  &#125;)(i);&#125;// 使用 let 块级作用域for (let i = 0; i &lt; 5; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, i * 1000);&#125;</code></pre><h3 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h3><pre><code class="js">function jsonp(url, params, callback) &#123;  // 判断是否含有参数  let queryString = url.indexOf(&quot;?&quot;) === &quot;-1&quot; ? &quot;?&quot; : &quot;&amp;&quot;;  // 添加参数  for (var k in params) &#123;    if (params.hasOwnProperty(k)) &#123;      queryString += k + &quot;=&quot; + params[k] + &quot;&amp;&quot;;    &#125;  &#125;  // 处理回调函数名  let random = Math.random().toString().replace(&quot;.&quot;, &quot;&quot;),    callbackName = &quot;myJsonp&quot; + random;  // 添加回调函数  queryString += &quot;callback=&quot; + callbackName;  // 构建请求  let scriptNode = document.createElement(&quot;script&quot;);  scriptNode.src = url + queryString;  window[callbackName] = function () &#123;    // 调用回调函数    callback(...arguments);    // 删除这个引入的脚本    document.getElementsByTagName(&quot;head&quot;)[0].removeChild(scriptNode);  &#125;;  // 发起请求  document.getElementsByTagName(&quot;head&quot;)[0].appendChild(scriptNode);&#125;</code></pre><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/zzc5464/p/jsonp.html" target="_blank" rel="noopener external nofollow noreferrer">《原生 jsonp 具体实现》</a><br><a href="https://segmentfault.com/a/1190000007665361#articleHeader1" target="_blank" rel="noopener external nofollow noreferrer">《jsonp 的原理与实现》</a></p><h3 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h3><pre><code class="js">var events = (function () &#123;  var topics = &#123;&#125;;  return &#123;    // 注册监听函数    subscribe: function (topic, handler) &#123;      if (!topics.hasOwnProperty(topic)) &#123;        topics[topic] = [];      &#125;      topics[topic].push(handler);    &#125;,    // 发布事件，触发观察者回调事件    publish: function (topic, info) &#123;      if (topics.hasOwnProperty(topic)) &#123;        topics[topic].forEach(function (handler) &#123;          handler(info);        &#125;);      &#125;    &#125;,    // 移除主题的一个观察者的回调事件    remove: function (topic, handler) &#123;      if (!topics.hasOwnProperty(topic)) return;      var handlerIndex = -1;      topics[topic].forEach(function (item, index) &#123;        if (item === handler) &#123;          handlerIndex = index;        &#125;      &#125;);      if (handlerIndex &gt;= 0) &#123;        topics[topic].splice(handlerIndex, 1);      &#125;    &#125;,    // 移除主题的所有观察者的回调事件    removeAll: function (topic) &#123;      if (topics.hasOwnProperty(topic)) &#123;        topics[topic] = [];      &#125;    &#125;  &#125;;&#125;)();</code></pre><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000006934031#articleHeader1" target="_blank" rel="noopener external nofollow noreferrer">《JS 事件模型》</a></p><h3 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h3><pre><code class="js">class EventEmitter &#123;  constructor() &#123;    this.events = &#123;&#125;;  &#125;  on(event, callback) &#123;    let callbacks = this.events[event] || [];    callbacks.push(callback);    this.events[event] = callbacks;    return this;  &#125;  off(event, callback) &#123;    let callbacks = this.events[event];    this.events[event] = callbacks &amp;&amp; callbacks.filter(fn =&gt; fn !== callback);    return this;  &#125;  emit(event, ...args) &#123;    let callbacks = this.events[event];    callbacks.forEach(fn =&gt; &#123;      fn(...args);    &#125;);    return this;  &#125;  once(event, callback) &#123;    let wrapFun = function (...args) &#123;      callback(...args);      this.off(event, wrapFun);    &#125;;    this.on(event, wrapFun);    return this;  &#125;&#125;</code></pre><h3 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h3><pre><code class="js">function Foo() &#123;  getName = function () &#123;    alert(1);  &#125;;  return this;&#125;Foo.getName = function () &#123;  alert(2);&#125;;Foo.prototype.getName = function () &#123;  alert(3);&#125;;var getName = function () &#123;  alert(4);&#125;;function getName() &#123;  alert(5);&#125;//请写出以下输出结果：Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 3</code></pre><p>详细资料可以参考：<br><a href="https://github.com/Wscats/Good-text-Share/issues/85" target="_blank" rel="noopener external nofollow noreferrer">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br><a href="https://segmentfault.com/q/1010000008430170" target="_blank" rel="noopener external nofollow noreferrer">《一道考察运算符优先级的 JavaScript 面试题》</a><br><a href="https://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="noopener external nofollow noreferrer">《一道常被人轻视的前端 JS 面试题》</a></p><h3 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h3><pre><code>Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</code></pre><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><pre><code class="js">var t = performance.timing;var pageLoadTime = t.loadEventEnd - t.navigationStart;</code></pre><p>详细资料可以参考：<br><a href="http://javascript.ruanyifeng.com/bom/performance.html" target="_blank" rel="noopener external nofollow noreferrer">《Performance API》</a></p><h3 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h3><pre><code>（1）第一个字符必须是字母、下划线（_）或美元符号（$）（2）余下的字符可以是下划线、美元符号或任何字母或数字字符一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</code></pre><p>详细资料可以参考：<br><a href="http://www.w3school.com.cn/js/pro_js_variables.asp" target="_blank" rel="noopener external nofollow noreferrer">《ECMAScript 变量》</a></p><h3 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h3><pre><code>在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</code></pre><h3 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h3><pre><code>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</code></pre><h3 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h3><pre><code>Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</code></pre><h3 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h3><pre><code class="js">for (var i = 0, j = 0; i &lt; 5, j &lt; 9; i++, j++) &#123;  console.log(i, j);&#125;// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。// 当判断语句为空时，循环会一直进行。</code></pre><h3 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h3><pre><code>我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？解决办法：（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</code></pre><h3 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h3><pre><code>在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。一般解决倒计时中的误差的有这样两种办法：（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</code></pre><p>详细资料可以参考：<br><a href="https://juejin.im/post/5badf8305188255c8e728adc" target="_blank" rel="noopener external nofollow noreferrer">《JavaScript 前端倒计时纠偏实现》</a></p><h3 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h3><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br><a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278" target="_blank" rel="noopener external nofollow noreferrer">《进程间 8 种通信方式详解》</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener external nofollow noreferrer">《进程与线程的一个简单解释》</a></p><h3 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h3><pre><code class="js">function findMostWord(article) &#123;  // 合法性判断  if (!article) return;  // 参数处理  article = article.trim().toLowerCase();  let wordList = article.match(/[a-z]+/g),    visited = [],    maxNum = 0,    maxWord = &quot;&quot;;  article = &quot; &quot; + wordList.join(&quot;  &quot;) + &quot; &quot;;  // 遍历判断单词出现次数  wordList.forEach(function (item) &#123;    if (visited.indexOf(item) &lt; 0) &#123;      // 加入 visited      visited.push(item);      let word = new RegExp(&quot; &quot; + item + &quot; &quot;, &quot;g&quot;),        num = article.match(word).length;      if (num &gt; maxNum) &#123;        maxNum = num;        maxWord = item;      &#125;    &#125;  &#125;);  return maxWord + &quot;  &quot; + maxNum;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 面试精选</title>
      <link href="%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Webpack/"/>
      <url>%E9%9D%A2%E8%AF%95%E7%B2%BE%E9%80%89/Webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="headerlink" title="异步编程的实现方式"></a>异步编程的实现方式</h2><ul><li>回调函数</li><li>事件监听</li><li>发布订阅模式(观察者模式)</li><li>Promise</li><li>Generator</li><li>async/await</li></ul><h2 id="为什么-Proxy-不能被-Polyfill"><a href="#为什么-Proxy-不能被-Polyfill" class="headerlink" title="为什么 Proxy 不能被 Polyfill"></a>为什么 Proxy 不能被 Polyfill</h2><p>Class 可用 function 模拟<br>Promise 可用 callback 模拟<br>Proxy 不能用 Object.defineProperty 模拟</p><h2 id="npm-打包注意点"><a href="#npm-打包注意点" class="headerlink" title="npm 打包注意点"></a>npm 打包注意点</h2><ol><li>支持 CommonJS 规范</li><li>打包结果应该为 ES5</li><li>npm 包应尽量小</li><li>发布模块不应将依赖模块一同打包</li><li>ui 组件类的模块应将依赖的其他资源文件包含在发布模块里</li></ol><h2 id="webpack-与-grunt、gulp-的不同点"><a href="#webpack-与-grunt、gulp-的不同点" class="headerlink" title="webpack 与 grunt、gulp 的不同点"></a>webpack 与 grunt、gulp 的不同点</h2><ul><li>webpack: 基于入口。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的 loader 处理不同的文件，采用 plugin 扩展功能。适用于大型复杂的前端站点构建。</li><li>grunt: 基于任务, 找到一个(或一类)文件, 对其做一系列链式操作,更新流上的数据。整条链式操作构成一个任务，多个任务就构成了整个 web 的构建流程。</li><li>gulp: 基于流,找到一个(或一类)文件, 对其做一系列链式操作,更新流上的数据。整条链式操作构成一个任务，多个任务就构成了整个 web 的构建流程。</li><li>roolup: 适用于基础库打包。</li></ul><h2 id="webpack-中-chunk-和-bundle-的区别是什么"><a href="#webpack-中-chunk-和-bundle-的区别是什么" class="headerlink" title="webpack 中 chunk 和 bundle 的区别是什么"></a>webpack 中 chunk 和 bundle 的区别是什么</h2><blockquote><p>chunk 是过程，bundle 是结果，chunk 在构建完成时呈现为 bundle</p></blockquote><ul><li>chunk</li></ul><p>chunk 是 webpack 打包过程中 Modules 的集合，是(<strong>打包过程中</strong>)的概念</p><p>webpack 的打包是从一个入口模块开始，入口模块引用其他模块，其他模块引用其他模块......<br>webpack 通过引用关系诸葛打包模块，这些 module 就形成了一个 chunk</p><p>如果有多个入口模块，可能会产生多个打包路径，每条路径都会形成 chunk</p><ul><li>bundle</li></ul><p>是我们最终输出的一个或多个打包好的文件</p><ul><li>chunk 和 bundle 的区别(关系)是什么</li></ul><p>大多数情况下，一个 chunk 会生产一个 bundle, 但也有例外。如果加了 sourceMap，一个 entry，一个 chunk 对应两个 bundle。</p><ul><li>split chunk</li></ul><p>做代码分割，可以通过配置增加</p><h2 id="webpack-的构建流程-打包流程"><a href="#webpack-的构建流程-打包流程" class="headerlink" title="webpack 的构建流程(打包流程)"></a>webpack 的构建流程(打包流程)</h2><p>Webpack 的运行流程是一个串行的流程，从启动到结束会依次执行以下流程：</p><ul><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li>开始编译: 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li>确定入口：根据配置中的 entry 找出所有的入口文件</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过本步骤的处理</li><li>完成模块编译：经过上一步后，使用 Loader 编译完所有模块后，得到了每个模块编译后的最终内容以及他们之间的依赖关系</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk, 再把每个 chunk 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会</li><li>输出完成：在确定好输入内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 Api 改变 Webpack 的运行结果</p><h3 id="简单说法"><a href="#简单说法" class="headerlink" title="简单说法"></a>简单说法</h3><ul><li>初始化: 启动构建, 读取与合并配置参数, 加载 Plugin, 实例化 Compiler(编译器)</li><li>编译: 从 Entry(入口文件) 出发，针对每个模块串行调用对应的 Loader 去翻译文件的内容，再找到该模块依赖的模块，递归的进行编译处理</li><li>输出: 将编译后的模块组合成 Chunk, 将 Chunk 转换成文件, 输出到文件系统中</li></ul><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="webpack-常用-loader"><a href="#webpack-常用-loader" class="headerlink" title="webpack 常用 loader"></a>webpack 常用 loader</h3><ul><li>raw-loader: 加载文件原始内容（utf-8）</li><li>file-loader: 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader: 和 file-loader 类似, 区别是用可以设置一个阀值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)</li></ul><blockquote><p>在 webpack 5，通过添加 4 种新的模块类型，来替换所有这些 loader</p><ol><li>asset/resource 替换 file-loader</li><li>asset/inline 替换 url-loader</li><li>asset/source 替换 raw-loader</li></ol><p>在 webpack 5 中，可通过设置 <code>type: &quot;javascript/auto&quot;</code> 来使用旧的 assets loader</p></blockquote><ul><li>svg-inline-loader: 将压缩后的 svg 内容注入到代码中</li><li>source-map-loader: 加载额外的 source map 文件，以方便断点调试</li><li>image-loader: 加载并且压缩图片文件</li><li>babel-loader: 把 es6 转换成 es5</li><li>css-loader: 加载 css, 支持模块化、压缩、文件导入等特性</li><li>style-loader: 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li><li>MiniCssExtractPlugin.loader: 替换 style-loader, 用于将 JavaScript 中的 css 分离</li><li>postcss-loader: 扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li><li>source-map-loader: 从现有的源文件中提取 source maps</li><li>eslint-loader: 通过 ESLint 检查 JavaScript 代码</li><li>tslint-loader: 通过 TSLint 检查 TypeScript 代码</li><li>mocha-loader: 加载 Mocha 测试用例的代码</li><li>coverjs-loader: 计算测试的覆盖率</li><li>ts-loader: 将 TypeScript 转换成 JavaScript</li><li>vue-loader: 加载 vue.js 单文件组件</li><li>cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li></ul><h3 id="webpack-loader-执行顺序"><a href="#webpack-loader-执行顺序" class="headerlink" title="webpack loader 执行顺序"></a>webpack loader 执行顺序</h3><blockquote><p>从下到上, 从右向左。因为使用了函数式编程的方式</p></blockquote><h3 id="编写-loader-的注意点"><a href="#编写-loader-的注意点" class="headerlink" title="编写 loader 的注意点"></a>编写 loader 的注意点</h3><ol><li>loader 支持链式调用, 因此开发过程中需严格遵守 <code>单一指责</code>, 即每个 loader 只负责自己需要处理的内容</li><li>loader 运行在 node.js 中, 因此需导出一个函数, 参数是加载文件的原始 UTF-8 格式编码的字符串, 返回处理后的内容</li><li>如果要返回多个结果，可以使用 this.callback(err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any)</li><li>在 loader 中, 异步操作需使用 this.async</li><li>loader-utils 提供了 getOptions 方法用来获取参数信息; schema-utils 提供了 validate 方法用来做 JSON 模式验证</li></ol><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="介绍-webpack-plugin"><a href="#介绍-webpack-plugin" class="headerlink" title="介绍 webpack plugin"></a>介绍 webpack plugin</h3><p>webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问</p><ul><li>compiler 实例</li></ul><p>包含了 webpack 环境的所有配置信息，包含 options, loaders, plugins, 在 webpack 启动时实例化，也可理解为 webpack 的实例</p><blockquote><p>Compiler 模块是 webpack 的支柱引擎，它通过 cli 或 node api 传递的所有选项，创建出一个 compilation 实例。它扩展 (extend) 自 Tapable 类，以便注册和调用插件。</p></blockquote><ul><li>compilation 钩子</li></ul><p>包含当前模块资源，编译生成资源，webpack 在开发模式下运行的时候，每当检测到一个文件变化，就会创建一次新的 compilation</p><blockquote><p>Compilation 模块会被 Compiler 用来创建新的 compilation 对象(或新的 build 对象)。compilation 实例能够访问所有的模块和它们的依赖(大部分是循环依赖)。它会对应用程序的依赖图中所有模块, 进行字面上的编译(literal compilation)。在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、分块(chunk)、哈希(hash)和重新创建(restore)。</p></blockquote><h3 id="webpack-常用-plugin"><a href="#webpack-常用-plugin" class="headerlink" title="webpack 常用 plugin"></a>webpack 常用 plugin</h3><ul><li>webpack-bar: 自定义 webpack bar</li><li>html-webpack-plugin: 可根据模版自动生成 html 代码, 并自动引用 css 和 js 文件</li><li>mini-css-extract-plugin: 用于分割 css chunk 包</li><li>optimize-css-assets-webpack-plugin(webpack5+不适用)/css-minimizer-webpack-plugin(webpack5+适用): 用于压缩 css 代码, 同时可对不同组件中重复的 css 代码去重</li><li>uglifyjs-webpack-plugin/terser-webpack-plugin: 压缩 JavaScript</li><li>clean-webpack-plugin: 目录清理</li><li>webpack-bundle-analyze: 可视化分析包大小体积</li><li>compression-webpack-plugin: 开启 gzip 压缩</li><li>terser-webpack-plugin: 使用多进程并行压缩代码, 需设置 <code>parallel: true</code></li><li>DefinePlugin: 编译时配置全局变量, 对开发模式和生产模式的构建允许不同的行为非常有用(可配合 .env 使用)</li><li>HotModuleReplacementPlugin: 热更新</li><li>DllPlugin: 拆分捆绑包以大幅缩短构建时间, 用于抽离第三方模块，常用于对静态不变的第三方库进行处理</li><li>SplitChunksPlugin: 自动拆分 chunks, 公共资源拆分</li><li>SourceMapDevToolPlugin: 对 sourceMap 的更精细的配置</li><li>webpack-bundle-analyzer: 包大小分析</li></ul><h3 id="webpack-plugin-执行顺序"><a href="#webpack-plugin-执行顺序" class="headerlink" title="webpack plugin 执行顺序"></a>webpack plugin 执行顺序</h3><blockquote><p>按照编译顺序执行</p></blockquote><h3 id="编写-Plugin-的步骤"><a href="#编写-Plugin-的步骤" class="headerlink" title="编写 Plugin 的步骤"></a>编写 Plugin 的步骤</h3><ol><li>创建一个 JavaScript 函数或 JavaScript 类。</li><li>在其原型上绑定 apply 方法</li><li>指定要利用的事件挂钩(hook)。</li><li>处理 webpack 内部实例特定的数据。</li><li>功能完成后，调用 webpack 提供的回调(callback)。</li></ol><h2 id="webpack-loader-和-plugin-的区别"><a href="#webpack-loader-和-plugin-的区别" class="headerlink" title="webpack loader 和 plugin 的区别"></a>webpack loader 和 plugin 的区别</h2><p>loader 本质是一个函数, 接收一个参数, 参数是接收到的文件内容, 然后进行转换, 返回转换后的结果。本质起到了对非 JavaScript 类型资源的转译的预处理工作。</p><p>plugin 就是插件, 基于事件流框架 tapable, 插件可以扩展 webpack 的功能, 在 webpack 运行的生命周期中会广播出许多事件, plugibn 可以监听这些事件, 在合适的时机通过 webpack 提供的 API 改变输出结果</p><p>loader 在 module.rules 中配置, 作为模块的解析规则，是一个数组, 每一项都是一个对象, 内部包含了 test(类型文件)、loader、options(参数)等属性</p><p>plugin 在 plugins 中单独配置, 类型为数组, 每一项都是一个 plugin 实例, 参数都通过构造函数传入</p><h3 id="Webpack-提高效率的-plugin"><a href="#Webpack-提高效率的-plugin" class="headerlink" title="Webpack 提高效率的 plugin"></a>Webpack 提高效率的 plugin</h3><ul><li>webpack-dashboard: 更友好的展示相关的打包信息</li><li>webpack-merge: 提取公共配置，减少重复配置代码</li><li>speed-measure-webpack-plugin: 简称为 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时, 有助于找到构建过程中的性能瓶颈</li><li>size-plugin: 监控资源的体积变化，尽早的发现问题</li><li>HotModuleReplacementPlugin: 热模块替换</li></ul><h2 id="什么是-SourceMap"><a href="#什么是-SourceMap" class="headerlink" title="什么是 SourceMap"></a>什么是 SourceMap</h2><p>source map 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。map 文件只要不打开开发者工具，浏览器是不会加载的。</p><p>线上环境一般有三种处理方案：</p><ul><li>hidden-source-map：借助第三方错误监控平台 Sentry 使用</li><li>nosources-source-map：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li><li>sourcemap：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</li></ul><h2 id="Webpack-模块打包原理"><a href="#Webpack-模块打包原理" class="headerlink" title="Webpack 模块打包原理"></a>Webpack 模块打包原理</h2><p>Webpack 实际上为各个模块创造了一个可以导出和导入的环境，本质上并没有修改代码的执行逻辑，代码的执行顺序和模块的加载顺讯也完全一致</p><h2 id="Webpack-热更新原理"><a href="#Webpack-热更新原理" class="headerlink" title="Webpack 热更新原理"></a>Webpack 热更新原理</h2><p>webpack 的热更新又叫做热替换, 即 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块</p><p>HMR 的核心是客户端从服务器拉取更新后的文件, 准确说就是 chunk diff (chunk 需要更新的部分), 实际上 WDS (无线分布式系统) 与浏览器之间维护了一个 WebSocket, 当本地资源发生变化时, WDS 会向浏览器推送更新，并带上构建时的 hash, 让客户端与上一次资源进行对比。</p><p>客户端对比出差异后会向 WDS 发起 AJAX 请求来获取更改后的内容(文件列表、hash), 这样客户端就可以借助这些信息继续向 WDS 发起 jsonp 请求该 chunk 的增量更新。</p><h2 id="代码分割的本质"><a href="#代码分割的本质" class="headerlink" title="代码分割的本质"></a>代码分割的本质</h2><p>代码分割的本质就是在 源代码直接上线 和 打包成唯一脚本 main.bundle.js 这两种极端方案之间的一种更适合时机场景的中间状态。</p><p>用可接受的服务器性能压力增加来换取更好的用户体验</p><p>源代码直接上线：虽然过程可控，但 http 请求多，性能开销大<br>打包成唯一脚本：服务器压力小，但页面空白期常，用户体验差</p><h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><blockquote><p>做性能优化的目的，如哪项指标影响了业务，那个指标是关键</p></blockquote><blockquote><p>常见的性能优化的点:</p><ol><li>首屏渲染时间</li><li>首次可交互时间 (手机号验证码)</li><li>首次有意义内容渲染时间 (具体的主要元素的渲染时间)</li></ol></blockquote><blockquote><p><a href="https://developers.google.com/speed/pagespeed/insights" target="_blank" rel="noopener external nofollow noreferrer">页面性能检测工具</a></p></blockquote><h3 id="根据类型"><a href="#根据类型" class="headerlink" title="根据类型"></a>根据类型</h3><h4 id="只请求当前需要的资源"><a href="#只请求当前需要的资源" class="headerlink" title="只请求当前需要的资源"></a>只请求当前需要的资源</h4><ul><li>路由的异步加载</li><li>图片的懒加载</li><li>babel 的 polyfill (低版本下对高版本语法的补充), <a href="https://polyfill.io/v3/url-builder" target="_blank" rel="noopener external nofollow noreferrer">利用 CDN 加载 polyfill 服务</a>, 可以实现对 polyfill 的按需加载</li></ul><h4 id="缩减资源体积"><a href="#缩减资源体积" class="headerlink" title="缩减资源体积"></a>缩减资源体积</h4><ul><li>打包压缩</li><li>gzip(一种压缩算法)</li><li>图片格式的优化，<a href="https://tinypng.com/" target="_blank" rel="noopener external nofollow noreferrer">压缩</a>, 根据屏幕分辨率展示不同分辨率的图片, webp 图片格式</li><li>在 request header 中尽量控制 cookie 大小</li></ul><h4 id="时序优化"><a href="#时序优化" class="headerlink" title="时序优化"></a>时序优化</h4><ul><li>对于没有相互关联, 没有依赖关系的请求, 采用 Promise.all 并行请求</li><li>ssr (在服务端打包, 可以做缓存)</li><li>prefetch、prerender、preload<ul><li>dns 预解析(<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;xxx1.com&quot; /&gt;</code>)</li><li>预连接 (<code>&lt;link rel=&quot;preconnect&quot; href=&quot;xxx1.com&quot; /&gt;</code>)</li><li>预加载 (<code>&lt;link rel=&quot;preload&quot; as=&quot;image&quot; href=&quot;https://xxx/a.png&quot; /&gt;</code>)</li></ul></li></ul><h4 id="合理利用缓存"><a href="#合理利用缓存" class="headerlink" title="合理利用缓存"></a>合理利用缓存</h4><ul><li>CDN (CDN 预热, CDN 刷新)</li></ul><h3 id="根据优化方向"><a href="#根据优化方向" class="headerlink" title="根据优化方向"></a>根据优化方向</h3><h4 id="工程化方向"><a href="#工程化方向" class="headerlink" title="工程化方向"></a>工程化方向</h4><ol><li>客户端使用 gizp 离线包, 服务端开启 gzip 压缩</li><li>使用 Tree-shaking 去除未使用代码</li><li>es-module</li><li>动态 import</li><li>图片加载优化, 客户端预渲染</li><li>使用 CDN 加速</li><li>采取 Webpack 提供的优化<ul><li>base64, tree-shaking, 资源压缩, 拆包 chunk</li><li>DLL 拆分基础包</li><li>使用别名</li></ul></li><li>骨架图</li><li>数据预取</li><li>减少重定向</li><li>合理利用浏览器缓存</li><li>启用 http2</li><li>使用负载均衡(可提高响应速度)</li></ol><h4 id="细节方向"><a href="#细节方向" class="headerlink" title="细节方向"></a>细节方向</h4><ol><li>图片占位, 雪碧图</li><li>预加载</li><li>合理利用缓存策略</li><li>script 标签合理利用 defer/async</li><li>减少 dom 操作，减少重排重绘</li><li>接口请求合并</li><li>数据缓存</li><li>首页加载不可视组件</li><li>防止渲染抖动, 控制时序</li><li>减少组件层级</li><li>使用 flex 布局</li></ol><h2 id="如何优化-Webpack-的构建速度"><a href="#如何优化-Webpack-的构建速度" class="headerlink" title="如何优化 Webpack 的构建速度"></a>如何优化 Webpack 的构建速度</h2><ol><li>使用高版本的 Webpack 和 Node.js</li><li>多进程/多实例构建 thread-loader</li><li>代码压缩</li><li>图片压缩</li><li>缩小打包作用域<ul><li>exclude/include(确定 loader 规则范围)</li><li>resolve.modules 指明第三方模块的绝对路径(减少不必要的查找)</li><li>对不需要解析的库进行忽略</li><li>完全排除模块</li><li>合理利用 alias</li></ul></li><li>提取页面公共资源<ul><li>基础包分离，将基础包通过 CDN 引入，不打入 bundle 中</li><li>使用 SplitChunksPlugin 进行公共资源分离</li></ul></li><li>DLL<ul><li>使用 DLLPlugin 进行分包，使用索引链接对 mainfest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间</li></ul></li><li>充分利用缓存提升二次构建速度<ul><li>babel-loader 开启缓存</li><li>terser-webpack-plugin 开启缓存</li><li>使用 cache-loader 或者 hard-source-webpack-plugin</li></ul></li><li>Tree shaking<ul><li>打包过程中检测工程中没有使用过的模块并进行标记，在资源压缩时将他们从最终的 bundle 中去掉，在开发中尽可能使用 ES6 Module 的模块，提高 tree-shaking 效率</li><li>禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就是转换过的 CommonJS 形式的模块，无法进行 tree-shaking</li><li>去掉无用的 css 代码</li></ul></li></ol><h2 id="Webpack-区分不同环境"><a href="#Webpack-区分不同环境" class="headerlink" title="Webpack 区分不同环境"></a>Webpack 区分不同环境</h2><ul><li><code>webpack.dev.js</code></li></ul><p>主要是用来配置一些 HMR 相关的内容，以及 sourceMap 用于调试工作</p><pre><code class="js">// webpack-merge 合并webpack 不同环境配置文件let &#123; smart &#125; = require(&#39;webpack-merge&#39;);let base = require(&#39;./webpack.base&#39;);module.exports = smart(base, &#123;    mode: &#39;development&#39;    entry: &#123;&#125;,    output: &#123;&#125;,    devServer: &#123;&#125;,    module: &#123;&#125;,    plugins: [], &#125;)</code></pre><ul><li><code>webpack.prod.js</code></li></ul><p>主要配置一些代码压缩等功能，精简代码，如去除无用的 console 等，对文件的分离</p><pre><code class="js">let &#123; smart &#125; = require(&#39;webpack-merge&#39;);let base = require(&#39;./webpack.base&#39;);module.exports = smart(base, &#123;    mode: &#39;production&#39;,    entry: &#123;&#125;,    output: &#123;&#125;,    devServer: &#123;&#125;,    module: &#123;&#125;,    plugins: [], &#125;)</code></pre><h2 id="Babel-原理"><a href="#Babel-原理" class="headerlink" title="Babel 原理"></a>Babel 原理</h2><p>Babel 大概分为三大部分：</p><ol><li><p>解析：将代码转换成 AST</p><ul><li>词法分析：将代码(字符串)分割为 token 流，即语法单元成的数组</li><li>语法分析：分析 token 流(上面生成的数组)并生成 AST</li></ul></li><li><p>转换：访问 AST 的节点进行变换操作生产新的 AST</p><ul><li>Taro 就是利用 babel 完成的小程序语法转换</li></ul></li><li><p>生成：以新的 AST 为基础生成代码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Webpack </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基数排序是一种非比较型整数排序算法，也是桶排序的一种特殊情况。其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较</p><p>简单来说就是分成 10 个桶，按照每个数字的最后一位数字进行分桶，然后按顺序放入桶中，之后按照桶大小从桶底部按顺序放入数列中。第一轮完毕后将按照每个数字的倒数第二位数字进行分桶，原理同上，当没有位数时，将按 0 处理。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">/** * * @param arr 待排序数组 * @param max 最大位数 */function radixSort(arr, max) &#123;  const buckets = [];  let unit = 10,    base = 1;  for (let i = 0; i &lt; max; i++, base *= 10, unit *= 10) &#123;    for (let j = 0; j &lt; array.length; j++) &#123;      let index = ~~((array[j] % unit) / base); //依次过滤出个位，十位等等数字      if (buckets[index] == null) &#123;        buckets[index] = []; //初始化桶      &#125;      buckets[index].push(array[j]); //往不同桶里添加数据    &#125;    let pos = 0,      value;    for (let j = 0, length = buckets.length; j &lt; length; j++) &#123;      if (buckets[j] != null) &#123;        while ((value = buckets[j].shift()) != null) &#123;          array[pos++] = value; //将不同桶里数据挨个捞出来，为下一轮高位排序做准备，由于靠近桶底的元素排名靠前，因此从桶底先捞        &#125;      &#125;    &#125;  &#125;  return arr;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>堆排序利用了二叉堆的特性来做，二叉堆通常用数组来表示，并且二叉堆是一颗完全二叉树(除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列)。二叉堆分为大根堆和小根堆。</p><ul><li>大根堆是某个节点的所有子节点的值都比它小</li><li>小根堆是某个节点的所有子节点的值都比它大</li></ul><p>堆排序的原理就是组成一个大根堆或小根堆。以小跟堆为例，某个节点的左边子节点的索引是 i ✖️ 2 + 1，右边是 i ✖️ 2 + 2，父节点是 (i - 1) / 2 =&gt; i &gt;&gt; 1</p><ol><li>首先遍历数组，判断该节点的父节点是否比它小，如果小就交换位置并继续判断，直到它的父节点比它大</li><li>重复以上操作 1，直到数组首位是最大值</li><li>然后将首位和末尾交换位置并将数组长度减 1，表示数组末尾已经是最大值，不需要再比较大小</li><li>对比左右节点哪个大，然后记住大的节点的索引的值并和父节点对比大小，如果子节点大就交换位置</li><li>重复 3 - 4 直到整个数组都是大根堆</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function heap(arr) &#123;    // 将最大值放到首位    for (let i = 0; i &lt; arr.length; i++) &#123;        heapInsert(arr, i);    &#125;    // 交换队首和队尾    [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];    while (arr.length &gt; 0) &#123;        heapify(arr, 0, arr.length - 1);        [arr[0], [arr[arr.length - 1]]] = [arr[arr.length - 1], arr[0]];    &#125;    return arr;&#125;function heapInsert(arr, index) &#123;    // 如果当前节点比父节点大，就交换    while(arr[index] &gt; arr[index &gt;&gt; 1]) &#123;        // 交换        [arr[index], arr[index &gt;&gt; 1]] = [arr[index &gt;&gt; 1], arr[index]];        // 将索引变为父节点        index = index &gt;&gt; 1;    &#125;&#125;function heapify(arr, index, size) &#123;    let left = index &lt;&lt; 1 + 1;    while (left &lt; size) &#123;        // 判断左右节点大小        let largest = left + 1 &lt; size &amp;&amp; arr[left] &lt; arr[left + 1] ? left + 1 : left;        // 判断子节点和父节点大小        largest = arr[index] &lt; arr[largest] ? largest : index;        if (largest === index) break;        [arr[index], arr[largest]] = [arr[lagest], arr[index]];        index = largest;        left = index &lt;&lt; 1 + 1;    &#125;&#125;</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最佳: O(nlogn) 最差: O(nlogn) 平均: O(nlogn)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>桶排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>桶排序是计数排序的升级版，也采用了分冶思想</p><ol><li>将要排序的数据分到有限数量的几个有序桶里</li><li>每个桶里的数据再单独进行排序(一般用插入排序或者快速排序)</li><li>桶内排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function bucketSort(arr, bucketSize) &#123;  if (arr.length === 0) return arr;  let i = 0;  let min = arr[0];  let max = arr[0];  for (let i = 1; i &lt; arr.length; i++) &#123;    if (arr[i] &lt; min) &#123;      min = arr[i];    &#125; else if (arr[i] &gt; max) &#123;      max = arr[i];    &#125;  &#125;  // 初始化桶  const DEFAULT_BUCKET_SIZE = 5; // 桶的数量  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;  const bucketCount = Math.floor((max - min) / bucketSize) + 1;  const buckets = new Array(bucketCount);  for (let i = 0; i &lt; buckets.length; i++) &#123;    buckets[i] = [];  &#125;  // 利用映射函数将数据分配到各个桶中  for (let i = 0; i &lt; arr.length; i++) &#123;    buckets[Math.floor((arr[i] - min) / bucketSize)].push(arr[i]);  &#125;  arr.length = 0;  for (let i = 0; i &lt; buckets.length; i++) &#123;    quickSort(bucket[i]);    for (let j = 0; j &lt; buckets[i].length; j++) &#123;      arr.push(buckets[i][j]);    &#125;  &#125;  return arr;&#125;function quickSort(arr) &#123;  if (arr.length &lt;= 1) return arr;  const middleIndex = arr.length &gt;&gt; 1;  const middle = arr.splice(middleIndex, 1)[0];  const left = [];  const right = [];  for (let i = 0; i &lt; arr.length; i++) &#123;    if (arr[i] &lt; middle) &#123;      left.push(arr[i]);    &#125; else &#123;      right.push(arr[i]);    &#125;  &#125;  return quickSort(left).concat(middle, quickSort(right));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计数排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有 17 个元素的值小于 x 的值，则 x 可以直接存放在输出序列的第 18 个位置上。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function countionSort(arr) &#123;  let obj = &#123;&#125;;  // 遍历原数组，给对象新增键值对，如果已经存在就对应的属性值++，如果不存在则新增键值对  for (let i = 0; i &lt; arr.length; i++) &#123;    if (!obj[arr[i]]) &#123;      obj[arr[i]] = 1;    &#125; else &#123;      obj[arr[i]]++;    &#125;  &#125;  let index = 0;  // 遍历对象属性名，按顺序放回覆盖原数组  for (let key in obj) &#123;    while (obj[key] &gt; 0) &#123;      arr[index] = Number(key);      obj[key]--;      index++;    &#125;  &#125;  return arr;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>快速排序的特点就是快，而且效率高。它是处理大数据最快的排序算法之一</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>随机选取一个数组中的值作为基准值，从左至右取值与基准值比较大小。比基准值小的放到数组左边，比基准值大的放到数组右边，对比完成后将基准值和第一个比基准值大的值交换位置，然后将数组以基准值的位置分为两个部分，继续递归以上操作。</p><pre><code class="js">function quickSort(arr) &#123;    if (arr.length &lt;= 1) return arr;    // 取基准点    const middleIndex = arr.length &gt;&gt; 1;    // 取基准点的值    const middle = arr.splice(middleIndex, 1)[0];    const left = [];    const right = [];    for (let i = 0; i &lt; arr.length; i++) &#123;        if (arr[i] &lt; middle) &#123;            left.push(arr[i]);        &#125; else &#123;            right.push(arr[i]);        &#125;    &#125;    return quickSort(left).concat(middle, quickSort(right))&#125;   </code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最佳: O(nlogn) 最差: O(n<sup>2</sup>) 平均: O(nlogn)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebScoket</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/WebScoket/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/WebScoket/</url>
      
        <content type="html"><![CDATA[<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 是基于应用层传输控制协议，而 socket 是基于传输层的传输控制协议，WebSocket 是在 Socket 之上封装的一种上层通讯协议。它们都是全双工的(可以同时接收和发送)。为了区别于普通的 Http 请求，发起 WebSocket 请求时，会增加一个请求头，用来告诉服务器这是 WebSocket 请求。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件发布订阅</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<ul><li>原生 eventBus 实现</li></ul><pre><code class="js">class EventEmitter &#123;  constructor() &#123;    this.cache = &#123;&#125;;  &#125;  /**   * @desc 监听   * @params name 事件名   * @params fn 事件函数   */  on(name, fn) &#123;    if (this.cache[name]) &#123;      this.cache[name].push(fn);    &#125; else &#123;      this.cache[name] = [fn];    &#125;  &#125;  /**   * @desc 触发   * @params name 事件名   * @params once 是否执行后立即销毁   * @params args 额外参数   */  emit(name, once = false, ...args) &#123;    if (this.cache[name]) &#123;      let tasks = this.cache[name].slice();      for (let fn of tasks) &#123;        fn(...args);      &#125;      if (once) &#123;        delete this.cache[name];      &#125;    &#125;  &#125;  /**   * @desc 移除监听   * @params name 事件名   * @params fn 事件函数   */  off(name, fn) &#123;      let tasks = this.cache[name];      if (tasks) &#123;          const index = tasks.findIndex(            task =&gt; task === fn || task.callback === fn          );          if (index &gt;= 0) &#123;              tasks.splice(index, 1);          &#125;      &#125;  &#125;&#125;// examplelet eventBus = new EventEmitter();let fn1 = function(name, age) &#123;  console.log(`$&#123;name&#125; $&#123;age&#125;`)&#125;let fn2 = function(name, age) &#123;  console.log(`hi $&#123;name&#125; $&#123;age&#125;`)&#125;eventBus.on(&quot;test1&quot;, fn1);eventBus.on(&quot;test1&quot;, fn2);eventBus.emit(&quot;test1&quot;, false, &quot;zhangsan&quot;, &quot;lisi&quot;)</code></pre><ul><li>Vue eventBus</li></ul><blockquote><p>vue 的实例就是一个事件总线</p></blockquote><pre><code class="js">// src/bus.jsimport Vue from &quot;vue&quot;;export default new Vue();// src/main.jsimport bus from &quot;./bus&quot;;Vue.prototype.$bus = Bus;// a.vuethis.$bus.on(&quot;changeValue&quot;, (msg, val) =&gt; &#123;  console.log(msg, val);&#125;);// b.vuethis.$bus.emit(&quot;changeValue&quot;, &quot;hi&quot;, &quot;eventBus&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件循环机制(Event Loop)</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间的先后顺序执行，排在队头的任务将会先被执行，而排在队尾的任务将会在最后执行。事件队列每次仅执行一个任务，在该任务执行完毕后，再执行下一个任务。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈则是一个类似于调用栈的运行容器，当执行栈为空时，JS 引擎便会检查事件队列，如果事件队列不为空，事件队列便会将第一个任务压入执行栈中运行。</p><h2 id="什么是-JavaScript-事件循环机制"><a href="#什么是-JavaScript-事件循环机制" class="headerlink" title="什么是 JavaScript 事件循环机制"></a>什么是 JavaScript 事件循环机制</h2><p>因为 JavaScript 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</p><p>在执行同步代码时，如果遇到了异步事件，JavaScript 引擎并不会一直等待其返回结果，而是会将这个事件暂时挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈不同的另一个任务队列中等待执行。</p><p>任务队列分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，JavaScript 引擎会首先判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入执行栈中执行。当微任务队列中的任务都执行完毕后再去判断宏任务队列中的任务。</p><h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><ul><li>Promise.then、Promise.catch、Promise.finally 等</li><li>Node 中的 Process.nextTick</li><li>对 Dom 变化监听的 MutationObserver</li></ul><h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><ul><li>JavaScript 脚本的执行</li><li>setTimeout、setInterval、setImmediate 一类的定时事件</li><li>I/O 操作</li><li>UI 渲染</li></ul><h2 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h2><pre><code class="js">console.log(&#39;1&#39;)setTimeout(() =&gt; &#123;  console.log(&#39;2&#39;)&#125;)new Promise((resolve, rejects) =&gt; &#123;  console.log(&#39;3&#39;)  resolve()&#125;).then(() =&gt; &#123;  console.log(&#39;4&#39;)&#125;)console.log(5)// 输出: 1 -&gt; 3 -&gt; 5 -&gt; 4 -&gt; 2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是复杂度分析"><a href="#什么是复杂度分析" class="headerlink" title="什么是复杂度分析"></a>什么是复杂度分析</h2><ol><li>数据结构和算法是解决 &quot;如何让计算机以更快的时间、更省空间的解决问题&quot;</li><li>因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。</li><li>分别用时间复杂度和空间复杂度两个概念来描述性能问题，两个统称为复杂度。</li><li>复杂度描述的是算法的执行时间(或占用空间)与数据规模的增长关系。</li></ol><h2 id="为什么要进行复杂度分析"><a href="#为什么要进行复杂度分析" class="headerlink" title="为什么要进行复杂度分析"></a>为什么要进行复杂度分析</h2><ol><li>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。</li><li>掌握复杂度分析，将可以编写出性能更优的代码，有利于降低系统开发和维护成本。</li></ol><h2 id="如何进行复杂度分析"><a href="#如何进行复杂度分析" class="headerlink" title="如何进行复杂度分析"></a>如何进行复杂度分析</h2><h3 id="大-O-表示法"><a href="#大-O-表示法" class="headerlink" title="大 O 表示法"></a>大 O 表示法</h3><p>算法的执行时间和每行代码的执行次数成正比，用 T(n)=O(f(n)) 表示，其中 T(n) 表示算法执行总时间，f(n) 表示每行代码执行的总次数，而 n 往往表示数据的规模，这就是大 O 时间复杂度表示法</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol><li>定义</li></ol><p>算法时间复杂度，也就是算法的时间量度</p><p>大 O 时间复杂度表示法实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的趋势，所以也叫渐进时间复杂度，简称时间复杂度。</p><ul><li><p>例 1</p><pre><code class="js">// example 1function func() &#123;  console.log(&quot;Hi&quot;); // 需要执行一次  return 0; // 需要执行一次&#125;</code></pre><blockquote><p>此方法将会执行 2 次计算</p></blockquote></li><li><p>例 2</p><pre><code class="js">function func(n) &#123;  for (let i = 0; i &lt; n; i++) &#123;    // n + 1 次    console.log(&quot;Hi&quot;); // n 次  &#125;  return 0; // 执行 1 次&#125;</code></pre><blockquote><p>此方法将会执行 (n + 1) + (n + 1) = 2n + 2 次计算</p></blockquote></li><li><p>例 3</p><pre><code class="js">function func(n) &#123;  let sum = 0; // 1 次  let i = 1; // 1 次  let j = 1; // 1 次  for (; i &lt;= n; ++i) &#123;    // n 次    j = 1; // n 次    for (; j &lt;= n; ++j) &#123;      // n * n 次      sum = sum + i * j; // n * n 次    &#125;  &#125;&#125;</code></pre><blockquote><p>此方法将会执行 ( n2 + n2 + n + n + 1 + 1 +1 ) = 2n<sup>2</sup> +2n + 3 次计算</p></blockquote></li></ul><ol start="2"><li>特点</li></ol><p>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长 <strong>变化趋势</strong>，所以常量、低阶、系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时 <strong>忽略</strong> 这些项</p><p>因此，例 1 的时间复杂度为 T(n) = O(1)；例 2 的时间复杂度为 T(n) = O(n)；例 3 的时间复杂度为 T(n) = O(n<sup>2</sup>)</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="只关注循环执行次数最多的一段代码"><a href="#只关注循环执行次数最多的一段代码" class="headerlink" title="只关注循环执行次数最多的一段代码"></a>只关注循环执行次数最多的一段代码</h3><h3 id="加法原则-用复杂度等于量级最大的那段代码的复杂度"><a href="#加法原则-用复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="加法原则: 用复杂度等于量级最大的那段代码的复杂度"></a>加法原则: 用复杂度等于量级最大的那段代码的复杂度</h3><h3 id="乘法原则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#乘法原则-嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="乘法原则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>乘法原则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><h3 id="多个规模求加法-比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加"><a href="#多个规模求加法-比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加" class="headerlink" title="多个规模求加法: 比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加"></a>多个规模求加法: 比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加</h3><pre><code class="js">function fn(m, n) &#123;  let sum = 0;  let i = 1;  for (; i &lt; m; ++i) &#123;    sum = sum + i;  &#125;  let sum2 = 0;  let j = 1;  for (; j &lt; n; ++i) &#123;    sum2 = sum2 + j;  &#125;  return sum + sum2;&#125;</code></pre><blockquote><p>(公式: T1(m) + T2(n) = O(f(m) + g(n)))</p></blockquote><h3 id="多个规模求乘法-比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘"><a href="#多个规模求乘法-比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘" class="headerlink" title="多个规模求乘法: 比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘"></a>多个规模求乘法: 比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘</h3><pre><code class="js">function fn(m, n) &#123;  let sum = 0;  let i = 1;  let j = 1;  for (; i &lt;= m; ++i) &#123;    j = 1;    for (; j &lt;= n; ++j) &#123;      sum = sum + i * j;    &#125;  &#125;&#125;</code></pre><blockquote><p>公式: T1(m) ✖️ T2(n) = O(f(m) ✖️ g(n)</p></blockquote><h2 id="常用的时间复杂度分析"><a href="#常用的时间复杂度分析" class="headerlink" title="常用的时间复杂度分析"></a>常用的时间复杂度分析</h2><h3 id="多项式阶"><a href="#多项式阶" class="headerlink" title="多项式阶"></a>多项式阶</h3><ul><li>常数阶 O(1)</li><li>对数阶 O(logn)</li></ul><pre><code class="js">// 对数阶function fn(n) &#123;  let i = 1;  while (i &lt;= n) &#123;    i = i * 2;  &#125;  return i;&#125;function func(n) &#123;  let sum = 0;  for (let i = 0; i &lt;= n; ++i) &#123;    sum = sum + fn(n);  &#125;  return sum;&#125;</code></pre><blockquote><p>fn 的时间复杂度为 O(logn)，而 func 的时间复杂度为 O(n)，所以上面代码的时间复杂度为 T(n) = T1(logn) * T2(n) = O(nlogn)</p></blockquote><ul><li>线性阶 O(n)</li><li>线性对数阶 O(nlogn)</li><li>平方阶 O(n<sup>2</sup>)</li><li>立方截 O(n<sup>3</sup>)</li></ul><h2 id="非多项式阶"><a href="#非多项式阶" class="headerlink" title="非多项式阶"></a>非多项式阶</h2><p>随着数据规模的增长，算法的执行时间和空间占用爆增，这类算法性能极差</p><ul><li>指数阶 O(2<sup>n</sup>)</li></ul><pre><code class="js">function fib(n) &#123;  if (n &lt;= 1) &#123;    return 1;  &#125; else &#123;    return fib(n - 1) + fib(n - 2);  &#125;&#125;</code></pre><ul><li>阶乘阶 O(n!)</li></ul><h2 id="时间复杂度分类"><a href="#时间复杂度分类" class="headerlink" title="时间复杂度分类"></a>时间复杂度分类</h2><ul><li>最好情况时间复杂度</li><li>最坏情况时间复杂度</li><li>平均情况时间复杂度(加权时间复杂度 or 期望时间复杂度)</li><li>均摊时间复杂度</li></ul><h2 id="时间复杂度总结"><a href="#时间复杂度总结" class="headerlink" title="时间复杂度总结"></a>时间复杂度总结</h2><p>常用时间复杂度所耗费的时间从小到大依次是:</p><p>O(1) &lt; O(logn) &lt; O(nlogin) &lt; O(n) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>时间复杂度的全称是渐近时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</p><p>类比一下，空间复杂度全程就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</p><ol><li>定义:</li></ol><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的算法公式计作: S(n) = O(f(n))，其中 n 为问题规模，f(n) 为语句关于 n 所占存储空间的函数</p><pre><code class="js">function fn(n) &#123;  const newArr = []; // 第 2 行  newArr.length = n; // 第 3 行  for (let i = 0; i &lt; n; ++i) &#123;    newArr[i] = i * i;  &#125;  for (let j = n - 1; j &gt;= 0; --j) &#123;    console.log(newArr[i]);  &#125;&#125;</code></pre><p>跟时间复杂度分析一样，我们可以看到，第二行代码中，我们申请了一个空间存储变量 newArr，是个空数组。第 3 行把 newArr 的长度修改为长度为 n 的数组，每项的值为 undefined。除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)</p><p>我们常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup>)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时用不到</p><h2 id="如何掌握好复杂度分析法"><a href="#如何掌握好复杂度分析法" class="headerlink" title="如何掌握好复杂度分析法"></a>如何掌握好复杂度分析法</h2><p>平时我们在写代码时，是用时间换空间还是空间换时间，可以根据算法的时间复杂度和空间复杂度来衡量</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E8%B7%A8%E5%9F%9F/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="跨域的几种方式"><a href="#跨域的几种方式" class="headerlink" title="跨域的几种方式"></a>跨域的几种方式</h2><ol><li>jsonp</li><li>document.domain + iframe</li><li>document.domain + location.hash</li><li>window.name + iframe</li><li>postMessage</li><li>跨域资源共享 cors</li><li>nginx 反向代理</li><li>node.js 中间件代理跨域</li><li>websocket 协议跨域</li></ol><h2 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h2><p>解决跨域的方法可以按照我们想要实现的目的来划分</p><h3 id="实现主域名下不同子域名的跨域操作"><a href="#实现主域名下不同子域名的跨域操作" class="headerlink" title="实现主域名下不同子域名的跨域操作"></a>实现主域名下不同子域名的跨域操作</h3><h3 id="通过-document-domain-实现主域名下不同子域名的跨域操作"><a href="#通过-document-domain-实现主域名下不同子域名的跨域操作" class="headerlink" title="通过 document.domain 实现主域名下不同子域名的跨域操作"></a>通过 document.domain 实现主域名下不同子域名的跨域操作</h3><ol><li>document.domain<br>将 document.domain 设置为主域名，来实现相同子域名下的跨域操作，这时主域名下的 cookie 就能被子域名所访问。</li></ol><h3 id="通过-location-hash、window-name、postMessage-来实现跨域窗口间的通信问题"><a href="#通过-location-hash、window-name、postMessage-来实现跨域窗口间的通信问题" class="headerlink" title="通过 location.hash、window.name、postMessage 来实现跨域窗口间的通信问题"></a>通过 location.hash、window.name、postMessage 来实现跨域窗口间的通信问题</h3><ol><li>locaiton.hash<br>在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 中是无法访问到不同源的父级窗口的，所以我们不能通过直接修改父级床口的 hash 值来实现通信。我们可以在 iframe 中再加入一个 iframe，这个 iframe 的内容是和父级页面同源的，所以我们可以通过 window.parent.parent 来修改最顶级页面的 src，以此来实现页面的双向通信。</li><li>window.name<br>主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这时页面就可以访问同源子页面中 window.name 的数据了，这种方式的好处是可以传输的数据量大。</li><li>postMessge<br>postMessage 是 h5 新提供的 api。通过它我们可以实现多窗口之间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换</li></ol><h4 id="通过-jsonp、cors、websocket、服务器代理来解决-ajax-无法提交跨域请求的问题"><a href="#通过-jsonp、cors、websocket、服务器代理来解决-ajax-无法提交跨域请求的问题" class="headerlink" title="通过 jsonp、cors、websocket、服务器代理来解决 ajax 无法提交跨域请求的问题"></a>通过 jsonp、cors、websocket、服务器代理来解决 ajax 无法提交跨域请求的问题</h4><ol><li>jsonp<br>jsonp 主要通过动态创建 script 标签来实现跨域请求，通过 url 执行回调函数，然后在服务器返回数据的时候，构建一个 json 的包装，这个包装就是回调函数。但是这个方法只适用于 get 请求。</li><li>cors<br>使用 cors 的方式，但是需要浏览器和服务端的同时支持。Access-Control-Allow-Origin: *</li><li>websocket<br>这个协议没有同源限制</li><li>代理<br>使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回</li></ol><h2 id="手动实现-jsonp"><a href="#手动实现-jsonp" class="headerlink" title="手动实现 jsonp"></a>手动实现 jsonp</h2><pre><code class="js">const jsonp = (&#123; url, params, callback &#125;) =&gt; &#123;    const generateUrl = () =&gt; &#123;        let dataSrc = &quot;&quot;;        for (let key in params) &#123;            if (params.hasOwnProperty(key)) &#123;                dataSrc += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`            &#125;        &#125;        dataSrc += `callback=$&#123;callback&#125;`;        return `$&#123;url&#125;?$&#123;dataSrc&#125;`;    &#125;    return new Promise((resolve, reject) =&gt; &#123;        const scriptEle = document.createElement(&quot;script&quot;);        scriptEle.src = generateUrl();        document.body.appendChild(scriptEle);        window.callback = data =&gt; &#123;            resolve(data);            document.removeChild(scriptEle);        &#125;    &#125;)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E9%97%AD%E5%8C%85/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包是指有权访问另一个函数作用域变量的函数，创建闭包的最常见方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h2><p>闭包有两个常用的用途</p><ol><li>使我们可以在函数外部可以访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以用这种方法创建私有变量。</li><li>使已经运行结束的函数上下文中的变量对象继续保留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ol><h2 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h2><p>作用域链的一个特殊引用</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h3><pre><code class="js">function outer() &#123;  var a = 1;  function inner() &#123;    console.log(a);  &#125;  inner();&#125;outer();</code></pre><h3 id="最基本的例子"><a href="#最基本的例子" class="headerlink" title="最基本的例子"></a>最基本的例子</h3><pre><code class="js">function createFunctions() &#123;  var result = new Array();  for (var i = 0; i &lt; 10; i++) &#123;    result[i] = function () &#123;      console.log(i);    &#125;;  &#125;  return result;&#125;var result = createFunctions();result[0](); // 10result[1](); // 10result[2](); // 10result[3](); // 10result[4](); // 10result[5](); // 10result[6](); // 10result[7](); // 10result[8](); // 10result[8](); // 10</code></pre><blockquote><p>因为执行 console.log(i); 后，首先 JavaScript 引擎会搜索当前函数变量对象，当前函数变量找不到 i 时，会根据作用域链找其他函数作用域中的变量，因此找到了 i 变量，此时的 i 变量保存的是 i 叠加后结果，因此是。</p></blockquote><ul><li>转换为符合预期结果的实现</li></ul><pre><code class="js">function createFunctions() &#123;  var result = new Array();  for (var i = 0; i &lt; 10; i++) &#123;    result[i] = (function (num) &#123;      return function() &#123;          console.log(num);      &#125;    &#125;)(i);  &#125;  return result;&#125;var result = createFunctions();result[0](); // 1result[1](); // 2result[2](); // 3result[3](); // 4result[4](); // 5</code></pre><h3 id="使用闭包实现每隔一秒打印-1-2-3-4"><a href="#使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="使用闭包实现每隔一秒打印 1,2,3,4"></a>使用闭包实现每隔一秒打印 1,2,3,4</h3><pre><code class="js">// 全部输出结果是 5for (var i = 0; i &lt; 5; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, i * 1000);&#125;// 使用闭包解决此问题for (var i = 0; i &lt; 5; i++) &#123;  (function (i) &#123;    setTimeout(function () &#123;      console.log(i);    &#125;, i * 1000);  &#125;)(i);&#125;// 使用 let 块级作用域for (let i = 0; i &lt; 5; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, i * 1000);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/KeepAlive/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/KeepAlive/</url>
      
        <content type="html"><![CDATA[<h2 id="keep-alive-的作用"><a href="#keep-alive-的作用" class="headerlink" title="keep-alive 的作用"></a>keep-alive 的作用</h2><p>在做组件切换的时候，保存一些组件的状态，防止多次渲染，同时也可缓存数据状态。</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>当我们使用 keep-alive 时，会额外增加两个钩子函数，activated 和 deactivated。用 keep-alive 包裹的组件在切换的时候不会进行销毁，而是缓存到内存中执行 deactivated 钩子函数，命中渲染缓存后会执行 activated 钩子函数。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从第一个元素开始，把当前元素和下一个索引元素进行比较，如果当前元素大，就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 2 的位置即可</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function bubbleSort(arr) &#123;  for (let i = arr.length - 1; i &gt; 0; i--) &#123;    for (let j = 0; j &lt; i; j++) &#123;      // 索引大的数组值大于索引小的数组值，交换      if (arr[j] &gt; arr[j + 1]) &#123;        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];      &#125;    &#125;  &#125;  return arr;&#125;</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度: O(n<sup>2</sup>)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>先将整个待排序的记录序列分割为若干子序列</li><li>分别进行直接插入排序</li><li>待整个序列中的记录基本有序时，再对全体记录进行直接插入排序</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li>[35, 33, 42, 10, 14, 19, 27, 44] 采用间隔为 4, 创建一个位于 4 个位置间隔的所有值的虚拟子列表 [35, 14] [33, 19] [42, 27] [10, 44]</li><li>比较每个子列表的值，并在原始数组中交换它们。完成此步骤后，新数组应改为 [14, 19, 27, 10, 35, 33, 42, 44]</li><li>然后采用 2 间隔，产生两个虚拟子列表 [14, 27, 35, 42] [19, 10, 33, 44]</li><li>比较并交换原始数组中的值。新数组变为 [14, 10, 27, 19, 35, 33, 42, 44]</li><li>最后，使用间隔为 1 对数组其余部分进行排序，使用插入排序对数组进行排序</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function shellSort(arr) &#123;  let gap = 1; // 间隔  let temp;  while (gap &lt; arr.length / 3) &#123;    // 动态定义间隔序列    gap = gap * 3 + 1;  &#125;  for (gap; gap &gt; 0; gap = Math.floot(gap / 3)) &#123;    for (let i = gap; i &lt; arr.length; i++) &#123;      for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;        [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];      &#125;    &#125;  &#125;  return arr;&#125;</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最佳: O(nlogn) 最差: O(nlog<sup>2</sup>n) 平均: O(nlog<sup>2</sup>n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>递归的将数组两两分开直到包含两个元素，然后将数组排序合并。最终合并为排序好的数组。</p><p>分冶思想，即将大问题拆成小问题，小问题解决后大问题自然就解决了。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>[3, 1, 2, 8, 9, 7, 6] 中间数索引为 3, 先排序数组 [3, 1, 2, 8], 继续拆分直到变为数组包含两个元素, 如果数组长度为奇数, 有一个拆分到只剩下 1 个元素。然后排序数组 [3, 1] [2, 8], 再排序 [1, 2, 3, 8], 这样左边数组就排序完毕，同理排序右边数组，最后排序左右数组合并后的结果</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">// 拆分function mergeSort(arr) &#123;  if (arr.length &lt;= 1) return arr;  let middle =  arr.length &gt;&gt; 1; // arr.length &gt;&gt; 1 等价于 Math.floot(arr.length / 2)  let left = arr.slice(0, middle);  let right = arr.slice(middle);  return merge(mergeSort(left), mergeSort(right));&#125;// 合并function merge(left, right) &#123;  const result = [];  while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123;    if (left[0] &lt;= right[0]) &#123;      result.push(left.shift());    &#125; else &#123;      result.push(right.shift());    &#125;  &#125;  return result.concat(left, right);&#125;</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>拆分数组需要 logn 步, 合并需要 n 步, 因此 O(nlogn)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第 3 个元素开始，向前对比，重复之前的操作。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function insertSort(arr) &#123;  // 外层控制循环次数  for (let i = 1; i &lt; arr.length; i++) &#123;    for (let j = i - 1; i &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123;      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];    &#125;  &#125;  return arr;&#125;</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度: O(n<sup>2</sup>)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>在冒泡排序上做了优化，减少了交换次数，首轮最大数放在第一项，一轮之后第一项就是有序的，第二轮开始选最大值放第二项，重复此操作。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值。下次遍历就可以从索引 1 开始重复上述操作。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code class="js">function selectionSort(arr) &#123;  for (let i = 0; i &lt; arr.length - 1; i++) &#123;    let minIndex = i;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;    &#125;    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];  &#125;  return arr;&#125;</code></pre><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度: O(n<sup>2</sup>)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编写 React 组件时常见的 5 个错误</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/React/%E7%BC%96%E5%86%99%20React%20%E7%BB%84%E4%BB%B6%E6%97%B6%E5%B8%B8%E8%A7%81%E7%9A%84%205%20%E4%B8%AA%E9%94%99%E8%AF%AF/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/React/%E7%BC%96%E5%86%99%20React%20%E7%BB%84%E4%BB%B6%E6%97%B6%E5%B8%B8%E8%A7%81%E7%9A%84%205%20%E4%B8%AA%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在不需要重渲染时使用-useState"><a href="#1-在不需要重渲染时使用-useState" class="headerlink" title="1. 在不需要重渲染时使用 useState"></a>1. 在不需要重渲染时使用 useState</h2><p>React 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。</p><p>使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。</p><p>关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。</p><p>这很危险❌</p><pre><code class="jsx">function ClickButton(props) &#123;  const [count, setCount] = useState(0);  const onClickCount = () =&gt; &#123;    setCount((c) =&gt; c + 1);  &#125;;  const onClickRequest = () =&gt; &#123;    apiCall(count);  &#125;;  return (    &lt;div&gt;      &lt;button onClick=&#123;onClickCount&#125;&gt;Counter&lt;/button&gt;      &lt;button onClick=&#123;onClickRequest&#125;&gt;Submit&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><h3 id="问题⚡"><a href="#问题⚡" class="headerlink" title="问题⚡"></a>问题⚡</h3><p>乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。</p><h3 id="解决方案✅"><a href="#解决方案✅" class="headerlink" title="解决方案✅"></a>解决方案✅</h3><p>如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。</p><pre><code class="jsx">function ClickButton(props) &#123;  const count = useRef(0);  const onClickCount = () =&gt; &#123;    count.current++;  &#125;;  const onClickRequest = () =&gt; &#123;    apiCall(count.current);  &#125;;  return (    &lt;div&gt;      &lt;button onClick=&#123;onClickCount&#125;&gt;Counter&lt;/button&gt;      &lt;button onClick=&#123;onClickRequest&#125;&gt;Submit&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><h2 id="2-使用-router-push-代替链接"><a href="#2-使用-router-push-代替链接" class="headerlink" title="2. 使用 router.push 代替链接"></a>2. 使用 router.push 代替链接</h2><p>这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。</p><p>假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。</p><p>所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？</p><h3 id="这很危险❌"><a href="#这很危险❌" class="headerlink" title="这很危险❌"></a>这很危险❌</h3><pre><code class="jsx">function ClickButton(props) &#123;  const history = useHistory();  const onClick = () =&gt; &#123;    history.push(&#39;/next-page&#39;);  &#125;;  return &lt;button onClick=&#123;onClick&#125;&gt;Go to next page&lt;/button&gt;;&#125;</code></pre><h3 id="问题⚡-1"><a href="#问题⚡-1" class="headerlink" title="问题⚡"></a>问题⚡</h3><p>就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。</p><h3 id="解决方案✅-1"><a href="#解决方案✅-1" class="headerlink" title="解决方案✅"></a>解决方案✅</h3><p>只要指向其他页面的链接带有某种用户交互，就要尽量用 &lt; Link&gt; 组件或常规的 &lt; a&gt; 标签处理。</p><pre><code class="jsx">function ClickButton(props) &#123;  return (    &lt;Link to=&quot;/next-page&quot;&gt;      &lt;span&gt;Go to next page&lt;/span&gt;    &lt;/Link&gt;  );&#125;</code></pre><p>优点：这也使代码更易读，更短！</p><h2 id="3-通过-useEffect-处理动作"><a href="#3-通过-useEffect-处理动作" class="headerlink" title="3. 通过 useEffect 处理动作"></a>3. 通过 useEffect 处理动作</h2><p>React 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。</p><p>想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。</p><h3 id="这很危险❌-1"><a href="#这很危险❌-1" class="headerlink" title="这很危险❌"></a>这很危险❌</h3><pre><code class="jsx">function DataList(&#123; onSuccess &#125;) &#123;  const [loading, setLoading] = useState(false);  const [error, setError] = useState(null);  const [data, setData] = useState(null);  const fetchData = useCallback(() =&gt; &#123;    setLoading(true);    callApi()      .then((res) =&gt; setData(res))      .catch((err) =&gt; setError(err))      .finally(() =&gt; setLoading(false));  &#125;, []);  useEffect(() =&gt; &#123;    fetchData();  &#125;, [fetchData]);  useEffect(() =&gt; &#123;    if (!loading &amp;&amp; !error &amp;&amp; data) &#123;      onSuccess();    &#125;  &#125;, [loading, error, data, onSuccess]);  return &lt;div&gt;Data: &#123;data&#125;&lt;/div&gt;;&#125;</code></pre><h3 id="问题⚡-2"><a href="#问题⚡-2" class="headerlink" title="问题⚡"></a>问题⚡</h3><p>一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？</p><p>对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。</p><h3 id="解决方案✅-2"><a href="#解决方案✅-2" class="headerlink" title="解决方案✅"></a>解决方案✅</h3><p>一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：</p><pre><code class="jsx">function DataList(&#123; onSuccess &#125;) &#123;  const [loading, setLoading] = useState(false);  const [error, setError] = useState(null);  const [data, setData] = useState(null);  const fetchData = useCallback(() =&gt; &#123;    setLoading(true);    callApi()      .then((fetchedData) =&gt; &#123;        setData(fetchedData);        onSuccess();      &#125;)      .catch((err) =&gt; setError(err))      .finally(() =&gt; setLoading(false));  &#125;, [onSuccess]);  useEffect(() =&gt; &#123;    fetchData();  &#125;, [fetchData]);  return &lt;div&gt;&#123;data&#125;&lt;/div&gt;;&#125;</code></pre><p>现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。</p><h2 id="4-单一责任组件"><a href="#4-单一责任组件" class="headerlink" title="4. 单一责任组件"></a>4. 单一责任组件</h2><p>组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）</p><h3 id="这很危险❌-2"><a href="#这很危险❌-2" class="headerlink" title="这很危险❌"></a>这很危险❌</h3><pre><code class="jsx">function Header(props) &#123;  return (    &lt;header&gt;      &lt;HeaderInner menuItems=&#123;menuItems&#125; /&gt;    &lt;/header&gt;  );&#125;function HeaderInner(&#123; menuItems &#125;) &#123;  return isMobile() ?         &lt;BurgerButton menuItems=&#123;menuItems&#125; /&gt; :         &lt;Tabs tabData=&#123;menuItems&#125; /&gt;;&#125;</code></pre><h3 id="问题⚡-3"><a href="#问题⚡-3" class="headerlink" title="问题⚡"></a>问题⚡</h3><p>使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。</p><h3 id="解决方案✅-3"><a href="#解决方案✅-3" class="headerlink" title="解决方案✅"></a>解决方案✅</h3><p>将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。</p><pre><code class="jsx">function Header(props) &#123;  return (    &lt;header&gt;        &#123;            isMobile() ?                 &lt;BurgerButton menuItems=&#123;menuItems&#125; /&gt; :                 &lt;Tabs tabData=&#123;menuItems&#125; /&gt;        &#125;        &lt;/header&gt;  );&#125;</code></pre><h2 id="5-单一责任的-useEffects"><a href="#5-单一责任的-useEffects" class="headerlink" title="5. 单一责任的 useEffects"></a>5. 单一责任的 useEffects</h2><p>还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。</p><p>但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）</p><h3 id="这很危险❌-3"><a href="#这很危险❌-3" class="headerlink" title="这很危险❌"></a>这很危险❌</h3><pre><code class="jsx">function Example(props) &#123;  const location = useLocation();  const fetchData = useCallback(() =&gt; &#123;    /*  Calling the api */  &#125;, []);  const updateBreadcrumbs = useCallback(() =&gt; &#123;    /* Updating the breadcrumbs*/  &#125;, []);  useEffect(() =&gt; &#123;    fetchData();    updateBreadcrumbs();  &#125;, [location.pathname, fetchData, updateBreadcrumbs]);  return (    &lt;div&gt;      &lt;BreadCrumbs /&gt;    &lt;/div&gt;  );&#125;</code></pre><h3 id="问题⚡-4"><a href="#问题⚡-4" class="headerlink" title="问题⚡"></a>问题⚡</h3><p>这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。</p><h3 id="解决方案✅-4"><a href="#解决方案✅-4" class="headerlink" title="解决方案✅"></a>解决方案✅</h3><p>把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。</p><pre><code class="jsx">function Example(props) &#123;  const location = useLocation();  const updateBreadcrumbs = useCallback(() =&gt; &#123;    /* Updating the breadcrumbs*/  &#125;, []);  useEffect(() =&gt; &#123;    updateBreadcrumbs();  &#125;, [location.pathname, updateBreadcrumbs]);  const fetchData = useCallback(() =&gt; &#123;    /*  Calling the api */  &#125;, []);  useEffect(() =&gt; &#123;    fetchData();  &#125;, [fetchData]);  return (    &lt;div&gt;      &lt;BreadCrumbs /&gt;    &lt;/div&gt;  );&#125;</code></pre><p><strong>额外的收获是</strong>，这些用例现在也在组件内按顺序排好了。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React-Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graphql 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/Graphql%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/Graphql%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-graphql"><a href="#什么是-graphql" class="headerlink" title="什么是 graphql ?"></a>什么是 graphql ?</h2><blockquote><p><code>graphql</code> 是一个用于 <code>API</code> 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时的数据（类型系统由你的数据定义）。<code>graphql</code> 并没有和任何特定数据库或者存储引擎进行绑定，而是依靠现有的代码</p></blockquote><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>一个 <code>graphql</code> 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。例如，一个 <code>graphql</code> 服务告诉我们当前登陆用户是<code>me</code>，这个用户名称可能像这样：</p></blockquote><pre><code class="graphql">type Query &#123;  me: User&#125;type User &#123;  id: ID  name: String&#125;</code></pre><blockquote><p>一并的还有每个类型上字段的解析函数</p></blockquote><pre><code class="javascript">function Query_me(request) &#123;  return request.auth.user;&#125;function User_name() &#123;  return user.getName();&#125;</code></pre><blockquote><p>一旦一个 <code>graphql</code> 服务运行起来（通常在 <code>web</code> 服务的一个 <code>URL</code> 上），它就能接收 <code>graphql</code> 查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行执行的解析函数来生成结果。</p></blockquote><pre><code class="graphql">&#123;  me &#123;    name  &#125;&#125;</code></pre><blockquote><p>会产生这样的 <code>JSON</code> 结果：</p></blockquote><pre><code class="graphql">&#123;    &quot;me&quot;: &#123;        &quot;name&quot;: &quot;Luke Skywalker&quot;    &#125;&#125;</code></pre><h2 id="查询和变更"><a href="#查询和变更" class="headerlink" title="查询和变更"></a>查询和变更</h2><h3 id="字段-Fields"><a href="#字段-Fields" class="headerlink" title="字段 Fields"></a>字段 Fields</h3><pre><code class="graphql">&#123;  hero &#123;    name  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;    &#125;  &#125;&#125;</code></pre><pre><code class="graphql">&#123;  hero &#123;    name    # 查询可以有备注！    friends &#123;      name    &#125;  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;friends&quot;: [        &#123;          &quot;name&quot;: &quot;Luke Skywalker&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Han Solo&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Leia Organa&quot;        &#125;      ]    &#125;  &#125;&#125;</code></pre><h3 id="参数-Arguements"><a href="#参数-Arguements" class="headerlink" title="参数 Arguements"></a>参数 Arguements</h3><pre><code class="graphql">&#123;  human(id: &quot;1000&quot;) &#123;    name    height  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;human&quot;: &#123;      &quot;name&quot;: &quot;Luke Skywalker&quot;,      &quot;height&quot;: 1.72    &#125;  &#125;&#125;</code></pre><pre><code class="graphql">&#123;  human(id: &quot;1000&quot;) &#123;    name    height(unit: FOOT)  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;human&quot;: &#123;      &quot;name&quot;: &quot;Luke Skywalker&quot;,      &quot;height&quot;: 5.6430448    &#125;  &#125;&#125;</code></pre><h3 id="别名-Aliases"><a href="#别名-Aliases" class="headerlink" title="别名 Aliases"></a>别名 Aliases</h3><pre><code class="graphql">&#123;  empireHero: hero(episode: EMPIRE) &#123;    name  &#125;  jediHero: hero(episode: JEDI) &#123;    name  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;empireHero&quot;: &#123;      &quot;name&quot;: &quot;Luke Skywalker&quot;    &#125;,    &quot;jediHero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;    &#125;  &#125;&#125;</code></pre><h3 id="片段-Fragments"><a href="#片段-Fragments" class="headerlink" title="片段 Fragments"></a>片段 Fragments</h3><pre><code class="graphql">&#123;  leftComparison: hero(episode: EMPIRE) &#123;    ...comparisonFields  &#125;  rightComparison: hero(episode: JEDI) &#123;    ...comparisonFields  &#125;&#125;fragment comparisonFields on Character &#123;  name  appearsIn  friends &#123;    name,    id  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;leftComparison&quot;: &#123;      &quot;name&quot;: &quot;Luke Skywalker&quot;,      &quot;appearsIn&quot;: [        &quot;NEWHOPE&quot;,        &quot;EMPIRE&quot;,        &quot;JEDI&quot;      ],      &quot;friends&quot;: [        &#123;          &quot;name&quot;: &quot;Han Solo&quot;,          &quot;id&quot;: &quot;1002&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Leia Organa&quot;,          &quot;id&quot;: &quot;1003&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;C-3PO&quot;,          &quot;id&quot;: &quot;2000&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;R2-D2&quot;,          &quot;id&quot;: &quot;2001&quot;        &#125;      ]    &#125;,    &quot;rightComparison&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;appearsIn&quot;: [        &quot;NEWHOPE&quot;,        &quot;EMPIRE&quot;,        &quot;JEDI&quot;      ],      &quot;friends&quot;: [        &#123;          &quot;name&quot;: &quot;Luke Skywalker&quot;,          &quot;id&quot;: &quot;1000&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Han Solo&quot;,          &quot;id&quot;: &quot;1002&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Leia Organa&quot;,          &quot;id&quot;: &quot;1003&quot;        &#125;      ]    &#125;  &#125;&#125;</code></pre><h4 id="在片段内使用变量"><a href="#在片段内使用变量" class="headerlink" title="在片段内使用变量"></a>在片段内使用变量</h4><pre><code class="graphql"># $first是变量，更改数值之后生成数据会有变化query HeroComparison($first: Int = 4) &#123;  leftComparison: hero(episode: EMPIRE) &#123;    ...comparisonFields  &#125;  rightComparison: hero(episode: JEDI) &#123;    ...comparisonFields  &#125;&#125;fragment comparisonFields on Character &#123;  name  friendsConnection(first: $first) &#123;    totalCount    edges &#123;      node &#123;        name      &#125;    &#125;  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;leftComparison&quot;: &#123;      &quot;name&quot;: &quot;Luke Skywalker&quot;,      &quot;friendsConnection&quot;: &#123;        &quot;totalCount&quot;: 4,        &quot;edges&quot;: [          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Han Solo&quot;            &#125;          &#125;,          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Leia Organa&quot;            &#125;          &#125;,          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;C-3PO&quot;            &#125;          &#125;,          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;R2-D2&quot;            &#125;          &#125;        ]      &#125;    &#125;,    &quot;rightComparison&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;friendsConnection&quot;: &#123;        &quot;totalCount&quot;: 3,        &quot;edges&quot;: [          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Luke Skywalker&quot;            &#125;          &#125;,          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Han Solo&quot;            &#125;          &#125;,          &#123;            &quot;node&quot;: &#123;              &quot;name&quot;: &quot;Leia Organa&quot;            &#125;          &#125;        ]      &#125;    &#125;  &#125;&#125;</code></pre><h3 id="操作名称-Operation-name"><a href="#操作名称-Operation-name" class="headerlink" title="操作名称 Operation name"></a>操作名称 Operation name</h3><pre><code class="graphql"># 示例query HeroNameAndFriends &#123;  hero &#123;    name    friends &#123;      name    &#125;  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;friends&quot;: [        &#123;          &quot;name&quot;: &quot;Luke Skywalker&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Han Solo&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Leia Organa&quot;        &#125;      ]    &#125;  &#125;&#125;</code></pre><ul><li>操作类型<ul><li><code>query</code></li><li><code>mutation</code></li><li><code>subscription</code></li></ul></li><li>操作名称</li></ul><blockquote><p>有意义和明确的名称</p></blockquote><h3 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h3><ul><li>使用变量之前，我们得做三件事</li></ul><ol><li>使用 <code>$variableName</code> 替代查询中的静态值。</li><li>声明 <code>$variableName</code> 为查询接受的变量之一。</li><li>将 <code>variableName: value</code> 通过传输专用（通常是 JSON）的分离的变量字典中。</li></ol><p>全部做完之后就像这个样子：</p><pre><code class="graphql"># &#123; &quot;graphiql&quot;: true, &quot;variables&quot;: &#123; &quot;episode&quot;: JEDI &#125; &#125;query HeroNameAndFriends($episode: Episode) &#123;  hero(episode: $episode) &#123;    name    friends &#123;      name    &#125;  &#125;&#125;</code></pre><h4 id="变量定义-Variable-definitions"><a href="#变量定义-Variable-definitions" class="headerlink" title="变量定义 Variable definitions"></a>变量定义 Variable definitions</h4><blockquote><ol><li>变量前缀必须为 <code>$</code>，后跟其类型</li><li>所有声明的变量都必须是 <em>标量_、_枚举型</em> 或者 _输入对象类型_。</li><li>变量定义可以是可选的或者必要的。上例中，<code>Episode</code> 后并没有 <code>!</code>，因此其是可选的。</li></ol></blockquote><h4 id="默认变量-Default-variables"><a href="#默认变量-Default-variables" class="headerlink" title="默认变量 Default variables"></a>默认变量 Default variables</h4><blockquote><p>可以通过在查询中的类型定义后面附带默认值的方式，将默认值赋给变量。</p></blockquote><pre><code class="graphql">query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123;  hero(episode: $episode) &#123;    name    friends &#123;      name    &#125;  &#125;&#125;</code></pre><h3 id="指令（Directives）"><a href="#指令（Directives）" class="headerlink" title="指令（Directives）"></a>指令（<code>Directives</code>）</h3><ul><li><code>@include(if: Boolean)</code> 仅在参数为 <code>true</code> 时，包含此字段。</li><li><code>@skip(if: Boolean)</code> 如果参数为 <code>true</code>，跳过此字段。</li></ul><pre><code class="graphql">query Hero($episode: Episode, $withFriends: Boolean!) &#123;  hero(episode: $episode) &#123;    name    friends @include(if: $withFriends) &#123;      name    &#125;  &#125;&#125;# 传递参数, 修改 withFriends 字段的值会生成不同的结果&#123;  &quot;episode&quot;: &quot;JEDI&quot;,  &quot;withFriends&quot;: true&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;friends&quot;: [        &#123;          &quot;name&quot;: &quot;Luke Skywalker&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Han Solo&quot;        &#125;,        &#123;          &quot;name&quot;: &quot;Leia Organa&quot;        &#125;      ]    &#125;  &#125;&#125;</code></pre><h3 id="变更（Mutations）"><a href="#变更（Mutations）" class="headerlink" title="变更（Mutations）"></a>变更（Mutations）</h3><blockquote><p><code>GraphQL</code> 的大部分讨论集中在数据获取，但是任何完整的数据平台也都需要一个改变服务端数据的方法。</p></blockquote><blockquote><p><code>REST</code> 中，任何请求都可能最后导致一些服务端副作用，但是约定上建议不要使用 <code>GET</code> 请求来修改数据。<code>GraphQL</code> 也是类似 —— 技术上而言，任何查询都可以被实现为导致数据写入。然而，建一个约定来规范任何导致写入的操作都应该显式通过变更（<code>mutation</code>）来发送。</p></blockquote><blockquote><p>就如同查询一样，如果任何变更字段返回一个对象类型，你也能请求其嵌套字段。获取一个对象变更后的新状态也是十分有用的。我们来看看一个变更例子：</p></blockquote><pre><code class="graphql">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;  createReview(episode: $ep, review: $review) &#123;    stars    commentary  &#125;&#125;# 变更的数据&#123;  &quot;ep&quot;: &quot;JEDI&quot;,  &quot;review&quot;: &#123;    &quot;stars&quot;: 5,    &quot;commentary&quot;: &quot;This is a great movie!&quot;  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;createReview&quot;: &#123;      &quot;stars&quot;: 5,      &quot;commentary&quot;: &quot;This is a great movie!&quot;    &#125;  &#125;&#125;</code></pre><blockquote><p>注意 <code>createReview</code> 字段如何返回了新建的 <code>review</code> 的 <code>stars</code> 和 <code>commentary</code> 字段。这在变更已有数据时特别有用，例如，当一个字段自增的时候，我们可以在一个请求中变更并查询这个字段的新值。</p></blockquote><blockquote><p>你也可能注意到，这个例子中，我们传递的 <code>review</code> 变量并非标量。它是一个<em>输入对象类型</em>，一种特殊的对象类型，可以作为参数传递。</p></blockquote><h4 id="变更中的多个字段（Multiple-fields-in-mutations）"><a href="#变更中的多个字段（Multiple-fields-in-mutations）" class="headerlink" title="变更中的多个字段（Multiple fields in mutations）"></a>变更中的多个字段（<code>Multiple fields in mutations</code>）</h4><blockquote><p>一个变更也能包含多个字段，一如查询。查询和变更之间名称之外的一个重要区别是：<em>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</em></p></blockquote><blockquote><p>这意味着如果我们一个请求中发送了两个 <code>incrementCredits</code> 变更，第一个保证在第二个之前执行，以确保我们不会出现竞态。</p></blockquote><h3 id="内联片段（Inline-Fragments）"><a href="#内联片段（Inline-Fragments）" class="headerlink" title="内联片段（Inline Fragments）"></a>内联片段（<code>Inline Fragments</code>）</h3><blockquote><p>如果你查询的字段返回的是接口或者联合类型，那么你可能需要使用<em>内联片段</em>来取出下层具体类型的数据：</p></blockquote><pre><code class="graphql">query HeroForEpisode($ep: Episode!) &#123;  hero(episode: $ep) &#123;    name    ... on Droid &#123;      primaryFunction    &#125;    ... on Human &#123;      height    &#125;  &#125;&#125;# 传递的变量&#123;  &quot;ep&quot;: &quot;JEDI&quot;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;hero&quot;: &#123;      &quot;name&quot;: &quot;R2-D2&quot;,      &quot;primaryFunction&quot;: &quot;Astromech&quot;    &#125;  &#125;&#125;</code></pre><blockquote><p>这个查询中，<code>hero</code> 字段返回 <code>Character</code> 类型，取决于 <code>episode</code> 参数，其可能是 <code>Human</code> 或者 <code>Droid</code> 类型。在直接选择的情况下，你只能请求 <code>Character</code> 上存在的字段，譬如 <code>name</code>。</p></blockquote><blockquote><p>如果要请求具体类型上的字段，你需要使用一个类型条件<strong>内联片段</strong>。因为第一个片段标注为 <code>... on Droid</code>，<code>primaryFunction</code> 仅在 <code>hero</code> 返回的 <code>Character</code> 为 <code>Droid</code> 类型时才会执行。同理适用于 <code>Human</code> 类型的 <code>height</code> 字段。</p></blockquote><blockquote><p>具名片段也可以用于同样的情况，因为具名片段总是附带了一个类型。</p></blockquote><h3 id="元字段（Meta-fields）"><a href="#元字段（Meta-fields）" class="headerlink" title="元字段（Meta fields）"></a>元字段（<code>Meta fields</code>）</h3><blockquote><p>某些情况下，你并不知道你将从 <code>GraphQL</code> 服务获得什么类型，这时候你就需要一些方法在客户端来决定如何处理这些数据。<code>GraphQL</code> 允许你在查询的任何位置请求 <code>__typename</code>，一个元字段，以获得那个位置的对象类型名称。</p></blockquote><pre><code class="graphql">&#123;  search(text: &quot;an&quot;) &#123;    __typename    ... on Human &#123;      name    &#125;    ... on Droid &#123;      name    &#125;    ... on Starship &#123;      name    &#125;  &#125;&#125;# 生成&#123;  &quot;data&quot;: &#123;    &quot;search&quot;: [      &#123;        &quot;__typename&quot;: &quot;Human&quot;,        &quot;name&quot;: &quot;Han Solo&quot;      &#125;,      &#123;        &quot;__typename&quot;: &quot;Human&quot;,        &quot;name&quot;: &quot;Leia Organa&quot;      &#125;,      &#123;        &quot;__typename&quot;: &quot;Starship&quot;,        &quot;name&quot;: &quot;TIE Advanced x1&quot;      &#125;    ]  &#125;&#125;</code></pre><blockquote><p>上面的查询中，<code>search</code> 返回了一个联合类型，其可能是三种选项之一。没有 <code>__typename</code> 字段的情况下，几乎不可能在客户端分辨开这三个不同的类型。</p></blockquote><blockquote><p><code>GraphQL</code> 服务提供了不少元字段，剩下的部分用于描述 <a href="https://graphql.cn/learn/introspection/" target="_blank" rel="noopener external nofollow noreferrer">内省</a> 系统</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> NodeJS </category>
          
          <category> Graphql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/Mongodb%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/Mongodb%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p><code>mongodb</code> 是一种非关系型数据库，不必写 <code>sql</code> 语句，其操作类似于 <code>json</code> ，方便后端工作者进行开发。</p><p><code>mongoose</code> 是一种 <code>mongodb</code> 的 <code>orm</code> 框架，方便操作和使用，其中，<code>Schema</code> 是关键。</p><h2 id="一、常用命令："><a href="#一、常用命令：" class="headerlink" title="一、常用命令："></a>一、常用命令：</h2><table><thead><tr><th>常用命令</th><th>介绍</th></tr></thead><tbody><tr><td><code>show dbs</code></td><td>显示数据库列表</td></tr><tr><td><code>show collections</code></td><td>显示当前数据库中的集合（类似数据库中的表）</td></tr><tr><td><code>show users</code></td><td>显示用户</td></tr><tr><td><code>use &lt;db name&gt;</code></td><td>切换/创建当前数据库</td></tr><tr><td><code>db.help()</code></td><td>显示数据库操作命令</td></tr><tr><td><code>db.dropDatabase()</code></td><td>删除当前使用数据库</td></tr><tr><td><code>db.createCollection()</code></td><td>创建一个集合(表)</td></tr><tr><td><code>db/db.getName()</code></td><td>查看当前所在数据库</td></tr><tr><td><code>db.user.findOne()</code></td><td>查询第一条数据</td></tr><tr><td><code>load()</code></td><td>加载文件</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="1-find-查找"><a href="#1-find-查找" class="headerlink" title="1. find 查找"></a>1. find 查找</h3><blockquote><p><code>@params: [条件，指定打印字段的名称]</code></p></blockquote><ul><li>查找 【<code>age &gt;= 20</code> 并且 <code>age &lt;= 30</code> 的】数据</li></ul><pre><code class="javascript">db.user.find(  &#123;    age: &#123;      $gte: 20,      $lte: 30    &#125;  &#125;,  &#123;    name: true,    age: true,    _id: false  &#125;);</code></pre><ul><li>查找【21 岁 和 10 岁的】数据</li></ul><pre><code class="javascript">db.user.find(  &#123;    age: &#123;      $in: [21, 10]    &#125;  &#125;,  &#123;    name: true,    age: true,    _id: false  &#125;);</code></pre><ul><li>查找 【 要么 <code>age &lt;= 10</code>，要么 <code>pc.brand = &#39;IBM&#39;</code> 】的数据</li></ul><blockquote><p>与或非：<code>$and, $or, $not</code></p></blockquote><pre><code class="javascript">db.user.find(  &#123;    $or: [(age: &#123; $lte: 10, &quot;pc.brand&quot;: &quot;IBM&quot; &#125;)]  &#125;,  &#123; name: true, age: true, _id: false &#125;);</code></pre><ul><li>数组查询：查找【喜欢篮球和敲代码的】数据</li></ul><blockquote><p><code>$all</code>：全部满足查询，<code>$in</code>：满足任意一个条件查询，<code>$size</code>：根据个数查询</p></blockquote><pre><code class="javascript">db.user.find(  &#123;    hobby: &#123; $all: [&quot;篮球&quot;, &quot;敲代码&quot;] &#125;  &#125;,  &#123; name: true, age: true, _id: false &#125;);</code></pre><ul><li>分页查询：</li></ul><blockquote><p><code>limit</code>：每次查询几条，<code>skip</code>：从第几条开始，<code>sort</code>：排序方式(-1：降序，1：升序)</p></blockquote><pre><code class="javascript">db.user.find(&#123;&#125;, &#123; name: true, age: true, _id: false &#125;).limit(1).skip(0).sort(&#123; age: -1 &#125;);</code></pre><ul><li>逐条打印 <code>forEach</code></li></ul><pre><code class="javascript">var db = connect(&quot;me&quot;);var userlist = db.user.find();userlist.forEach(user =&gt; &#123;  /** 业务逻辑处理 if else */  printjson(user);&#125;);</code></pre><h3 id="2-update-更新"><a href="#2-update-更新" class="headerlink" title="2. update 更新"></a>2. update 更新</h3><blockquote><p><code>db.user.update(条件, 方法)</code></p></blockquote><ul><li><code>$inc</code>：进行加减操作</li><li><code>$set</code>：修改一个指定的<code>key</code>值</li></ul><pre><code class="javascript">//    修改数组中的某个元素的值db.user.update(&#123; name: &quot;xiaofeng&quot; &#125;, &#123; $set: &#123; &quot;age.0&quot;: 40 &#125; &#125;);</code></pre><ul><li><code>$unset</code> ：删除一个<code>key</code>值和对应的<code>value</code>值</li><li><code>upsert</code> ： 如果当前找不到这个值， 那么就插入这个值</li></ul><pre><code class="javascript">db.user.update(&#123; name: &quot;xiaofeng&quot; &#125;, &#123; $set: &#123; age: 10 &#125; &#125;, &#123; upsert: true &#125;);</code></pre><ul><li><code>multi</code>：给所有数据都增加属性 如果为<code>false</code>或者不加那么只有第一条数据会加</li></ul><pre><code class="javascript">db.user.update(&#123;&#125;, &#123; $set: &#123; hobby: [] &#125; &#125;, &#123; multi: true &#125;);</code></pre><ul><li><code>$push</code>：给数组字段里增加一个新的元素</li></ul><pre><code class="javascript">db.user.update(&#123; name: &quot;xiaowu&quot; &#125;, &#123; $push: &#123; hobby: &quot;吃鸡&quot; &#125; &#125;);</code></pre><ul><li><code>$addToSet</code> ： 查找是否存在，如果不存在则<code>push</code>进去，如果存在则不<code>push</code></li><li><code>$each</code>：在数组中插入多个元素</li></ul><pre><code class="javascript">//    在数组中插入多个元素var newHobby = [&quot;鸡&quot;, &quot;鸭&quot;, &quot;鹅&quot;];db.user.update(&#123; name: &quot;wxq&quot; &#125;, &#123; $addToSet: &#123; hobby: &#123; $each: newHobby &#125; &#125; &#125;);</code></pre><ul><li><code>findAndModify</code> ： 有返回值，可以根据返回值来进行逻辑处理</li></ul><pre><code class="javascript">//    应答式的修改方法var modify = &#123;  findAndModify: &quot;user&quot;,  query: &#123; name: &quot;wxq&quot; &#125;,  update: &#123; $set: &#123; age: 21 &#125; &#125;,  new: true //    true：返回修改之后的值，false：返回修改之前的值&#125;;var result = db.runCommand(modify);printjson(result);</code></pre><h3 id="3-插入-insert"><a href="#3-插入-insert" class="headerlink" title="3. 插入 insert"></a>3. 插入 insert</h3><blockquote><p>使用<code>insert()</code>或<code>save()</code>方法向集合中插入文档。如果不指定<code>_id</code>字段，<code>save()</code>方法类似<code>insert()</code>方法；如果指定<code>_id</code>字段，则会更新该<code>_id</code>的数据。</p></blockquote><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h3><blockquote><pre><code class="javascript">db.collection.drop();</code></pre></blockquote><pre><code>### 索引&gt; 建立索引可以提高查询效率，不是所有的情况都要建立索引；&gt; 当频繁查询数据时常用。- 建立索引：```javascriptdb.tel.ensureIndex(&#123;tel: 1&#125;)</code></pre><ul><li>获取索引：</li></ul><pre><code class="javascript">db.tel.getIndexes();</code></pre><ul><li>删除索引：</li></ul><pre><code class="javascript">db.tel.dropIndex(&#123; tel: 1 &#125;);</code></pre><h2 id="二、mongoose"><a href="#二、mongoose" class="headerlink" title="二、mongoose"></a>二、mongoose</h2><blockquote><p><strong>介绍：</strong><code>Mongoose</code>是<code>MongoDB</code>的一个对象模型工具，是基于<code>node-mongodb-native</code>开发的<code>MongoDB nodejs</code>驱动，可以在<strong>异步的环境下执行</strong>。同时它也是针对<code>MongoDB</code>操作的一个对象模型库，封装了<code>MongoDB</code>对文档的的一些增删改查等常用方法，让<code>NodeJS</code>操作<code>Mongodb</code>数据库变得更加<strong>灵活简单</strong>。</p></blockquote><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><blockquote><p><code>npm install mongoose</code></p></blockquote><h3 id="2、数据库连接"><a href="#2、数据库连接" class="headerlink" title="2、数据库连接"></a>2、数据库连接</h3><pre><code class="javascript">// 初始化mongooseconst mongoose = require(&quot;mongoose&quot;);const db = &quot;mongodb://localhost/shop&quot;;exports.connect = () =&gt; &#123;  // 连接数据库  mongoose.connect(db, &#123;    useNewUrlParser: true // 解析url  &#125;);  // 监听数据库连接  mongoose.connection.on(&quot;disconnected&quot;, () =&gt; &#123;    mongoose.connect(db);  &#125;);  // 数据库出错  mongoose.connection.on(&quot;error&quot;, error =&gt; &#123;    console.log(error);    mongoose.connect(db);  &#125;);  // 连接的时候  mongoose.connection.once(&quot;open&quot;, () =&gt; &#123;    console.log(&quot;mongoodb connected success&quot;);  &#125;);&#125;;</code></pre><h3 id="3、Schema"><a href="#3、Schema" class="headerlink" title="3、Schema"></a>3、Schema</h3><h4 id="3-1-定义一个-Schema"><a href="#3-1-定义一个-Schema" class="headerlink" title="3.1 定义一个 Schema"></a>3.1 定义一个 Schema</h4><blockquote><p><strong>介绍</strong>：数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p></blockquote><pre><code class="javascript">var mongoose = require(&quot;mongoose&quot;);var TestSchema = new mongoose.Schema(&#123;  name: &#123; type: String, unique: true &#125;, // unique: true代表当前用户名是唯一的  age: &#123; type: Number, default: 18 &#125;,  gender: &#123; type: Boolean, default: true &#125;&#125;);</code></pre><h4 id="3-2-Model"><a href="#3-2-Model" class="headerlink" title="3.2 Model"></a>3.2 Model</h4><blockquote><p><strong>介绍</strong>：由<code>Schema</code>构造生成的模型，除了<code>Schema</code>定义的数据库骨架以外，还具有数据库操作行为，类似于管理数据库属性、行为的类<br>创建<code>Model</code>模型，需要指定：<strong>1.集合名称，2.集合的<code>Schema</code>结构对象</strong></p></blockquote><pre><code class="javascript">// 创建Modelvar TestModel = mongoose.model(&quot;test1&quot;, TestSchema);</code></pre><blockquote><p><code>test1</code>：数据库中的集合名称，当我们对其添加数据时如果<code>test1</code>已经存在，则会保存到其目录下，如果未存在，则会创建<code>test1</code>集合，然后在保存数据。</p></blockquote><h4 id="3-3-Entity"><a href="#3-3-Entity" class="headerlink" title="3.3 Entity"></a>3.3 Entity</h4><blockquote><p><strong>介绍</strong>：由<code>Model</code>创建的实体，使用<code>save</code>方法保存数据，<code>Model</code>和<code>Entity</code>都有能影响数据库的操作，但<code>Model</code>比<code>Entity</code>更具操作性。</p></blockquote><pre><code class="javascript">// 创建Entityvar TestEntity = new TestModel(&#123;  name: &quot;Lenka&quot;,  age: 36,  email: &quot;lenka@qq.com&quot;&#125;);console.log(TestEntity.name); // Lenkaconsole.log(TestEntity.age); // 36</code></pre><h4 id="3-4-创建集合"><a href="#3-4-创建集合" class="headerlink" title="3.4 创建集合"></a>3.4 创建集合</h4><pre><code class="javascript">var mongoose = require(&quot;mongoose&quot;);mongoose.connect(&quot;mongodb://127.0.0.1:27017/test&quot;);mongoose.connection.on(&quot;connected&quot;, function () &#123;  console.log(&quot;yes&quot;);&#125;);var TestSchema = new mongoose.Schema(&#123;  name: &#123; type: String &#125;,  age: &#123; type: Number, default: 0 &#125;,  email: &#123; type: String &#125;,  time: &#123; type: Date, defaultL: Date.now &#125;&#125;);var TestModel = mongoose.model(&quot;test1&quot;, TestSchema);var TestEntity = new TestModel(&#123;  name: &quot;zs&quot;,  age: 20,  email: &quot;aa@bb.com&quot;&#125;);TestEntity.save(function (error, doc) &#123;  if (error) &#123;    console.log(&quot;error:&quot; + error);  &#125; else &#123;    console.log(doc);  &#125;&#125;);</code></pre><h3 id="4、操作"><a href="#4、操作" class="headerlink" title="4、操作"></a>4、操作</h3><h4 id="4-1-查询"><a href="#4-1-查询" class="headerlink" title="4.1 查询"></a>4.1 查询</h4><h5 id="4-1-1-find-基本查询"><a href="#4-1-1-find-基本查询" class="headerlink" title="4.1.1 find 基本查询"></a>4.1.1 find 基本查询</h5><blockquote><p><code>obj.find(查询条件, callback)</code></p></blockquote><h5 id="4-1-2-find-过滤查询"><a href="#4-1-2-find-过滤查询" class="headerlink" title="4.1.2 find 过滤查询"></a>4.1.2 find 过滤查询</h5><ul><li>属性过滤&gt; <code>find(Conditions, field, callback)</code>，其中<code>field</code>省略或者设置为<code>null</code>，则返回所有属性</li></ul><h5 id="4-1-3-单条数据查询"><a href="#4-1-3-单条数据查询" class="headerlink" title="4.1.3 单条数据查询"></a>4.1.3 单条数据查询</h5><ul><li><code>findOne</code></li></ul><blockquote><p><code>findOne(Conditions, callback)</code>，注意：只返回第一个符合条件的文档数据</p></blockquote><ul><li><code>findById</code>&gt; <code>findById(_id, callback)</code>，注意：只接受文档的<code>_id</code>作为参数</li></ul><h4 id="4-2-Model-保存"><a href="#4-2-Model-保存" class="headerlink" title="4.2 Model 保存"></a>4.2 Model 保存</h4><ul><li><code>Model.create(文档数据, callback)</code></li></ul><h4 id="4-3-entity-保存"><a href="#4-3-entity-保存" class="headerlink" title="4.3 entity 保存"></a>4.3 entity 保存</h4><pre><code class="javascript">var Entity = new Model(&#123; name: &quot;zs&quot;, age: 27 &#125;);Entity.save(function (error, doc) &#123;  if (error) &#123;    console.log(error);  &#125; else &#123;    console.log(doc);  &#125;&#125;);</code></pre><h4 id="4-4-数据更新"><a href="#4-4-数据更新" class="headerlink" title="4.4 数据更新"></a>4.4 数据更新</h4><ul><li><code>obj.update(查询条件, 更新对象, callback)</code></li></ul><h4 id="4-5-数据删除"><a href="#4-5-数据删除" class="headerlink" title="4.5 数据删除"></a>4.5 数据删除</h4><ul><li><code>obj.remove(查询条件, callback)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> NodeJS </category>
          
          <category> Mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传统部署</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/%E4%BC%A0%E7%BB%9F%E9%83%A8%E7%BD%B2/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/%E4%BC%A0%E7%BB%9F%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote><p>node.js + mongodb 的 传统线上部署</p></blockquote><h3 id="1-远程链接服务器和下载-Xftp"><a href="#1-远程链接服务器和下载-Xftp" class="headerlink" title="1.远程链接服务器和下载 Xftp"></a>1.远程链接服务器和下载 Xftp</h3><ul><li><code>xftp</code></li></ul><blockquote><p>用于部署好之后将本地写好的程序上传到云服务器</p></blockquote><h3 id="2-使用-yum-或-wget-安装-node-js-环境"><a href="#2-使用-yum-或-wget-安装-node-js-环境" class="headerlink" title="2.使用 yum 或 wget 安装 node.js 环境"></a>2.使用 yum 或 wget 安装 node.js 环境</h3><ul><li><code>wget</code>安装</li></ul><blockquote><ol><li><code>cd /usr/src</code></li><li><code>wget http://nodejs.org/dist/v10.4.1/node-v10.4.1.tar.gz</code></li><li>解压：<code>tar zxf node-v10.4.1.tar.gz</code></li><li><code>cd ./node-v10.4.1</code></li><li>执行配置脚本来进行编译预处理:：<code>./configure</code></li><li>编译源代码：<code>make</code>(耗时比较长)</li><li><code>make install</code></li></ol></blockquote><h3 id="3-安装-pm2"><a href="#3-安装-pm2" class="headerlink" title="3.安装 pm2"></a>3.安装 pm2</h3><ul><li><code>pm2</code>：</li></ul><blockquote><p><code>PM2</code> 是 <code>node</code> 进程管理工具，可以利用它来简化很多 <code>node</code><a href="https://www.baidu.com/s?wd=%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener external nofollow noreferrer">应用管理</a>的繁琐任务，如性能监控、自动重启、负载均衡等。</p></blockquote><ul><li><p>在项目目录中启动：<code>pm2 start app.js --name app</code></p></li><li><p>查看：<code>pm2 ls 或 pm2 list</code></p></li><li><p>删除一个进程：<code>pm2 delete app</code></p></li><li><p>重启：<code>pm2 restart app</code></p></li><li><p>停止所有：<code>pm2 stop all</code></p></li><li><p>查看所有进程状态：<code>pm2 status</code></p></li><li><p>安装：<code>npm -g install pm2</code></p></li></ul><h3 id="4-安装-mongodb"><a href="#4-安装-mongodb" class="headerlink" title="4.安装 mongodb"></a>4.安装 mongodb</h3><ol><li><code>cd /usr/local</code></li><li><code>wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.4.tgz</code></li><li>解压：<code>tar zxvf mongodb-linux-x86_64-4.0.4.tgz</code></li><li>重命名：<code>mv mongodb-linux-x86_64-4.0.4 mongodb</code></li><li>配置环境变量：<code>vim /etc/profile</code></li></ol><blockquote><p>在 <code>export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL</code> 一行的上面添加如下内容:<br><code>export PATH=/usr/mongodb/bin:$PATH</code></p></blockquote><ol start="6"><li><code>cd ~</code> <code>source /etc/profile</code></li><li>创建数据库目录：</li></ol><pre><code class="bash">cd /usr/local/mongodbtouch mongodb.confmkdir dbmkdir logcd logtouch mongodb.log</code></pre><ol start="8"><li>修改<code>mongodb</code>配置文件</li></ol><p><code>vim /usr/mongodb/mongodb.conf</code></p><pre><code class="nginx">port=27017 #端口dbpath= /usr/local/mongodb/db #数据库存文件存放目录logpath= /usr/local/mongodb/log/mongodb.log #日志文件存放路径logappend=true #使用追加的方式写日志fork=true #以守护进程的方式运行，创建服务器进程maxConns=100 #最大同时连接数#noauth=true #不启用验证journal=true #每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。#即使宕机，启动时wiredtiger会先将数据恢复到最近一次的checkpoint点，然后重放后续的journal日志来恢复。storageEngine=wiredTiger  #存储引擎有mmapv1、wiretiger、mongorocksbind_ip = 0.0.0.0  #这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB</code></pre><ol start="9"><li>设置文件夹权限：</li></ol><pre><code class="bash">cd /usr/mongodbchmod 777 dbchmod 777 log</code></pre><ol start="10"><li>启动<code>mongodb</code></li></ol><pre><code class="bash">cd ~mongod --config /usr/local/mongodb/mongodb.conf</code></pre><ol start="11"><li>查看<code>pid</code></li></ol><pre><code class="bash">ps aux |grep mongodb</code></pre><ol start="12"><li>关闭数据库</li></ol><pre><code class="bash">sudo kill 5314</code></pre><h3 id="5-安装-nginx"><a href="#5-安装-nginx" class="headerlink" title="5.安装 nginx"></a>5.安装 nginx</h3><ul><li>安装依赖</li></ul><pre><code class="bash"> yum install gcc-c++ yum -y install zlib zlib-devel openssl openssl--devel pcre pcre-devel</code></pre><pre><code class="bash"> yum install nginx -y</code></pre><ul><li>反向代理设置：</li></ul><ol><li><code>cd /etc/nginx</code></li><li><code>vim nginx.conf</code></li><li>找到 <code>server</code></li><li>把默认配置的 <code>listen</code> 改掉，保留其中一个监听 <code>80</code> 端口；然后多加一个 <code>server</code> 选项：</li><li>在添加 <code>server</code> 的里写上配置：</li></ol><pre><code class="nginx">server &#123;  listen 80;  server_name conjuring.cn;  location / &#123;    proxy_pass http://39.98.208.91:3000;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header Host $http_host;    proxy_set_header X-Nginx-Proxy true;    proxy_redirect off;  &#125;&#125;# proxy_pass 对应的是项目运行原本带有端口的 iP 地址，# server_name 是映射 proxy_pass 地址的新的地址。</code></pre><ul><li>重启 <code>nginx</code></li></ul><pre><code class="bash">nginx -s reload</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> NodeJS </category>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa 的使用</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/Koa%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs/Koa%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>官网：<a href="https://koa.bootcss.com/" target="_blank" rel="noopener external nofollow noreferrer">https://koa.bootcss.com/</a><br>注意：<code>koa2</code>依赖 <code>node v7.6.0</code> 或 <code>ES2015</code> 及更高版本和 <code>async</code>方法支持</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><code>$ npm install koa --save</code></p></blockquote><h2 id="启动服务："><a href="#启动服务：" class="headerlink" title="启动服务："></a>启动服务：</h2><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();app.use(async ctx =&gt; &#123;  ctx.body = &quot;Hello World&quot;;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><h2 id="get-post-请求"><a href="#get-post-请求" class="headerlink" title="get/post 请求"></a>get/post 请求</h2><ul><li>get</li></ul><blockquote><p>明文传递，传输体积小，因为在请求头里面</p></blockquote><blockquote><p><code>query</code>：返回格式化好的参数对象<br><code>queryString</code>：返回请求字符串</p></blockquote><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();app.use(async ctx =&gt; &#123;  let url = ctx.url;  let qyery = ctx.query;  let queryString = ctx.queryString;  ctx.body = &#123;    url,    qyery,    qyeryString  &#125;;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><ul><li>post</li></ul><blockquote><p>密文传递，传输体积大，因为在请求包体里面</p></blockquote><ul><li>方式 1：不用中间件</li></ul><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();app.use(async ctx =&gt; &#123;  // 叠加数据  let data = &quot;&quot;;  // 监听data事件，收到表单的数据的时候就会执行  ctx.req.on(&quot;data&quot;, chunk =&gt; &#123;    data += chunk; // 二进制  &#125;);  //    接受表单提交数据完成之后  ctx.req.on(&quot;end&quot;, () =&gt; &#123;    data = decodeURI(data);    console.log(data);  &#125;);  ctx.body = &quot;123&quot;;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><ul><li>方式 2：<code>koa-bodyparser</code>中间件</li></ul><blockquote><p>安装：<code>$ npm install koa-bodyparser --save</code></p></blockquote><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();const bodyparser = require(&quot;koa-bodyparser&quot;);app.use(bodyparser());app.use(async ctx =&gt; &#123;  let data = ctx.request.body;  ctx.body = data;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><h2 id="路由-koa-router"><a href="#路由-koa-router" class="headerlink" title="路由 koa-router"></a>路由 koa-router</h2><blockquote><p>安装：<code>$ npm install koa-router --save</code></p></blockquote><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();const Router = require(&quot;koa-router&quot;);const router = new Router(&#123;  prefix: &quot;/api&quot; // 设置前缀&#125;);router.get(&quot;/abc&quot;, (ctx, next) =&gt; &#123;  ctx.body = ctx.query;&#125;);app.use(router.routes());// 这里对应get方法，如果发送了post，则会报错；即只允许特定方法进行请求app.use(router.allowedMothods());app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();const Router = require(&quot;koa-router&quot;);const router = new Router();// MVC模式 即导入控制器下的方法let user = require(&quot;./controller/user.js&quot;);// &#39;/user&#39;代表控制器名称，必须和请求的地址相对应router.use(&quot;/user&quot;, user.routes());app.use(router.routes());// 这里对应get方法，如果发送了post，则会报错；即只允许特定方法进行请求app.use(router.allowedMothods());app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><table><thead><tr><th>字段名</th><th>说明</th></tr></thead><tbody><tr><td><code>maxAge</code></td><td>一个数字表示从 <code>Date.now()</code> 得到的毫秒数</td></tr><tr><td><code>signed</code></td><td><code>cookie</code> 签名值</td></tr><tr><td><code>expires</code></td><td><code>cookie</code> 过期的 <code>Date</code></td></tr><tr><td><code>path</code></td><td><code>Cookie</code> 路径，默认是 &#39;<code>/</code>&#39;</td></tr><tr><td><code>domain</code></td><td><code>cookie</code> 域名</td></tr><tr><td><code>secure</code></td><td>安全 <code>cookie</code></td></tr><tr><td><code>httponly</code></td><td>服务器可访问 <code>cookie</code>, 默认是 <code>true</code></td></tr><tr><td><code>overwrite</code></td><td>一个布尔值，表示是否覆盖以前设置的同名的 <code>cookie</code>（默认是 <code>false</code>）,如果是 <code>true</code>,在同一个请求中设置相同名称的所有 <code>Cookie</code>（不管路径或域）是否在设置此 <code>Cookie</code> 时从 <code>Set-Cookie</code> 标头中过滤掉</td></tr></tbody></table><pre><code class="javascript">const Koa = require(&quot;koa&quot;);const app = new Koa();app.use(async ctx =&gt; &#123;  if (ctx.url == &quot;/weichuang&quot;) &#123;    //    设置cookie：set，获取cookie：get    ctx.cookies.set(&quot;name&quot;, &quot;weichang&quot;, &#123;      domain: &quot;localhost&quot;,      path: &quot;/weichuang&quot;,      maxAge: 24 * 60 * 60 * 1000,      expires: new Date(&quot;2019-12-31&quot;),      httpOnly: false,      overwrite: false    &#125;);    ctx.body = &quot;cookie success&quot;;  &#125; else &#123;    ctx.body = &quot;no cookie&quot;;  &#125;&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;服务开启成功&quot;);&#125;);</code></pre><h2 id="ejs-模板引擎"><a href="#ejs-模板引擎" class="headerlink" title="ejs 模板引擎"></a>ejs 模板引擎</h2><blockquote><p>安装：<code>$ npm install ejs --save</code><br>中间件<code>koa-view</code>：<code>$ npm install koa-view --save</code></p></blockquote><pre><code class="javascript">// index.ejs&lt;h1&gt;&lt;%=title%&gt;&lt;/h1&gt;&lt;ul&gt;   &lt;%       for(let i = 0; i &lt; list.length; i++) &#123;   %&gt;    &lt;li&gt;      &lt;%=list[i].name%&gt; -- &lt;%=list[i].age%&gt;    &lt;/li&gt;   &lt;%       &#125;   %&gt;&lt;/ul&gt;// app.jsconst Koa = require(&#39;koa&#39;)const app = new Koa()const views = require(&#39;koa-views&#39;)const path = require(&#39;path&#39;)// 加载模板app.use(views(path.join(__dirname, &#39;./views&#39;), &#123;   extension: &#39;ejs&#39;&#125;))app.use(async ctx =&gt; &#123;   let title = &#39;hello&#39;;   await ctx.render(&#39;index&#39;, &#123;       title,       list: [           &#123;name: &#39;a&#39;, age: 0&#125;,           &#123;name: &#39;a1&#39;, age: 1&#125;,           &#123;name: &#39;a2&#39;, age: 2&#125;,           &#123;name: &#39;a3&#39;, age: 3&#125;       ]   &#125;)&#125;)app.listen(3000, () =&gt; &#123;   console.log(&#39;服务开启成功&#39;)&#125;)</code></pre><h2 id="cors-跨域"><a href="#cors-跨域" class="headerlink" title="cors 跨域"></a>cors 跨域</h2><blockquote><p>安装：<code>$ npm install koa2-cors --save</code></p></blockquote><pre><code class="javascript">//解决跨域const cors = require(&quot;koa2-cors&quot;);app.use(  cors(&#123;    origin: [&quot;http://localhost:8080&quot;],    // 配置证书    credentials: true  &#125;));</code></pre><h2 id="加盐加密"><a href="#加盐加密" class="headerlink" title="加盐加密"></a>加盐加密</h2><blockquote><p>安装：<code>$ npm install bcrypt --save</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> NodeJS </category>
          
          <category> Koa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jaxu/p/11338294.html" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-检测是否为字符串"><a href="#1-检测是否为字符串" class="headerlink" title="1. 检测是否为字符串"></a>1. 检测是否为字符串</h2><h2 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h2><h3 id="2-1-字符串切片"><a href="#2-1-字符串切片" class="headerlink" title="2.1 字符串切片"></a>2.1 字符串切片</h3><ul><li>substring</li></ul><blockquote><p>用法: [start, end)<br>是否改变原字符串：否</p></blockquote><ul><li>substr</li></ul><blockquote><p>用法: [start, length]，参数可以为<em>负数</em><br>是否改变原字符串：否</p></blockquote><ul><li>slice</li></ul><blockquote><p>用法: [start, end)，参数可以为<em>负数</em><br>是否改变原字符串：否</p></blockquote><h3 id="2-2-字符串转换数组"><a href="#2-2-字符串转换数组" class="headerlink" title="2.2 字符串转换数组"></a>2.2 字符串转换数组</h3><ul><li>split</li></ul><blockquote><p>用法: [字符串/正则/空, 分割片段数量)<br>是否改变原字符串：否</p></blockquote><h3 id="2-3-修改替换字符串"><a href="#2-3-修改替换字符串" class="headerlink" title="2.3 修改替换字符串"></a>2.3 修改替换字符串</h3><ul><li>replace</li></ul><blockquote><p>用法: [字符串/正则, 替换的文本/生成替换文本的函数]<br>是否改变原字符串：否</p></blockquote><h2 id="3-查找字符串"><a href="#3-查找字符串" class="headerlink" title="3. 查找字符串"></a>3. 查找字符串</h2><ul><li>indexOf</li></ul><blockquote><p>用法: [字符, 开始查找的位置]<br>返回: 索引值</p></blockquote><ul><li>includes</li></ul><blockquote><p>用法: [字符, 开始查找的位置]<br>返回: ture / false</p></blockquote><ul><li>search</li></ul><blockquote><p>作用: 用于检索字符串中指定的子字符串，或检索与正则相匹配的子字符串<br>用法: [要搜索的子串/正则]<br>返回: 第一个匹配的子字符串的起始位置</p></blockquote><ul><li>match</li></ul><blockquote><p>作用: 在字符串内检索指定的值，或找到一个或多个正则表达式的匹配<br>用法: [要匹配的子串/正则]<br>返回: 数组[匹配文本, 索引值, 原始字符串]</p></blockquote><h2 id="4-大小写转换"><a href="#4-大小写转换" class="headerlink" title="4. 大小写转换"></a>4. 大小写转换</h2><ul><li>toLowerCase</li></ul><blockquote><p>作用: 大写转小写</p></blockquote><ul><li>toUpperCase</li></ul><blockquote><p>作用: 小写转大写</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>外边距合并问题</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jaxu/p/11302315.html" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 字典和散列表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-检测是否为数组"><a href="#1-检测是否为数组" class="headerlink" title="1. 检测是否为数组"></a>1. 检测是否为数组</h2><h2 id="2-操作数组方法-不改变原数组"><a href="#2-操作数组方法-不改变原数组" class="headerlink" title="2. 操作数组方法 - 不改变原数组"></a>2. 操作数组方法 - 不改变原数组</h2><h3 id="2-1-拼接两个数组"><a href="#2-1-拼接两个数组" class="headerlink" title="2.1 拼接两个数组"></a>2.1 拼接两个数组</h3><ul><li>concat</li></ul><h3 id="2-2-数组转字符串"><a href="#2-2-数组转字符串" class="headerlink" title="2.2 数组转字符串"></a>2.2 数组转字符串</h3><ul><li>join</li></ul><blockquote><p>参数: 分割符</p></blockquote><ul><li>toString</li></ul><h3 id="2-3-数组切片"><a href="#2-3-数组切片" class="headerlink" title="2.3 数组切片"></a>2.3 数组切片</h3><ul><li>slice</li></ul><blockquote><p>用法: [start, end)，参数可以为<em>负数</em></p></blockquote><h3 id="2-4-获取数组对象的原始值"><a href="#2-4-获取数组对象的原始值" class="headerlink" title="2.4 获取数组对象的原始值"></a>2.4 获取数组对象的原始值</h3><ul><li>valueOf</li></ul><h2 id="3-操作数组方法-改变原数组"><a href="#3-操作数组方法-改变原数组" class="headerlink" title="3. 操作数组方法 - 改变原数组"></a>3. 操作数组方法 - 改变原数组</h2><h3 id="3-1-删除"><a href="#3-1-删除" class="headerlink" title="3.1 删除"></a>3.1 删除</h3><ul><li>pop</li></ul><blockquote><p>作用: 删除并返回数组的最后一个元素</p></blockquote><ul><li>shift</li></ul><blockquote><p>作用: 删除并返回数组的第一个元素</p></blockquote><ul><li>splice</li></ul><blockquote><p>作用: 删除指定位置的元素<br>用法: splice(位置索引, 删除的数量)<br>注意: 如果只传第一个参数，则删除该索引开始之后的所有元素</p></blockquote><h3 id="3-2-添加"><a href="#3-2-添加" class="headerlink" title="3.2 添加"></a>3.2 添加</h3><ul><li>push</li></ul><blockquote><p>作用：向数组的末尾添加一个或多个元素。改变原数组，返回新的长度</p></blockquote><ul><li>unshift</li></ul><blockquote><p>作用: 向数组的开头添加一个或更多元素。改变原数组，返回新的长度</p></blockquote><ul><li>splice</li></ul><blockquote><p>作用: 在指定位置添加元素<br>用法: splice(位置索引, 删除的数量, 添加的新项目)<br>注意: 如果删除了元素，则会改变原数组</p></blockquote><h3 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3 排序"></a>3.3 排序</h3><ul><li>reverse</li></ul><blockquote><p>作用: 颠倒数组中元素的排列顺序。倒序。</p></blockquote><ul><li>sort</li></ul><blockquote><p>作用: 对数组的元素进行排序<br>参数(可选择): 函数(规定的排序方式)</p></blockquote><h2 id="4-数组迭代方法"><a href="#4-数组迭代方法" class="headerlink" title="4. 数组迭代方法"></a>4. 数组迭代方法</h2><blockquote><p>参数: [数组项的值, 索引, 数组对象本身]<br>是否改变原始数组: 否</p></blockquote><h3 id="4-1-判断每一项"><a href="#4-1-判断每一项" class="headerlink" title="4.1 判断每一项"></a>4.1 判断每一项</h3><ul><li>every</li></ul><blockquote><p>作用: 判断所有元素是否都符合条件，判断所有元素是否都符合条件，如果该函数对每一项都返回 <code>true</code>，则返回 <code>true</code></p></blockquote><ul><li>some</li></ul><blockquote><p>作用: 判断是否有至少一个元素符合条件，返回布尔值</p></blockquote><h3 id="4-2-过滤"><a href="#4-2-过滤" class="headerlink" title="4.2 过滤"></a>4.2 过滤</h3><ul><li>filter</li></ul><blockquote><p>作用: 返回判断条件为 <code>true</code> 的项组成的数组</p></blockquote><h3 id="4-3-遍历-无返回值"><a href="#4-3-遍历-无返回值" class="headerlink" title="4.3 遍历 - 无返回值"></a>4.3 遍历 - 无返回值</h3><ul><li>forEach</li></ul><blockquote><p>作用: 数组迭代，数组循环遍历，无返回值</p></blockquote><h3 id="4-4-遍历-有返回值"><a href="#4-4-遍历-有返回值" class="headerlink" title="4.4 遍历 - 有返回值"></a>4.4 遍历 - 有返回值</h3><ul><li>map</li></ul><blockquote><p>作用: 数组迭代，数组循环遍历，对元素重新组装，生成新数组</p></blockquote><h2 id="5-数组求和"><a href="#5-数组求和" class="headerlink" title="5. 数组求和"></a>5. 数组求和</h2><ul><li>reduce</li></ul><blockquote><p>参数：[前一个值，当前值，项的索引，数组对象]<br>是否改变原始数组：否</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对象</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%B9%E8%B1%A1/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-新增或修改对象现有属性"><a href="#1-新增或修改对象现有属性" class="headerlink" title="1. 新增或修改对象现有属性"></a>1. 新增或修改对象现有属性</h3><ul><li>Object.defineProperty</li></ul><blockquote><p>参数: [obj, prop, descriptor] (要在其上定义属性的对象, 要定义或修改的属性的名称, 将被定义或修改的属性描述符)<br>返回: 新对象</p></blockquote><h3 id="2-复制对象中可枚举的部分到目标对象-浅克隆"><a href="#2-复制对象中可枚举的部分到目标对象-浅克隆" class="headerlink" title="2. 复制对象中可枚举的部分到目标对象(浅克隆)"></a>2. 复制对象中可枚举的部分到目标对象(浅克隆)</h3><ul><li>Object.assign</li></ul><blockquote><p>参数: [target, ...sources] (目标对象，源对象)<br>返回: 新对象</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jaxu/p/11264017.html" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jaxu/p/11309385.html" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jaxu/p/11268862.html" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/jaxu/p/11287315.html" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表用来存储有序的元素集合，与数组不同，链表中的元素并非保存在连续的存储空间内，每个元素由一个存储元素本身的节点和一个指向下一个元素的指针构成。当要移动或删除元素时，只需要修改相应元素上的指针就可以了。对链表元素的操作要比对数组元素的操作效率更高。下面是链表数据结构的示意图<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&name=linkList.png&originHeight=118&originWidth=687&size=6139&status=done&style=none&width=687" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704346914-b3d8a713-634d-45fe-ad2c-e040f9985485.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&name=linkList.png&originHeight=118&originWidth=687&size=6139&status=done&style=none&width=687" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList.png"></p><ul><li>上面链表中每一个元素只有一个 <code>next</code> 指针，用来指向下一个节点，这样的链表称之为单向链表，我们只能从链表的头部开始遍历整个链表，任何一个节点只能找到它的下一个节点，而不能找到它的上一个节点。双向链表中的每一个元素拥有两个指针，一个用来指向下一个节点，一个用来指向上一个节点。在双向链表中，除了可以像单向链表一样从头部开始遍历之外，还可以从尾部进行遍历。下面是双向链表的数据结构示意图：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704367520-532d5db4-3fde-4ac4-8de5-4fd3e1d287e1.png#align=left&display=inline&height=123&margin=%5Bobject%20Object%5D&name=doubleLinkList.png&originHeight=123&originWidth=811&size=8281&status=done&style=none&width=811" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704367520-532d5db4-3fde-4ac4-8de5-4fd3e1d287e1.png#align=left&display=inline&height=123&margin=%5Bobject%20Object%5D&name=doubleLinkList.png&originHeight=123&originWidth=811&size=8281&status=done&style=none&width=811" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="doubleLinkList.png"></p><h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote><p>要实现链表数据结构，关键在于保存 <code>head</code> 元素（即链表的头元素）以及每一个元素的 <code>next</code> 指针，有这两部分我们就可以很方便地遍历链表从而操作所有的元素。可以把链表想象成一条锁链，锁链中的每一个节点都是相互连接的，我们只要找到锁链的头，整条锁链就都可以找到了。让我们来看一下具体的实现方式。</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>首先我们需要一个辅助类，用来描述链表中的节点。这个类很简单，只需要两个属性，一个用来保存节点的值，一个用来保存指向下一个节点的指针。</li></ul><pre><code class="javascript">function ListNode(element) &#123;  this.element = element;  this.next = null;&#125;</code></pre><ul><li>下面是链表类的基本骨架</li></ul><pre><code class="javascript">class LinkList &#123;  constructor() &#123;    this.length = 0;    this.head = null;  &#125;  // 向链表中添加节点  append(element) &#123;    var node = new ListNode(element);    if (this.head === null) &#123;      this.head = node;    &#125; else &#123;      var current = this.getElementAt(this.length - 1);      current.next = node;    &#125;    this.length++;  &#125;  // 在链表的指定位置插入节点  insert(position, element) &#123;    if (position &lt; 0 || position &gt; this.length - 1) &#123;      return false;    &#125;    var node = new ListNode(element);    if (position === 0) &#123;      node.next = this.head;      this.head = node;    &#125; else &#123;      var previous = this.getElementAt(position - 1);      node.next = previous.next;      previous.next = node;    &#125;    this.length++;    return true;  &#125;  // 删除链表中指定位置的元素，并返回这个元素的值  removeAt(position) &#123;    if (position &lt; 0 || position &gt; this.length - 1) &#123;      return null;    &#125;    var current = this.head;    if (position === 0) &#123;      this.head = current.next;    &#125; else &#123;      var previous = this.getElementAt(position - 1);      current = previous.next;      previous.next = current.next;    &#125;    this.length--;    return current.element;  &#125;  // 删除链表中对应的元素  remove(element) &#123;    var index = this.indexOf(element);    return this.removeAt(index);  &#125;  // 在链表中查找给定元素的索引  indexOf(element) &#123;    var current = this.head;    for (var i = 0; i &lt; this.length; i++) &#123;      if (current.element === element) &#123;        return i;      &#125;      current = current.next;    &#125;    return -1;  &#125;  // 返回链表中索引所对应的元素  getElementAt(position) &#123;    if (position &lt; 0 || position &gt; this.length - 1) &#123;      return null;    &#125;    var current = this.head;    for (var i = 0; i &lt; position; i++) &#123;      current = current.next;    &#125;    return current;  &#125;  // 判断链表是否为空  isEmpty() &#123;    // return this.head === null;    return this.length === 0;  &#125;  // 返回链表的长度  size() &#123;    return this.length;  &#125;  // 返回头节点  getHead() &#123;    return this.head;  &#125;  // 清空链表  clear() &#123;    this.head = null;    this.length = 0;  &#125;  // 辅助方法，按指定格式输出链表中的所有元素，方便测试验证结果  toString() &#123;    var current = this.head;    var s = &quot;&quot;;    while (current) &#123;      var next = current.next;      next = next ? next.element : &quot;null&quot;;      s += `[element: $&#123;current.element&#125;, next: $&#123;next&#125;] `;      current = current.next;    &#125;    return s;  &#125;&#125;</code></pre><ul><li>让我们从查找链表元素的方法 <code>getElementAt()</code> 开始，因为后面我们会多次用到它。</li></ul><pre><code class="javascript">getElementAt(position) &#123;  if (position &lt; 0 || position &gt; this.length - 1) &#123;    return null;  &#125;  var current = this.head;  for (var i = 0; i &lt; position; i++) &#123;    current = current.next;  &#125;  return current;&#125;</code></pre><blockquote><p>首先判断参数 <code>position</code> 的边界值，如果值超出了索引的范围（小于 <code>0</code> 或者大于<code>length - 1</code>），则返回 <code>null</code>。我们从链表的 <code>head</code> 开始，遍历整个链表直到找到对应索引位置的节点，然后返回这个节点。是不是很简单？和所有有序数据集合一样，链表的索引默认从 <code>0</code> 开始，只要找到了链表的头（所以我们必须在 <code>LinkList</code> 类中保存 <code>head</code> 值），然后就可以遍历找到索引所在位置的元素。</p></blockquote><ul><li>有了 <code>getElementAt()</code> 方法，接下来我们就可以很方便地实现 <code>append()</code> 方法，用来在链表的尾部添加新节点。</li></ul><pre><code class="javascript">append(element) &#123;  var node = new ListNode(element);  // 如果当前链表为空，则将 head 指向 node  if (this.head === null) &#123;    this.head = node;  &#125; else &#123;    // 否则，找到链表尾部的元素，然后添加新元素    var current = this.getElementAt(this.length - 1);    current.next = node;  &#125;  this.length++;&#125;</code></pre><blockquote><p>如果链表的 <code>head</code> 为 <code>null</code>（这种情况表示链表为空），则直接将 <code>head</code> 指向新添加的元素。否则，通过 <code>getElementAt()</code> 方法找到链表的最后一个节点，将该节点的 <code>next</code> 指针指向新添加的元素。新添加的元素的 <code>next</code> 指针默认为 <code>null</code>，链表最后一个元素的 <code>next</code> 值为 <code>null</code>。将节点挂到链表上之后，不要忘记将链表的长度加 <code>1</code>，我们需要通过<code>length</code> 属性来记录链表的长度。</p></blockquote><ul><li>接下来我们要实现 <code>insert()</code> 方法，可以在链表的任意位置添加节点。</li></ul><pre><code class="javascript">insert(position, element) &#123;  // position 不能超过边界值  if (position &lt; 0 || position &gt; this.length - 1) &#123;    return false;  &#125;  var node = new ListNode(element);  if (position === 0) &#123;    node.next = this.head;    this.head = node;  &#125; else &#123;    var previous = this.getElementAt(position - 1);    node.next = previous.next;    previous.next = node;  &#125;  this.length++;  return true;&#125;</code></pre><blockquote><p>首先也是要判断参数 <code>position</code> 的边界值，不能越界。当 <code>position</code> 的值为 <code>0</code> 时，表示要在链表的头部插入新节点，对应的操作如下图所示。将新插入节点的 <code>next</code> 指针指向现在的 <code>head</code>，然后更新 <code>head</code> 的值为新插入的节点。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704395087-c23664dd-c205-44d5-9e63-870bf14ec0b1.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_insert1.png&originHeight=205&originWidth=687&size=11778&status=done&style=none&width=687" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704395087-c23664dd-c205-44d5-9e63-870bf14ec0b1.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_insert1.png&originHeight=205&originWidth=687&size=11778&status=done&style=none&width=687" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList_insert1.png"></p><blockquote><p>如果要插入的节点在链表的中间或者尾部，对应的操作如下图。假设链表长度为 <code>3</code>，要在位置 <code>2</code> 插入新节点，我们首先找到位置 <code>2</code> 的前一个节点 <code>previous node</code>，将新节点 <code>new node</code> 的 <code>next</code> 指针指向 <code>previous node</code> 的 <code>next</code> 所对应的节点，然后再将<code>previous node</code> 的 <code>next</code> 指针指向 <code>new node</code>，这样就把新节点挂到链表中了。考虑一下，当插入的节点在链表的尾部，这种情况也是适用的。而如果链表为空，即链表的 <code>head</code> 为 <code>null</code>，则参数 <code>position</code> 会超出边界条件，从而 <code>insert()</code> 方法会直接返回 <code>false</code>。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704419032-051f8ebf-b913-43a0-8473-afb6535e64f9.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_insert2.png&originHeight=205&originWidth=687&size=12178&status=done&style=none&width=687" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704419032-051f8ebf-b913-43a0-8473-afb6535e64f9.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_insert2.png&originHeight=205&originWidth=687&size=12178&status=done&style=none&width=687" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList_insert2.png"></p><blockquote><p>最后，别忘了更新 <code>length</code> 属性的值，将链表的长度加 <code>1</code>。</p></blockquote><ul><li>按照相同的方式，我们可以很容易地写出 <code>removeAt()</code> 方法，用来删除链表中指定位置的节点。</li></ul><pre><code class="javascript">removeAt(position) &#123;  // position 不能超出边界值  if (position &lt; 0 || position &gt; this.length - 1) &#123;    return null;  &#125;  var current = this.head;  if (position === 0) &#123;    this.head = current.next;  &#125; else &#123;    var previous = this.getElementAt(position - 1);    current = previous.next;    previous.next = current.next;  &#125;  this.length--;  return current.element;&#125;</code></pre><blockquote><p>下面两张示意图说明了从链表头部和其它位置删除节点的情况。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705111553-9ff6c07c-5b98-408d-952e-625082c91c70.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_removeAt1.png&originHeight=205&originWidth=687&size=10618&status=done&style=none&width=687" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705111553-9ff6c07c-5b98-408d-952e-625082c91c70.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_removeAt1.png&originHeight=205&originWidth=687&size=10618&status=done&style=none&width=687" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList_removeAt1.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705120449-8a4c3bff-e7e3-4338-883f-c230e291392b.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_removeAt2.png&originHeight=205&originWidth=687&size=8551&status=done&style=none&width=687" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705120449-8a4c3bff-e7e3-4338-883f-c230e291392b.png#align=left&display=inline&height=205&margin=%5Bobject%20Object%5D&name=linkList_removeAt2.png&originHeight=205&originWidth=687&size=8551&status=done&style=none&width=687" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList_removeAt2.png"></p><blockquote><p>如果要删除的节点为链表的头部，只需要将 <code>head</code> 移到下一个节点即可。如果当前链表只有一个节点，那么下一个节点为 <code>null</code>，此时将 <code>head</code> 指向下一个节点等同于将 <code>head</code> 设置成 <code>null</code>，删除之后链表为空。如果要删除的节点在链表的中间部分，我们需要找出 <code>position</code> 所在位置的前一个节点，将它的 <code>next</code> 指针指向 <code>position</code> 所在位置的下一个节点。总之，删除节点只需要修改相应节点的指针，使断开位置左右相邻的节点重新连接上。被删除的节点由于再也没有其它部分的引用而被丢弃在内存中，等待垃圾回收器来清除。</p></blockquote><blockquote><p>最后，别忘了将链表的长度减 <code>1</code>。</p></blockquote><ul><li>下面我们来看看 <code>indexOf()</code> 方法，该方法返回给定元素在链表中的索引位置。</li></ul><pre><code class="javascript">indexOf(element) &#123;  var current = this.head;  for (var i = 0; i &lt; this.length; i++) &#123;    if (current.element === element) &#123;      return i;    &#125;    current = current.next;  &#125;  return -1;&#125;</code></pre><blockquote><p>我们从链表的头部开始遍历，直到找到和给定元素相同的元素，然后返回对应的索引号。如果没有找到对应的元素，则返回 <code>-1</code>。</p></blockquote><ul><li>在 <code>isEmpty()</code> 方法中，我们可以根据 <code>length</code> 是否为 <code>0</code> 来判断链表是否为空，当然也可以根据 <code>head</code> 是否为 <code>null</code> 来进行判断，前提是所有涉及到链表节点添加和移除的方法都要正确地更新 <code>length</code> 和 <code>head</code>。<code>toString()</code> 方法只是为了方便测试而编写的，我们来看看几个测试用例：</li></ul><pre><code class="javascript">var linkList = new LinkList();linkList.append(10);linkList.append(15);linkList.append(20);console.log(linkList.toString());linkList.insert(0, 9);linkList.insert(2, 11);linkList.insert(5, 25);console.log(linkList.toString());console.log(linkList.removeAt(0));console.log(linkList.removeAt(1));console.log(linkList.removeAt(3));console.log(linkList.toString());console.log(linkList.indexOf(20));linkList.remove(20);console.log(linkList.toString());linkList.clear();console.log(linkList.size());</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705261819-5917b870-8756-4de9-8e66-be0548d56213.png#align=left&display=inline&height=171&margin=%5Bobject%20Object%5D&name=linkList_test.png&originHeight=171&originWidth=1306&size=14507&status=done&style=none&width=1306" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705261819-5917b870-8756-4de9-8e66-be0548d56213.png#align=left&display=inline&height=171&margin=%5Bobject%20Object%5D&name=linkList_test.png&originHeight=171&originWidth=1306&size=14507&status=done&style=none&width=1306" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList_test.png"></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><blockquote><p>由于双向链表具有单向链表的所有特性，因此我们的双向链表类可以继承自前面的单向链表类，不过辅助类 <code>Node</code> 需要添加一个 <code>prev</code> 属性，用来指向前一个节点。</p></blockquote><pre><code class="javascript">function Node(element) &#123;  this.element = element;  this.next = null;  this.prev = null;&#125;</code></pre><ul><li>下面是继承自 <code>LinkList</code> 类的双向链表类的基本骨架</li></ul><pre><code class="javascript">class DoubleLinkList extends LinkList &#123;  constructor() &#123;    super();    this.tail = null; // 尾节点  &#125;&#125;</code></pre><ul><li>先来看看 <code>append()</code> 方法的实现。当链表为空时，除了要将 <code>head</code> 指向当前添加的节点外，还要将 <code>tail</code> 也指向当前要添加的节点。当链表不为空时，直接将 <code>tail</code> 的 <code>next</code> 指向当前要添加的节点 <code>node</code>，然后修改 <code>node</code> 的 <code>prev</code> 指向旧的 <code>tail</code>，最后修改 <code>tail</code> 为新添加的节点。我们不需要从头开始遍历整个链表，而通过 <code>tail</code> 可以直接找到链表的尾部，这一点比单向链表的操作要更方便。最后将 <code>length</code> 的值加 <code>1</code>，修改链表的长度。</li></ul><pre><code class="javascript">append(element) &#123;  var node = new Node(element);  // 如果链表为空，则将 head 和 tail 都指向当前添加的节点  if (this.head === null) &#123;    this.head = node;    this.tail = node;  &#125; else &#123;    // 否则，将当前节点添加到链表的尾部    this.tail.next = node;    node.prev = this.tail;    this.tail = node;  &#125;  this.length++;&#125;</code></pre><ul><li>由于双向链表可以从链表的尾部往前遍历，所以我们修改了 <code>getElementAt()</code> 方法，对基类中单向链表的方法进行了改写。当要查找的元素的索引号大于链表长度的一半时，从链表的尾部开始遍历。</li></ul><pre><code class="javascript">getELementAt(position) &#123;  if (position &lt; 0 || position &gt; this.length - 1) return null;  // 从后向前遍历  if (position &gt; Math.floor(this.length / 2)) &#123;    var current = this.tail;    for (var i = this.length - 1; i &gt; position; i--) &#123;      current = current.prev;    &#125;    return current;  &#125; else &#123;    return super.getELementAt(position);  &#125;&#125;</code></pre><blockquote><p>有两种遍历方式，从前往后遍历调用的是基类单向链表里的方法，从后往前遍历需要用到节点的 <code>prev</code> 指针，用来查找前一个节点。</p></blockquote><ul><li>我们同时还需要修改 <code>insert()</code> 和 <code>removeAt()</code> 这两个方法。记住，与单向链表唯一的区别就是要同时维护 <code>head</code> 和 <code>tail</code>，以及每一个节点上的 <code>next</code> 和 <code>prev</code> 指针。</li></ul><pre><code class="javascript">insert(position, element) &#123;  if (position &lt; 0 || position &gt; this.length - 1) return false;  // 插入到尾部  if (position === this.length) &#123;    this.append(element);  &#125; else &#123;    var node = new ListNode(element);    // 插入到头部    if (position === 0) &#123;      if (this.head === null) &#123;        this.head = node;        this.tail = node;      &#125; else &#123;        node.next = this.head;        this.head.prev = node;        this.head = node;      &#125;    &#125; else &#123;      // 插入到中间位置      var current = this.getElementAt(position);      var previous = current.prev;      node.next = current;      node.prev = previous;      previous.next = node;      current.prev = node;    &#125;  &#125;  this.length++;  return true;&#125;removeAt(position) &#123;  if (position &lt; 0 || position &gt; this.length - 1) return null;  var current = this.head;  var previous;  // 移除头部元素  if (position === 0) &#123;    this.head = current.next;    this.head.prev = null;    if (this.length === 1) &#123;      this.tail = null;    &#125;  &#125; else if (position === this.length - 1) &#123;    // 移除尾部元素    current = this.tail;    this.tail = current.prev;    this.tail.next = null;  &#125; else &#123;    // 移除中间元素    current = this.getELementAt(position);    previous = current.prev;    previous.next = current.next;    current.next.prev = previous;  &#125;  this.length--;  return current.element;&#125;</code></pre><ul><li>操作过程中需要判断一些特殊情况，例如链表的头和尾，以及当前链表是否为空等等，否则程序可能会在某些特殊情况下导致越界和报错。下面是一个完整的双向链表类的代码</li></ul><pre><code class="javascript">class DoubleLinkList extends LinkList &#123;  constructor() &#123;    super();    this.tail = null;  &#125;  append(element) &#123;    var node = new ListNode(element);    if (this.head === null) &#123;      this.head = node;      this.tail = node;    &#125; else &#123;      this.tail.next = node;      node.prev = this.tail;      this.tail = node;    &#125;    this.length++;  &#125;  getElementAt(position) &#123;    if (position &lt; 0 || position &gt; this.length - 1) return null;    if (position &gt; Math.floor(this.length / 2)) &#123;      var current = this.tail;      for (var i = this.length - 1; i &gt; position; i--) &#123;        current = current.prev;      &#125;      return current;    &#125; else &#123;      super.getElementAt(position);    &#125;  &#125;  insert(position, element) &#123;    if (position &lt; 0 || position &gt; this.length - 1) return false;    if (position === this.length) &#123;      this.append(element);    &#125; else &#123;      var node = new ListNode(element);      if (position === 0) &#123;        if (this.head === null) &#123;          this.head = node;          this.tail = node;        &#125; else &#123;          node.next = this.head;          this.head.prev = node;          this.head = node;        &#125;      &#125; else &#123;        var current = this.getElementAt(position);        var previous = current.prev;        node.next = current;        node.prev = previous;        previous.next = node;        current.prev = node;      &#125;    &#125;    this.length++;    return true;  &#125;  removeAt(position) &#123;    if (position &lt; 0 || position &gt; this.length - 1) return null;    var current = this.head;    var previous;    if (position === 0) &#123;      this.head = current.next;      this.head.prev = null;      if (this.length === 1) &#123;        this.tail = null;      &#125;    &#125; else if (position === this.length - 1) &#123;      current = this.tail;      this.tail = current.prev;      this.tail.next = null;    &#125; else &#123;      current = this.getElementAt(position);      previous = current.prev;      previous.next = current.next;      current.next.prev = previous;    &#125;    this.length--;    return current.element;  &#125;  getTail() &#123;    return this.tail;  &#125;  clear() &#123;    super.clear();    this.tail = null;  &#125;  toString() &#123;    var current = this.head;    var s = &quot;&quot;;    while (current) &#123;      var next = current.next;      var previous = current.prev;      next = next ? next.element : &quot;null&quot;;      previous = previous ? previous.element : &quot;null&quot;;      s += `[element: $&#123;current.element&#125;, prev: $&#123;previous&#125;, next: $&#123;next&#125;]`;      current = current.next;    &#125;    return s;  &#125;&#125;</code></pre><ul><li>我们重写了 <code>toString()</code> 方法以方便更加清楚地查看测试结果。下面是一些测试用例：</li></ul><pre><code class="javascript">let doubleLinkList = new DoubleLinkList();doubleLinkList.append(10);doubleLinkList.append(15);doubleLinkList.append(20);doubleLinkList.append(25);doubleLinkList.append(30);console.log(doubleLinkList.toString());console.log(doubleLinkList.getElementAt(1).element);console.log(doubleLinkList.getElementAt(2).element);console.log(doubleLinkList.getElementAt(3).element);doubleLinkList.insert(0, 9);doubleLinkList.insert(4, 24);doubleLinkList.insert(7, 35);console.log(doubleLinkList.toString());console.log(doubleLinkList.removeAt(0));console.log(doubleLinkList.removeAt(1));console.log(doubleLinkList.removeAt(5));console.log(doubleLinkList.toString());</code></pre><p>-　对应的结果如下</p><pre><code class="javascript">[element: 10, prev: null, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 25] [element: 25, prev: 20, next: 30] [element: 30, prev: 25, next: null]20[element: 9, prev: null, next: 10] [element: 10, prev: 9, next: 15] [element: 15, prev: 10, next: 20] [element: 20, prev: 15, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 30] [element: 30, prev: 25, next: 35] [element: 35, prev: 30, next: null]15[element: 10, prev: null, next: 20] [element: 20, prev: 10, next: 24] [element: 24, prev: 20, next: 25] [element: 25, prev: 24, next: 35] [element: 35, prev: 25, next: null]</code></pre><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>顾名思义，循环链表的尾部指向它自己的头部。循环链表可以有单向循环链表，也可以有双向循环链表。下面是单向循环链表和双向循环链表的数据结构示意图</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705287564-4531cdeb-9452-4e71-a303-44e9c7c6e029.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=linkList_around.png&originHeight=299&originWidth=813&size=13882&status=done&style=none&width=813" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705287564-4531cdeb-9452-4e71-a303-44e9c7c6e029.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=linkList_around.png&originHeight=299&originWidth=813&size=13882&status=done&style=none&width=813" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linkList_around.png"></p><blockquote><p>在实现循环链表时，需要确保最后一个元素的 <code>next</code> 指针指向 <code>head</code>。下面是单向循环链表的完整代码</p></blockquote><pre><code class="javascript">class CircularLinkList extends LinkList &#123;  constructor() &#123;    super();  &#125;  append(element) &#123;    let node = new ListNode(element);    if (this.head === null) this.head = node;    else &#123;      let current = this.getElementAt(this.length - 1);      current.next = node;    &#125;    // 将新添加的元素的 next 指向 head    node.next = this.head;    this.length++;  &#125;  insert(element, position) &#123;    if (position &lt; 0 || position &gt; this.length - 1) return false;    let node = new ListNode(element);    if (position === 0) &#123;      node.next = this.head;      let current = this.getElementAt(this.length - 1);      current.next = node;      this.head = node;    &#125; else &#123;      var previous = this.getElementAt(position - 1);      node.next = previous.next;      previous.next = node;    &#125;    this.length++;    return true;  &#125;  removeAt(position) &#123;    if (position &lt; 0 || position &gt; this.length - 1) return null;    let current = this.head;    if (position === 0) this.head = current.next;    else &#123;      let previous = this.getElementAt(position - 1);      current = previous.next;      previous.next = current.next;    &#125;    this.length--;    if (this.length &gt; 1) &#123;      let last = this.getElementAt(this.length - 1);      last.next = this.head;    &#125;    return current.element;  &#125;  toString() &#123;    let current = this.head;    let s = &quot;&quot;;    for (let i = 0; i &lt; this.length; i++) &#123;      let next = current.next;      next = next ? next.element : &quot;null&quot;;      s += `[element: $&#123;current.element&#125;, next: $&#123;next&#125;]`;      current = current.next;    &#125;  &#125;&#125;</code></pre><ul><li>单向循环链表的测试用例</li></ul><pre><code class="javascript">let circularLinkList = new CircularLinkList();circularLinkList.append(10);circularLinkList.append(15);circularLinkList.append(20);console.log(circularLinkList.toString());circularLinkList.insert(0, 9);circularLinkList.insert(3, 25);console.log(circularLinkList.toString());console.log(circularLinkList.removeAt(0));console.log(circularLinkList.toString());</code></pre><p>-　对应的结果如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705316856-b6b81605-b48c-462c-adc6-57b21fecd1bf.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=linList_around_result.png&originHeight=87&originWidth=1086&size=9699&status=done&style=none&width=1086" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608705316856-b6b81605-b48c-462c-adc6-57b21fecd1bf.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=linList_around_result.png&originHeight=87&originWidth=1086&size=9699&status=done&style=none&width=1086" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="linList_around_result.png"></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从图片裁剪了解 js 二进制常用 api</title>
      <link href="JavaScript/%E4%BB%8E%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E4%BA%86%E8%A7%A3%20js%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%20api/"/>
      <url>JavaScript/%E4%BB%8E%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E4%BA%86%E8%A7%A3%20js%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%20api/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="二进制模块之间的关系"><a href="#二进制模块之间的关系" class="headerlink" title="二进制模块之间的关系"></a>二进制模块之间的关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1598083455644-f4308101-1403-4566-ae7d-09a0c4fa5ffe.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=889&size=126895&status=done&style=none&width=889" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1598083455644-f4308101-1403-4566-ae7d-09a0c4fa5ffe.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=889&size=126895&status=done&style=none&width=889" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>获取文件并读取文件</li><li>获取裁剪坐标</li><li>裁剪图片</li><li>读取裁剪后的图片预览并上传</li></ol><p>接下来先了解下二进制相关的 <code>API</code>  以方便实现本需求。</p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><blockquote><p><code>HTML5</code>定义了<code>FileReader</code>作为文件<code>API</code>的重要成员用于读取文件，根据<code>W3C</code>的定义，<code>FileReader</code>接口提供了读取文件的方法和包含读取结果的事件模型。</p></blockquote><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><pre><code class="javascript">const fileReader = new FileReader();</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/error" target="_blank" rel="noopener external nofollow noreferrer">error</a></td><td>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException" target="_blank" rel="noopener external nofollow noreferrer">DOMException</a>，表示在读取文件时发生的错误  。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState" target="_blank" rel="noopener external nofollow noreferrer">readyState</a></td><td>一个数字，用来表示  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noopener external nofollow noreferrer">FileReader</a> API 的三种可能状态。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result" target="_blank" rel="noopener external nofollow noreferrer">result</a></td><td>文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>abort</td><td>中止读取操作</td></tr><tr><td>readAsArrayBuffer</td><td>异步按字节读取文件内容，结果用  ArrayBuffer  对象表示</td></tr><tr><td>readAsBinaryString</td><td>异步按字节读取文件内容，结果为文件的二进制串</td></tr><tr><td>readAsDataURL</td><td>异步读取文件内容，结果用  data:url  的字符串形式表示</td></tr><tr><td>readAsText</td><td>异步按字符读取文件内容，结果用字符串形式表示</td></tr></tbody></table><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>中断时触发</td></tr><tr><td>onerror</td><td>出错时触发</td></tr><tr><td>onload</td><td>文件读取成功完成时触发</td></tr><tr><td>onloadend</td><td>读取完成触发（无论成功或失败）</td></tr><tr><td>onloadstart</td><td>读取开始时触发</td></tr><tr><td>onprogress</td><td>读取中</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="jsx">/** * @description 把一个文件的内容通过字符串的方式读取出来 */&lt;input type=&quot;file&quot; id=&quot;upload&quot; /&gt;const upload = document.getElementById(&quot;upload&quot;);upload.addEventListener(&quot;change&quot;, function() &#123;    const fileReader = new FileReader();  fileReader.onload = function() &#123;      const reult = fileReader.result;    console.log(result):  &#125;&#125;, false);</code></pre><h2 id="ArrayBuffer-TypedArray-DataView"><a href="#ArrayBuffer-TypedArray-DataView" class="headerlink" title="ArrayBuffer / TypedArray / DataView"></a>ArrayBuffer / TypedArray / DataView</h2><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1597991690421-351d07c1-8366-469f-8912-d094078e5986.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=1746&size=58281&status=done&style=none&width=873" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1597991690421-351d07c1-8366-469f-8912-d094078e5986.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=1746&size=58281&status=done&style=none&width=873" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><code>FileReader</code>  有个 <code>readAsArrayBuffer()</code>  方法，如果被读取的文件是二进制数据，那么用次方法读取将是最合适的方案，读取出来的数据将是一个 <code>ArrayBuffer</code>  对象。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p><code>ArrayBuffer</code>  对象用来表示通用的、固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code>  不能直接操作,而是要通过<strong>类型数组对象</strong>或  <strong><code>DataView</code>**</strong>  对象**来操作,它们会将缓冲区中的数据表示为特定的格式,并通过这些格式来读写缓冲区的内容.</p></blockquote><p><code>ArrayBuffer</code>也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p><pre><code class="javascript">const arrayBuffer = new ArrayBuffer(8);// ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节）console.log(arrayBuffer.byteLength);</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>ArrayBuffer.length</td><td>ArrayBuffer  构造函数的 length  属性，其值为 1 。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength" target="_blank" rel="noopener external nofollow noreferrer">ArrayBuffer.prototype.byteLength</a></td><td>只读属性，表示  ArrayBuffer  的 byte  的大小，在 ArrayBuffer  构造完成时生成，不可改变。</td></tr></tbody></table><blockquote><p>由于无法对  <code>Arraybuffer</code>  直接进行操作,所以我们需要借助其他对象来操作. 所有就有了  <strong><code>TypedArray</code>**</strong>(类型数组对象)<strong>和  <strong><code>DataView</code>*</strong>*对象</strong>。</p></blockquote><h3 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h3><p>上方代码生成了一段 8 字节的内存区域。其中每个字节的默认值都是 0。</p><p>为了读和写这段内容，需要为它指定视图。 <code>DataView</code>  视图的创建，需要提供 <code>ArrayBuffer</code> 对象实例作为参数。</p><p><code>DataView</code>  视图是一个可以从二进制 <code>ArrayBuffer</code>  对象中读写多种数值类型的底层接口。</p><ul><li><code>setInt8()</code>  从 <code>DataView</code>  起始位置以 <code>byte</code>  为计数的指定偏移量 <code>byteOffset</code>  处存储一个 <code>8-bit</code>  数(一个字节)。</li><li><code>getInt8()</code>  从 <code>DataView</code>  起始位置以 <code>byte</code> 为计数的指定偏移量 <code>byteOffset</code> 处获取一个 <code>8-bit</code> 数(一个字节)。</li></ul><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><pre><code class="javascript">new DataView(buffer, [, byteOffset [, byteLength]])</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>buffer</td><td>一个 已经存在的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener external nofollow noreferrer">ArrayBuffer</a>  或  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" target="_blank" rel="noopener external nofollow noreferrer">SharedArrayBuffer</a>   对象，DataView  对象的数据源。</td></tr><tr><td>byteOffset (可选)</td><td>此  DataView  对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。</td></tr><tr><td>byteLength (可选)</td><td>此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。</td></tr></tbody></table><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError" target="_blank" rel="noopener external nofollow noreferrer">RangeError</a></li></ul><p>如果 <code>byteOffset</code> 或者 <code>byteLength </code>参数的值导致视图超出了 <code>buffer</code> 的结束位置就会抛出此异常。</p><p>例如，假设 <code>buffer</code> （缓冲对象）是 <code>16</code> 字节长度，<code>byteOffset</code> 参数为 <code>8</code>，<code>byteLength</code> 参数为  <code>10</code>，这个错误就会抛出，这是因为结果视图试图超出 <code>buffer</code> 对象的总长度 <code>2</code> 个字节。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="javascript">let arrayBuffer = new ArrayBuffer();console.log(arrayBuffer.byteLength); // 2let dataView = new DataView(buffer);dataView.setInt8(0, 1);dataView.setInt8(1, 2);console.log(dataView.getInt8(0)); // 1console.log(dataView.getInt8(1)); // 2console.log(dataView.getInt16(0)); // 258</code></pre><h3 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h3><p>另一种<code>TypedArray</code>视图，与<code>DataView</code>视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。</p><p><code>TypedArray</code>对象描述了一个底层的二进制数据缓存区（<code>binary data buffer</code>）的一个类数组视图（<code>view</code>）。但它本身不可以被实例化，甚至无法访问，你可以把它理解为接口，它有很多的实现。</p><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><table><thead><tr><th>类型</th><th>单个元素值的范围</th><th>大小（bytes）</th><th>描述</th></tr></thead><tbody><tr><td>Int8Array</td><td>-128 to 127</td><td>1</td><td>8 位二进制有符号整数</td></tr><tr><td>Uint8Array</td><td>0 to 255</td><td>1</td><td>8 位无符号整数</td></tr><tr><td>Int16Array</td><td>-32768 to 32767</td><td>2</td><td>16 位二进制有符号整数</td></tr><tr><td>Uint16Array</td><td>0 to 65535</td><td>2</td><td>16 位无符号整数</td></tr></tbody></table><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><pre><code class="javascript">const arrayBuffer = new ArrayBuffer(8);console.log(arrayBuffer.byteLength); // 8const int8Array = new Int8Array(arrayBuffer);console.log(int8Array.length); // 8const int16Array = new Int16Array(arrayBuffer);console.log(int16Array.length); // 4</code></pre><h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p><code>Blob</code>  是用来支持文件操作的。简单的说：在 <code>JS</code>  中，有两个构造函数  <code>File</code>  和  <code>Blob</code>, 而 <code>File</code>  继承了所有 <code>Blob</code>  的属性。</p><p>所以在我们看来， <code>File</code>  对象可以看作一种特殊的 <code>Blob</code>  对象。</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1598082428365-89545715-5ef7-45d9-8610-82d830059ebe.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1728&size=143528&status=done&style=none&width=1728" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1598082428365-89545715-5ef7-45d9-8610-82d830059ebe.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1728&size=143528&status=done&style=none&width=1728" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="javascript">/** * @description 返回一个创建的 Blob 对象，其内容由参数中给定的数组串联组成 */Blob(blobParts[, options])</code></pre><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size" target="_blank" rel="noopener external nofollow noreferrer">Blob.size</a>  只读</td><td>Blob  对象中所包含数据的大小（字节）</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type" target="_blank" rel="noopener external nofollow noreferrer">Blob.type</a>  只读</td><td>一个字符串，表明该  Blob  对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</td></tr></tbody></table><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>[Blob.slice([start[, end[, contentType]]])](<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice" target="_blank" rel="noopener external nofollow noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice</a>)</td><td>返回一个新的  Blob  对象，包含了源  Blob  对象中指定范围内的数据。</td></tr><tr><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream" target="_blank" rel="noopener external nofollow noreferrer">Blob.stream()</a></td><td>返回一个能读取 blob 内容的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream" target="_blank" rel="noopener external nofollow noreferrer">ReadableStream</a>。</td></tr></tbody></table><p>| <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text" target="_blank" rel="noopener external nofollow noreferrer">Blob.text()</a><br>| 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/USVString" target="_blank" rel="noopener external nofollow noreferrer">USVString</a>。 |<br>| <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer" target="_blank" rel="noopener external nofollow noreferrer">Blob.arrayBuffer()</a> | 返回一个 promise 且包含 blob 所有内容的二进制格式的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBuffer" target="_blank" rel="noopener external nofollow noreferrer">ArrayBuffer</a>  |</p><h2 id="atob-和-btoa"><a href="#atob-和-btoa" class="headerlink" title="atob 和 btoa"></a>atob 和 btoa</h2><p>从 <code>IE10+</code>  浏览器开始，所有的浏览器就原生提供了 <code>Base64</code>  编解码的方法。</p><h3 id="Base64-解码"><a href="#Base64-解码" class="headerlink" title="Base64 解码"></a>Base64 解码</h3><pre><code class="javascript">let decodedData = window.atob(encodedData);</code></pre><h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><pre><code class="javascript">let encodedData = window.btoa(stringToEncode);</code></pre><h2 id="Canvas-中的-ImageData-对象"><a href="#Canvas-中的-ImageData-对象" class="headerlink" title="Canvas 中的 ImageData 对象"></a>Canvas 中的 ImageData 对象</h2><p><code>ImageData</code>  对象中存储着 <code>canvas</code>  对象真实的像素数据，它包含以下几个只读属性：</p><ul><li><code>width</code> ：图片宽度，单位是像素</li><li><code>height</code> ：图片高度，单位是像素</li><li><code>data</code> ： <code>Uint8ClampedArray</code>  类型的一维数组，包含着 <code>RGBA</code>  格式的整型数据，范围在 <code>0</code>  至 <code>255</code>  之间（包括 <code>255</code>）。</li></ul><h3 id="创建一个-ImageData-对象"><a href="#创建一个-ImageData-对象" class="headerlink" title="创建一个 ImageData 对象"></a>创建一个 ImageData 对象</h3><p>使用 <code>createImageData()</code> 方法去创建一个新的，空白的 <code>ImageData</code>  对象。</p><pre><code class="javascript">let myImageData = ctx.createImageData(width, height);</code></pre><p>上面代码创建了一个新的具体特定尺寸的<code>ImageData</code>对象。所有像素被预设为透明黑。</p><h3 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h3><p>为了获得一个包含画布场景像素数据的 <code>ImageData</code>  对象，你可以用 <code>getImageData()</code>  方法：</p><pre><code class="javascript">let myImageData = ctx.getImageData(left, top, width, height);</code></pre><h3 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h3><p>你可以用 <code>putImageData()</code>  方法去对场景进行像素数据的写入。</p><pre><code class="javascript">ctx.putImageData(myImageData, dx, dy);</code></pre><h3 id="使用-toDataURL-将-canvas-转换为-data-URI-格式"><a href="#使用-toDataURL-将-canvas-转换为-data-URI-格式" class="headerlink" title="使用 toDataURL 将 canvas 转换为 data URI 格式"></a>使用 toDataURL 将 canvas 转换为 data URI 格式</h3><ul><li>创建一个 <code>&lt;canvas&gt;</code>  元素</li></ul><pre><code class="html">&lt;canvas id=&quot;canvas&quot; width=&quot;5&quot; height=&quot;5&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>获取一个 <code>data-URL</code></li></ul><pre><code class="javascript">let canvas = document.getElementById(&quot;canvas&quot;);let dataURL = canvas.toDataURL();console.log(dataURL);// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;</code></pre><p>基本所需要的技术点已经全部列出，接下来我们将实现图片裁剪的需求</p><h2 id="实现图片裁剪"><a href="#实现图片裁剪" class="headerlink" title="实现图片裁剪"></a>实现图片裁剪</h2><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1598084805698-72d41a26-6ec6-4e5f-88d3-2662e3f05326.gif#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=866&originWidth=2216&size=3680927&status=done&style=none&width=2216" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1598084805698-72d41a26-6ec6-4e5f-88d3-2662e3f05326.gif#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=866&originWidth=2216&size=3680927&status=done&style=none&width=2216" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.gif"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="jsx">import React, &#123; useState, useRef &#125; from &quot;react&quot;;import &#123; Input, Row, Col, Button &#125; from &quot;antd&quot;;import &#123; ScissorOutlined, PlusCircleOutlined, MinusCircleOutlined, UploadOutlined &#125; from &quot;@ant-design/icons&quot;;const App = () =&gt; &#123;  const imageRef = useRef(),    canvasRef = useRef(),    avatarRef = useRef(),    [state, setState] = useState(&#123;      file: null,      dataURL: &quot;&quot;,      times: 1,      startX: 0,      startY: 0,      startDrag: false,      lastX: 0,      lastY: 0,      avatarDataUrl: &quot;&quot;    &#125;);  function drawImage(left = state.lastX, top = state.lastY) &#123;    let image = imageRef.current;    let canvas = canvasRef.current;    let ctx = canvas.getContext(&quot;2d&quot;);    ctx.clearRect(0, 0, canvas.width, canvas.height);    let imageWidth = image.width;    let imageHeight = image.height;    if (imageWidth &gt; imageHeight) &#123;      let scale = canvas.width / canvas.height;      imageWidth = canvas.width * state.times;      imageHeight = imageHeight * scale * state.times;    &#125; else &#123;      let scale = canvas.height / canvas.width;      imageHeight = canvas.height * state.times;      imageWidth = imageWidth * scale * state.times;    &#125;    ctx.drawImage(image, (canvas.width - imageWidth) / 2 + left, (canvas.height - imageHeight) / 2 + top, imageWidth, imageHeight);  &#125;  function handleChange(event) &#123;    let file = event.target.files[0];    let fileReader = new FileReader();    fileReader.onload = event =&gt; &#123;      setState(&#123;        ...state,        file,        dataURL: event.target.result      &#125;);      imageRef.onload = () =&gt; drawImage();    &#125;;    fileReader.readAsDataURL(file);  &#125;  function handleMouseDown(event) &#123;    setState(&#123;      ...state,      startX: event.clientX,      startY: event.clientY,      startDrag: true    &#125;);  &#125;  function handleMouseMove(event) &#123;    if (state.startDrag) &#123;      drawImage(event.clientX - state.startX + state.lastX, event.clientY - state.startY + state.lastY);    &#125;  &#125;  function handleMouseUp(event) &#123;    setState(&#123;      ...state,      lastX: event.clientX - state.startX + state.lastX,      lastY: event.clientY - state.startY + state.lastY,      startDrag: false    &#125;);  &#125;  function bigger() &#123;    setState(&#123;      ...state,      times: state.times + 0.1    &#125;);    drawImage();  &#125;  function smaller() &#123;    setState(&#123;      ...state,      times: state.times - 0.1    &#125;);    drawImage();  &#125;  function confirm() &#123;    let canvas = canvasRef.current;    let ctx = canvas.getContext(&quot;2d&quot;);    const imageData = ctx.getImageData(100, 100, 100, 100);    let avatarCanvas = document.createElement(&quot;canvas&quot;);    avatarCanvas.width = 100;    avatarCanvas.height = 100;    let avatarCtx = avatarCanvas.getContext(&quot;2d&quot;);    avatarCtx.putImageData(imageData, 0, 0);    let avatarDataUrl = avatarCanvas.toDataURL();    setState(&#123; ...state, avatarDataUrl &#125;);    avatarRef.current.src = avatarDataUrl;  &#125;  function upload(event) &#123;    console.log(state.avatarDataUrl);    let bytes = atob(state.avatarDataUrl.split(&quot;,&quot;)[1]);    console.log(&quot;bytes&quot;, bytes);    let arrayBuffer = new ArrayBuffer(bytes.length);    let uInt8Array = new Uint8Array();    for (let i = 0; i &lt; bytes.length; i++) &#123;      uInt8Array[i] = bytes.charCodeAt[i];    &#125;    let blob = new Blob([arrayBuffer], &#123; type: &quot;image/png&quot; &#125;);    let xhr = new XMLHttpRequest();    let formData = new FormData();    formData.append(&quot;avatar&quot;, blob);    xhr.open(&quot;POST&quot;, &quot;/upload&quot;, true);    xhr.send(formData);  &#125;  return (    &lt;div style=&#123;&#123; padding: "10px" &#125;&#125;&gt;      &lt;h2&gt;图片裁剪，预览以及上传&lt;/h2&gt;      &lt;Input type=&quot;file&quot; accept=&quot;image/*&quot; onChange=&#123;handleChange&#125; style=&#123;&#123; width: "200px" &#125;&#125; /&gt;      &lt;Row&gt;        &lt;Col&gt;&#123;state.file &amp;&amp; &lt;img ref=&#123;imageRef&#125; src=&#123;state.dataURL&#125; alt=&quot;&quot; style=&#123;&#123; border: "2px dashed #79D281", width: "400px" &#125;&#125; /&gt;&#125;&lt;/Col&gt;      &lt;/Row&gt;      &lt;div onMouseDown=&#123;handleMouseDown&#125; onMouseMove=&#123;handleMouseMove&#125; onMouseUp=&#123;handleMouseUp&#125;&gt;        &#123;state.file &amp;&amp; (          &lt;Row&gt;            &lt;Col style=&#123;&#123; position: "relative" &#125;&#125;&gt;              &lt;canvas ref=&#123;canvasRef&#125; width=&quot;300&quot; height=&quot;300&quot; style=&#123;&#123; border: "2px dashed #632B21" &#125;&#125;&gt;&lt;/canvas&gt;              &lt;div                style=&#123;&#123;                  width: 100,                  height: 100,                  backgroundColor: "blue",                  opacity: 0.3,                  position: "absolute",                  left: 100,                  top: 100                &#125;&#125;&gt;&lt;/div&gt;            &lt;/Col&gt;            &lt;Col&gt;              &lt;Button icon=&#123;&lt;PlusCircleOutlined /&gt;&#125; onClick=&#123;bigger&#125;&gt;                变大              &lt;/Button&gt;              &lt;Button icon=&#123;&lt;MinusCircleOutlined /&gt;&#125; onClick=&#123;smaller&#125;&gt;                变小              &lt;/Button&gt;              &lt;Button icon=&#123;&lt;ScissorOutlined /&gt;&#125; onClick=&#123;confirm&#125;&gt;                剪切              &lt;/Button&gt;            &lt;/Col&gt;          &lt;/Row&gt;        )&#125;      &lt;/div&gt;      &lt;div&gt;&#123;state.file &amp;&amp; &lt;img ref=&#123;avatarRef&#125; alt=&quot;&quot; style=&#123;&#123; border: "2px solid #85D6C7" &#125;&#125; /&gt;&#125;&lt;/div&gt;      &lt;div&gt;        &#123;state.file &amp;&amp; (          &lt;Button type=&quot;primary&quot; icon=&#123;&lt;UploadOutlined /&gt;&#125; onClick=&#123;upload&#125;&gt;            上传          &lt;/Button&gt;        )&#125;      &lt;/div&gt;    &lt;/div&gt;  );&#125;;export default App;</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="一、获取文件并读取文件"><a href="#一、获取文件并读取文件" class="headerlink" title="一、获取文件并读取文件"></a>一、获取文件并读取文件</h4><p>给 <code>input</code>  绑定事件</p><pre><code class="jsx">import React, &#123; useState, useRef &#125; from &quot;react&quot;;const App = () =&gt; &#123;  const imgRef = useRef();  const canvasRef = useRef();  const [file, setFile] = useState();  const [dataURL, setDataURL] = useState();  const [startX, setStartX] = useState(0);  const [startY, setStartY] = useState(0);  const [lastX, setLastX] = useState(0);  const [lastY, setLastY] = useState(0);  const [startDrag, setStartDrag] = useState(false);  const handleChange = event =&gt; &#123;    let file = event.target.files[0];    let fileReader = new FileReader();    fileReader.onload = event =&gt; &#123;      setFile(file);      setDataURL(event.target.result);      imageRef.current.onload = () =&gt; drawImage();    &#125;;    fileReader.readAsDataURL(file);  &#125;;  return (    &lt;&gt;      &lt;input type=&quot;file&quot; onChange=&#123;handleChange&#125; /&gt;      &lt;img src=&quot;xxx&quot; ref=&#123;imgRef&#125; /&gt;    &lt;/&gt;  );&#125;;</code></pre><p><code>HTML5</code>  支持从  <code>input[type=file]</code>  元素中直接获取文件信息，也可以读取文件内容。</p><p>此处用到了 <code>FileReader</code> ，这个类专门用来读取本地文件。纯文本或者二进制都可以进行读取，但是本地文件必须是经过用户允许之后才能读取，也就是说，用户要在 <code>input[type=file]</code>  中选择了这个文件，你才可以读取到它。</p><p>通过 <code>FileReader</code>  我们可以将图片文件转化为 <code>DataURL</code> ，就是以 <code>data:image/png;base64</code>  开头的一种 <code>URL</code> ，然后可以直接放在 <code>image.src</code>  里，此时本地图片就会被显示出来。</p><h4 id="二、获取裁剪坐标"><a href="#二、获取裁剪坐标" class="headerlink" title="二、获取裁剪坐标"></a>二、获取裁剪坐标</h4><ul><li><code>mousedown</code></li></ul><p>这里要记录鼠标按下时的坐标，即 <code>startX</code>  和 <code>startY</code> ，同时将标识位 <code>startDrag</code>  设为 <code>true</code> ，标识鼠标开始移动。</p><pre><code class="javascript">const handleMouseDown = event =&gt; &#123;  setStartX(event.clientX);  setStartY(event.clientY);  setStartDrag(true);&#125;;</code></pre><ul><li><code>mousemove</code></li></ul><p>判断 <code>startDrag</code>  为 <code>true</code>（即鼠标开始移动），然后记录对应移动的距离。</p><pre><code class="javascript">const handleMouseMove = event =&gt; &#123;  if (startDrag) &#123;    drawImage(event.clientX - startX + lastX, event.clientY - startY + lastY);  &#125;&#125;;</code></pre><ul><li><code>mouseup</code></li></ul><p>这里要记录下最终鼠标的落点坐标，对应就是 <code>lastX</code>  与 <code>lastY</code>。</p><pre><code class="javascript">const handleMouseUp = event =&gt; &#123;  setLastX(event.clientX - startX + lastX);  setLastY(event.clientY - startY + lastY);  setStartDrag(false);&#125;;</code></pre><h4 id="三、裁剪图片"><a href="#三、裁剪图片" class="headerlink" title="三、裁剪图片"></a>三、裁剪图片</h4><p>将图片放置入 <code>canvas</code>  时需要调用 <code>drawImage</code> :</p><pre><code class="javascript">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</code></pre><pre><code class="javascript">const drawImage = (left = lastX, top = lastY) =&gt; &#123;  let image = imgRef.current,    canvas = canvasRef.current,    ctx = canvas.getContext(&quot;2d&quot;);  ctx.clearRect(0, 0, canvas.width, canvas.height);  let imageWidth = image.width,    imageHeight = image.height;  if (imageWidth &gt; imageHeight) &#123;    let scale = canvas.width / canvas.height;    imageWidth = canvas.width * times;    imageHeight = imageHeight * scale * times;  &#125; else &#123;    let scale = canvas.height / canvas.width;    imageHeight = canvas.height * times;    imageWidth = imageWidth * scale * times;  &#125;  ctx.drawImage(image, (canvas.width - imageWidth) / 2 + left, (canvas.height - imageHeight) / 2 + top, imageWidth, imageHeight);&#125;;</code></pre><p>加入了 <code>scale</code>，这个变量是用来实现图片放大、缩小效果的。同时会判断图片的宽、高的大小关系，从而实现图片在 <code>canvas</code>  中对应的适配。</p><h4 id="四、读取裁剪后的图片并上传"><a href="#四、读取裁剪后的图片并上传" class="headerlink" title="四、读取裁剪后的图片并上传"></a>四、读取裁剪后的图片并上传</h4><p>这时我们要获取 <code>canvas</code>  中图片的信息，用 <code>toDataURL</code>  就可以转换成上面用到的 <code>DataURL</code> 。</p><pre><code class="javascript">const confirm = () =&gt; &#123;  let canvas = canvasRef.current;  let ctx = canvas.getContext(&quot;2d&quot;);  const imageData = ctx.getImageData(100, 100, 100, 100);  let avatarCanvas = document.createElement(&quot;canvas&quot;);  avatarCanvas.width = 100;  avatarCanvas.height = 100;  let avatarCtx = avatarCanvas.getContext(&quot;2d&quot;);  avatarCtx.putImageData(imageData, 0, 0);  let avatarDataUrl = avatarCanvas.toDataURL();  setAvatarDataUrl(avatarDataUrl);  avatarRef.current.src = avatarDataUrl;&#125;;</code></pre><p>然后取出其中 <code>base64</code>  信息，再用 <code>window.atob</code>  转换成由二进制字符串。但 <code>window.atob</code>  转换后的结果仍然是字符串，直接给 <code>Blob</code>  还是会出错。所以又要用 <code>Uint8Array</code>  转换一下。</p><p>这时候裁剪后的文件就储存在 <code>blob</code>  里了,我们可以把它当作是普通文件一样，加入到 <code>FormData</code>  里，并上传至服务器了。</p><pre><code class="javascript">const upload = event =&gt; &#123;  // console.log(&quot;文件url&quot;, this.state.avatarDataUrl);  let bytes = atob(avatarDataUrl.split(&quot;,&quot;)[1]);  console.log(&quot;bytes&quot;, bytes);  let arrayBuffer = new ArrayBuffer(bytes.length);  let uInt8Array = new Uint8Array();  for (let i = 0; i &lt; bytes.length; i++) &#123;    uInt8Array[i] = bytes.charCodeAt[i];  &#125;  let blob = new Blob([arrayBuffer], &#123; type: &quot;image/png&quot; &#125;);  let xhr = new XMLHttpRequest();  let formData = new FormData();  formData.append(&quot;avatar&quot;, blob);  xhr.open(&quot;POST&quot;, &quot;/upload&quot;, true);  xhr.send(formData);&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https简介</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https%E7%AE%80%E4%BB%8B/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>https 是在 http 的基础上和 ssl/tls 证书结合起来的一种协议，保证了传输过程中的安全性，减少了恶意劫持的可能，很好的解决了 http 的三个缺点(被监听，被篡改，被伪装)<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703700828-253dff98-95a7-425f-b35f-c1a4c3e7b53f.png#align=left&display=inline&height=430&margin=%5Bobject%20Object%5D&name=https1.png&originHeight=430&originWidth=643&size=176587&status=done&style=none&width=643" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703700828-253dff98-95a7-425f-b35f-c1a4c3e7b53f.png#align=left&display=inline&height=430&margin=%5Bobject%20Object%5D&name=https1.png&originHeight=430&originWidth=643&size=176587&status=done&style=none&width=643" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https1.png"></p><h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><ul><li>对称加密</li></ul><blockquote><p>加密的密钥和解密的密钥相同</p></blockquote><ul><li>非对称加密</li></ul><blockquote><p>将密钥分为公钥和私钥，公钥可公开，私钥保密，客户端公钥加密的数据，服务端可以通过私钥解密。</p></blockquote><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><ul><li><code>http</code> 和 <code>https</code> 都需要在建立连接的基础上来进行数据传输</li><li>当客户在浏览器输入网址并按下回车，浏览器会在 <code>浏览器DNS缓存</code>，<code>本地DNS缓存</code> 以及 <code>host</code> 中寻找对应记录，如果没有获取到则会请求 <code>DNS</code> 服务来获取对应 <code>ip</code></li><li>获取到 <code>ip</code> 后，<code>tcp</code> 连接会进行三次握手建立连接</li></ul><h2 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703708786-c272a04f-2a68-45be-8a06-f8d5841f72aa.png#align=left&display=inline&height=497&margin=%5Bobject%20Object%5D&name=https2.png&originHeight=497&originWidth=500&size=35314&status=done&style=none&width=500" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703708786-c272a04f-2a68-45be-8a06-f8d5841f72aa.png#align=left&display=inline&height=497&margin=%5Bobject%20Object%5D&name=https2.png&originHeight=497&originWidth=500&size=35314&status=done&style=none&width=500" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https2.png"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>建立连接时，客户端发送 <code>SYN</code> 包(<code>syn=j</code>)到服务端，并进入 <code>SYN_SEND</code> 状态，等待服务器确认</li><li>服务器收到 <code>SYN</code> 包，向客户端返回 <code>ACK(ack=j+1)</code>，同时自己也发送一个 <code>SYN</code> 包 <code>(syn=k)</code>，即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RCVD</code> 状态</li><li>客户端收到服务端的 <code>SYN+ACK</code> 包，向服务器发送确认包 <code>ACK(ack=k+1)</code>，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code> 状态，完成三次握手</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li><code>TCP</code> 向客户端发送一个 <code>FIN</code>，用来关闭客户到服务器的数据传输</li><li>服务器收到这个 <code>FIN</code>，它返回一个 <code>ACK</code>，确认序号为收到的序号加 <code>1</code>，和 <code>SYN</code> 一样，一个 <code>FIN</code> 将占用一个序号</li><li>服务器关闭客户端连接，发送一个 <code>FIN</code> 给客户端</li><li>客户端发回 <code>ACK</code> 报文确认，并将确认序号设置为收到序号加 <code>1</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>在工作中，前端代码打包之后的生成的静态资源就要发布到静态服务器上，这时候就要做对这些静态资源做一些运维配置，其中，gzip 和 设置缓存是必不可少的。这两项是最直接影响到网站性能和用户体验的。</p><ul><li>缓存的优点</li></ul><ol><li>减少了不必要的数据传输，节省带宽</li><li>减少服务器的负担，提升网站性能</li><li>加快了客户端加载网页的速度</li><li>用户体验友好</li></ol><ul><li>缺点</li></ul><blockquote><p>资源如果有更改但是客户端不及时更新会造成用户获取信息滞后，如果老版本有 <code>bug</code> 的话，情况会更加糟糕。</p></blockquote><h2 id="强缓存（本地缓存）"><a href="#强缓存（本地缓存）" class="headerlink" title="强缓存（本地缓存）"></a>强缓存（本地缓存）</h2><ol><li>利用 <code>http</code> 头中的 <code>Expires</code> 和 <code>Cache-control</code> 两个字段控制的，用来表示资源的缓存时间。</li><li>强缓存中，普通刷新会忽略它，但不清除它，需要强制刷新。浏览器强制刷新，请求会带上 <code>Cache-control: no-cache</code> 和 <code>Pragma: no-cache</code></li></ol><h2 id="协商缓存（弱缓存）"><a href="#协商缓存（弱缓存）" class="headerlink" title="协商缓存（弱缓存）"></a>协商缓存（弱缓存）</h2><ol><li>协商缓存就是由服务器来确定缓存资源是否可用。所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求是否可以缓存访问。</li><li>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存。</li><li>主要涉及两组 <code>header</code> 字段：</li></ol><ul><li><code>Etag</code> 和 <code>If-None-Match</code></li><li><code>Last-Modified</code> 和 <code>If-Modified-Since</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><ol><li>在进行窗口的 <code>resize</code>、<code>scroll</code></li><li><code>输入框内容校验</code></li><li><code>mousedown</code>、<code>mousemove</code></li><li><code>keyup</code>, <code>keydown</code><br>等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用 <code>debounce</code>（防抖）和 <code>throttle</code>（节流）的方式来减少调用频率，同时又不影响实际效果。</li></ol></blockquote><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发 <code>scroll</code> 事件时，并不执行 <code>handle</code> 函数，当 <code>1s</code> 内没有触发 <code>scroll</code>事件时，才会延时触发 <code>scroll</code> 事件。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703595580-b3299f97-9961-476b-89e1-64db6b1090e5.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=%E9%98%B2%E6%8A%96.png&originHeight=150&originWidth=700&size=8748&status=done&style=none&width=700" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703595580-b3299f97-9961-476b-89e1-64db6b1090e5.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=%E9%98%B2%E6%8A%96.png&originHeight=150&originWidth=700&size=8748&status=done&style=none&width=700" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="防抖.png"></p><h3 id="传统防抖"><a href="#传统防抖" class="headerlink" title="传统防抖"></a>传统防抖</h3><h4 id="最简单的防抖"><a href="#最简单的防抖" class="headerlink" title="最简单的防抖"></a>最简单的防抖</h4><pre><code class="javascript">function debounce(fn, wait) &#123;  var timer = null;  return function () &#123;    if (timer !== null) &#123;      clearTimeout(timer);      timer = setTimeout(fn, wait);    &#125;  &#125;;&#125;// 处理函数function hanlder() &#123;  console.log(parseInt(Math.random()));&#125;// 事件window.addEventListener(&quot;scroll&quot;, debounce(handler, 1000));</code></pre><h4 id="修改-this"><a href="#修改-this" class="headerlink" title="修改 this"></a>修改 this</h4><blockquote><p>在 <code>debounce</code> 包裹后的 <code>fn</code> 中我们输出 <code>this</code> 会指向 <code>window</code> 对象，而有些情况下 <code>fn</code> 内的 <code>this</code> 并不指向 <code>window</code>，所以修正后的 <code>防抖函数</code> 如下</p></blockquote><pre><code class="javascript">function debounce(fn, wait) &#123;  var timer = null;  return function () &#123;    var context = this;    if (timer !== null) &#123;      clearTimeout(timer);      timer = setTimeout(function () &#123;        fn.apply(context);      &#125;, wait);    &#125;  &#125;;&#125;</code></pre><h4 id="传递-event-事件对象"><a href="#传递-event-事件对象" class="headerlink" title="传递 event 事件对象"></a>传递 event 事件对象</h4><blockquote><p>在 <code>debounce</code> 包裹后的 <code>fn</code> 中我们输出 <code>event</code> 为 <code>undefined</code>，而不被包裹的 <code>fn</code> 中将输出相应的事件源，所以修正后的 <code>防抖函数</code> 如下</p></blockquote><pre><code class="javascript">function debounce(fn, wait) &#123;  var timer = null;  return function () &#123;    var context = this;    var args = arguments;    if (timer !== null) &#123;      clearTimeout(timer);      timer = setTimeout(function () &#123;        fn.apply(context, args);      &#125;, wait);    &#125;  &#125;;&#125;</code></pre><h3 id="立即执行的防抖"><a href="#立即执行的防抖" class="headerlink" title="立即执行的防抖"></a>立即执行的防抖</h3><blockquote><p>某些时候，我们不希望非要等到事件停止触发后才执行相应逻辑，希望立刻执行函数，但是要等到停止触发 <code>n</code> 秒后，才可以重新触发执行。<br>此时我们需要增加 <code>immediate</code> 参数来进行控制是否立即执行。</p></blockquote><pre><code class="javascript">function debounce(func, wait, immediate) &#123;  var timer = null;  return function () &#123;    var context = this;    var args = arguments;    if (timer != null) &#123;      clearTimeout(timer);    &#125;    if (immediate) &#123;      // 立即执行      timer = setTimeout(function () &#123;        timer = null;      &#125;, wait);      if (!timer) &#123;        fn.apply(context, args);      &#125;    &#125; else &#123;      timer = setTimeout(function () &#123;        fn.apply(context, args);      &#125;, wait);    &#125;  &#125;;&#125;</code></pre><blockquote><p>此时注意一点，就是 <code>fn</code> 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 <code>immediate</code> 为  <code>false</code> 的时候，因为使用了 <code>setTimeout</code> ，我们将 <code>fn.apply(context, args)</code> 的返回值赋给变量，最后再 <code>return</code> 的时候，值将会一直是 <code>undefined</code>，所以我们只在 <code>immediate</code> 为 <code>true</code> 的时候返回函数的执行结果。</p></blockquote><pre><code class="javascript">function debounce(func, wait, immediate) &#123;  var timer = null;  var result;  return function () &#123;    var context = this;    var args = arguments;    if (timer != null) &#123;      clearTimeout(timer);    &#125;    if (immediate) &#123;      // 立即执行      timer = setTimeout(function () &#123;        timer = null;      &#125;, wait);      if (!timer) &#123;        result = fn.apply(context, args);      &#125;    &#125; else &#123;      timer = setTimeout(function () &#123;        fn.apply(context, args);      &#125;, wait);    &#125;    return result;  &#125;;&#125;</code></pre><h3 id="可以取消的防抖"><a href="#可以取消的防抖" class="headerlink" title="可以取消的防抖"></a>可以取消的防抖</h3><blockquote><p>新的需求是希望能取消 <code>debounce</code> 函数，比如说 <code>debounce</code> 的时间间隔是 <code>10</code> 秒钟，<code>immediate</code> 为 <code>true</code>，这样的话，我只有等 <code>10</code> 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行。</p></blockquote><pre><code class="javascript">function debounce(func, wait, immediate) &#123;  var timer = null;  var result;  var debounceCallback = function () &#123;    var context = this;    var args = arguments;    if (timer != null) &#123;      clearTimeout(timer);    &#125;    if (immediate) &#123;      // 立即执行      timer = setTimeout(function () &#123;        timer = null;      &#125;, wait);      if (!timer) &#123;        result = fn.apply(context, args);      &#125;    &#125; else &#123;      timer = setTimeout(function () &#123;        fn.apply(context, args);      &#125;, wait);    &#125;    return result;  &#125;;  debounceCallback.cancel = function () &#123;    clearTimeout(timer);    timer = null;  &#125;;  return debounceCallback;&#125;</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote><p>当持续触发事件时，保证 <code>一定时间段内只调用一次</code> 事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发 <code>scroll</code> 事件时，并不立即执行 <code>handle</code> 函数，每隔 <code>1s</code> 才会执行一次 <code>handle</code> 函数。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703615184-c4c3dd6f-7242-4dfb-a924-fe04be39ae04.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=%E8%8A%82%E6%B5%81.png&originHeight=323&originWidth=330&size=8046&status=done&style=none&width=330" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703615184-c4c3dd6f-7242-4dfb-a924-fe04be39ae04.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=%E8%8A%82%E6%B5%81.png&originHeight=323&originWidth=330&size=8046&status=done&style=none&width=330" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="节流.png"></p><h3 id="时间戳法"><a href="#时间戳法" class="headerlink" title="时间戳法"></a>时间戳法</h3><blockquote><p>当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p></blockquote><pre><code class="javascript">var throttle = function (func, delay) &#123;  var prev = Date.now();  return function () &#123;    var now = Date.now();    var context = this;    var args = arguments;    if (now - prev &gt;= delay) &#123;      func.apply(context, args);      prev = Date.now();    &#125;  &#125;;&#125;;function handler() &#123;  console.log(parseInt(Math.random()));&#125;window.addEventListener(&quot;scroll&quot;, throttle(handler, 1000));</code></pre><h3 id="定时器法"><a href="#定时器法" class="headerlink" title="定时器法"></a>定时器法</h3><blockquote><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p></blockquote><pre><code class="javascript">var throttle = function (func, delay) &#123;  var timer = null;  return function () &#123;    var context = this;    var args = arguments;    if (!timer) &#123;      timer = setTimeout(function () &#123;        func.apply(context, args);        timer = null;      &#125;, delay);    &#125;  &#125;;&#125;;function handle() &#123;  console.log(Math.random());&#125;window.addEventListener(&quot;scroll&quot;, throttle(handle, 1000));</code></pre><h3 id="时间戳法和定时器法的比较"><a href="#时间戳法和定时器法的比较" class="headerlink" title="时间戳法和定时器法的比较"></a>时间戳法和定时器法的比较</h3><blockquote><p>时间戳法中事件会立即执行，定时器法会在 n 秒之后第一次执行<br>时间戳法中事件停止触发后没有办法再执行事件，定时器法中事件停止触发后依然会再执行一次事件</p></blockquote><h3 id="最终加强版本"><a href="#最终加强版本" class="headerlink" title="最终加强版本"></a>最终加强版本</h3><blockquote><p>第一次立即执行，最后一次停止后仍会执行一次</p></blockquote><pre><code class="javascript">function throttle(func, delay) &#123;  var timer = null;  var startTime = Date.now();  var context;  var args;  var later = function () &#123;    startTime = Date.now();    timer = null;    func.apply(context, args);  &#125;;  return function () &#123;    var currentTime = Date.now();    var remaining = delay - (currentTime - startTime);    context = this;    args = arguments;    // 如果没有剩余的时间或者自行修改了系统时间    if (remaining &lt;= 0 || remaining &gt; wait) &#123;      func.apply(context, args);      startTime = Date.now();      if (timer) &#123;        clearTimeout(timer);        timer = null;      &#125;    &#125;    if (!timer) &#123;      timer = setTimeout(func, remaining);    &#125;  &#125;;&#125;</code></pre><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul><li>包括第一次立即执行，最后一次停止后不执行；第一次不立即执行，最后一次停止后再执行一次；取消节流；</li></ul><pre><code class="javascript">function throttle(func, wait, options) &#123;  var timer = null;  var startTime = Date.now();  var context;  var args;  if (!options) options = &#123;&#125;;  var later = function () &#123;    startTime = options.leading === false ? 0 : Date.now();    timer = null;    func.apply(context, args);    if (!timer) context = args = null;  &#125;;  var throttled = function () &#123;    var now = Date.now();    if (!startTime &amp;&amp; options.leading === false) startTime = now;    var remaining = wait - (now - startTime);    context = this;    args = arguments;    if (remaining &lt;= 0 || remaining &gt; wait) &#123;      if (timer) &#123;        clearTimeout(timer);        timer = null;      &#125;      startTime = now;      func.apply(context, args);      if (!timer) context = args = null;    &#125; else if (!timer &amp;&amp; options.trailing !== false) &#123;      timer = setTimeout(later, remaining);    &#125;  &#125;;  throttled.cancel = function () &#123;    clearTimeout(timeout);    startTime = 0;    timeout = null;  &#125;;  return throttled;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>防抖</li></ul><blockquote><p><code>将几次操作合并为一此操作进行</code>。原理是维护一个计时器，规定在 <code>delay</code> 时间后触发函数，但是在 <code>delay</code> 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p></blockquote><ul><li>节流</li></ul><blockquote><p><code>使得一定时间内只触发一次函数</code>。原理是通过判断是否到达一定时间来触发函数。</p></blockquote><blockquote><p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 <code>Ajax</code> 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 调试技巧</title>
      <link href="Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>Chrome%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官方文档: <a href="https://developers.google.com/" target="_blank" rel="noopener external nofollow noreferrer">https://developers.google.com/</a></p></blockquote><blockquote><p>隆重感谢: <a href="https://juejin.cn/book/6844733783166418958" target="_blank" rel="noopener external nofollow noreferrer">掘金小册-你不知道的 Chrome 调试技巧</a></p></blockquote><h3 id="1、快速打印想要的-dom-元素"><a href="#1、快速打印想要的-dom-元素" class="headerlink" title="1、快速打印想要的 dom 元素"></a>1、快速打印想要的 dom 元素</h3><ul><li>控制台输入 <code>$0</code>  即可打印出当前指针所选中的元素</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="2、如何给-Dom-元素打断点"><a href="#2、如何给-Dom-元素打断点" class="headerlink" title="2、如何给 Dom 元素打断点"></a>2、如何给 Dom 元素打断点</h3><ul><li>鼠标右键选中元素，选中 <code>Break on</code>。</li><li><code>subtree modifications</code> 监听任何它内部的节点被 <code>移除</code> 或者 <code>添加</code>的事件</li><li><code>Break &gt; attribute modifications</code>  监听任何当前选中的节点被 <code>添加</code>，<code>移除</code> 或者 <code>被修改值</code>的事件。此时属性被修改后将会产生断点调试。</li><li><code>Break &gt; node removal</code>  监听被选中的元素被 <code>移除</code> 的事件。此时属性被删除后将会产生断点调试。</li></ul><h3 id="3、debug-函数"><a href="#3、debug-函数" class="headerlink" title="3、debug 函数"></a>3、debug 函数</h3><ul><li>可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="4、console-log-添加样式"><a href="#4、console-log-添加样式" class="headerlink" title="4、console.log 添加样式"></a>4、console.log 添加样式</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="5、发现问题并定位代码的内存泄漏"><a href="#5、发现问题并定位代码的内存泄漏" class="headerlink" title="5、发现问题并定位代码的内存泄漏"></a>5、发现问题并定位代码的内存泄漏</h3><ul><li>选中 <code>Memory &gt; Heap snapshot</code>  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。</li><li>选中垃圾回收按钮右侧下拉菜单里的 <code>Comparison</code> ，即可将选中的快照与它上一次快照进行对比。如 <code>delta</code>  的数据对比，从而快速定位到问题出现的位置。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="6、-快速选中元素"><a href="#6、-快速选中元素" class="headerlink" title="6、$ 快速选中元素"></a>6、$ 快速选中元素</h3><ul><li>Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="7、使用-chrome-调试-node-js-程序"><a href="#7、使用-chrome-调试-node-js-程序" class="headerlink" title="7、使用 chrome 调试 node.js 程序"></a>7、使用 chrome 调试 node.js 程序</h3><ul><li><code>node --inspect-brk 文件名</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="8、点击一个元素，获取下面所有代码执行过程"><a href="#8、点击一个元素，获取下面所有代码执行过程" class="headerlink" title="8、点击一个元素，获取下面所有代码执行过程"></a>8、点击一个元素，获取下面所有代码执行过程</h3><ul><li>方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 <code>debug</code>，确定执行过程。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>方案 2: 找到当前点击所造成的影响（如：删除元素， <code>XHR</code>）等，通过点击 <code>Break &gt; node removal</code> 等操作，在造成影响的位置下断点，通过查看 <code>call stack</code> 查看执行过程。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><ul><li>方案 3: 使用 <code>getEventListeners</code> 获取 <code>Dom</code> 元素上绑定的事件。(注意：此方法只能在 <code>Chrome</code> 控制台使用)</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="9、如何使用-Chrome-调试-Webpack-程序"><a href="#9、如何使用-Chrome-调试-Webpack-程序" class="headerlink" title="9、如何使用 Chrome 调试 Webpack 程序"></a>9、如何使用 Chrome 调试 Webpack 程序</h3><ol><li>在想要调试的代码为止使用 debugger 打断点</li><li>定位 webpack-dev-server 的命令文件</li><li>使用 node --inspect-brk 打开调试服务</li><li>打开 chrome devtool 进行调试</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="10、使用错误断点，让程序在错误处暂停"><a href="#10、使用错误断点，让程序在错误处暂停" class="headerlink" title="10、使用错误断点，让程序在错误处暂停"></a>10、使用错误断点，让程序在错误处暂停</h3><ul><li>方案 1: 在控制面板里直接点击错误信息</li><li>方案 2: 点击 <code>Sources</code>  后点击 <code>Pause on exceptions</code>  最后勾选 <code>Pause on exceptions</code>。之后刷新页面即可</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="11、使用-Chrome-作为代码编辑工具"><a href="#11、使用-Chrome-作为代码编辑工具" class="headerlink" title="11、使用 Chrome 作为代码编辑工具"></a>11、使用 Chrome 作为代码编辑工具</h3><ul><li>选中 <code>Sources &gt; Filesystem</code>  然后关联本地文件夹即可</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码"><a href="#12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码" class="headerlink" title="12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码"></a>12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码</h3><ul><li>选中 <code>Sources &gt; Snippets</code>  创建新的代码片段</li><li>输入 <code>Command + p</code>  后输入 <code>i</code>  后执行</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="13、使用-Chome-实时保存更改的-css-样式"><a href="#13、使用-Chome-实时保存更改的-css-样式" class="headerlink" title="13、使用 Chome 实时保存更改的 css 样式"></a>13、使用 Chome 实时保存更改的 css 样式</h3><ul><li>选中 <code>Source &gt; Overrides</code> ，之后点击 <code>+</code>  选择一个本地文件夹用来保存更改后的样式，最后勾选 <code>Enable Local Overrides</code> 。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比"><a href="#14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比" class="headerlink" title="14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比"></a>14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比</h3><ul><li>输入 <code>Command + shift + p</code> ，搜索 <code>show changes</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="15、查看-Chrome-请求是由谁发起的"><a href="#15、查看-Chrome-请求是由谁发起的" class="headerlink" title="15、查看 Chrome 请求是由谁发起的"></a>15、查看 Chrome 请求是由谁发起的</h3><ul><li>选择 <code>NetWork &gt; Initialtor</code> ，不但可以查看调用位置，也可获取触发位置。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="16、Chrome-性能监测工具"><a href="#16、Chrome-性能监测工具" class="headerlink" title="16、Chrome 性能监测工具"></a>16、Chrome 性能监测工具</h3><ul><li><code>Command + shift + p</code>  输入 <code>show performance monitor</code>  即可实时查看程序运行的性能。<ul><li><code>CPU usage</code> ： <code>cpu</code> 的监听</li><li><code>JS heap size</code> : 内存占用监听，如添加到 <code>window</code>  对象上的事件不回收会造成内存溢出。</li><li><code>DOM Nodes</code>: 内存中所分配的 <code>dom</code> 节点的个数</li><li><code>JS envnt listeners</code>: <code>js</code> 中已经绑定的事件个数</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="17、使用-Chrome-做性能调优，迅速定位问题"><a href="#17、使用-Chrome-做性能调优，迅速定位问题" class="headerlink" title="17、使用 Chrome 做性能调优，迅速定位问题"></a>17、使用 Chrome 做性能调优，迅速定位问题</h3><ul><li>选择 <code>performance</code>  点击录制按钮，可以查看从录制开始到停止时间内 <code>js</code> 代码运行的情况。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率"><a href="#18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率" class="headerlink" title="18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率"></a>18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率</h3><ul><li><code>Command + shift + p</code>  输入 <code>show animations</code>  打开动画的调试器。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况"><a href="#19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况" class="headerlink" title="19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况"></a>19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况</h3><ul><li><code>Command + shift +p</code>  输入 <code>show coverage</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></p><h3 id="20、copy-复制控制台内容"><a href="#20、copy-复制控制台内容" class="headerlink" title="20、copy() 复制控制台内容"></a>20、copy() 复制控制台内容</h3><ul><li>可以通过全局的方法  <code>copy()</code>  在  <code>console</code>  里  <code>copy</code>  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  <code>copy($_)</code>  或  <code>copy($0)</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="21、-查看上一次程序执行结果"><a href="#21、-查看上一次程序执行结果" class="headerlink" title="21、$_查看上一次程序执行结果"></a>21、$_查看上一次程序执行结果</h3><ul><li><code>$_</code>  是对上次执行的结果的 <strong>引用</strong></li></ul><p>**<br><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png"></strong></p><h3 id="22、-i-配合-chrome-插件引入第三方包"><a href="#22、-i-配合-chrome-插件引入第三方包" class="headerlink" title="22、$i 配合 chrome 插件引入第三方包"></a>22、$i 配合 chrome 插件引入第三方包</h3><ul><li>有时你只是想玩玩新出的 <code>npm</code> 包，现在不用再大费周章去建一个项目测试了，只需要在 <a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related" target="_blank" rel="noopener external nofollow noreferrer">Chrome 插件:Console Importer</a> 的帮助之下，快速的在 <code>console</code> 中引入和测试一些 <code>npm</code> 库。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="23、使用实时表达式"><a href="#23、使用实时表达式" class="headerlink" title="23、使用实时表达式"></a>23、使用实时表达式</h3><ul><li><code>DevTools</code> 在 <code>Console</code> 面板中引入了一个非常漂亮的附加功能，这是一个名为 <code>Live expression</code> 的工具。只需按下 &quot;眼睛&quot; 符号，你就可以在那里定义任何 <code>JavaScript</code> 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="24、通过-39-h-39-来隐藏元素"><a href="#24、通过-39-h-39-来隐藏元素" class="headerlink" title="24、通过 &#39;h&#39; 来隐藏元素"></a>24、通过 &#39;h&#39; 来隐藏元素</h3><ul><li>按一下  <code>&#39;h&#39;</code>  就可以隐藏你在元素面板中选择的元素。再次按下 &#39;<code>h</code>&#39; 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="25、拖动-amp-放置-元素"><a href="#25、拖动-amp-放置-元素" class="headerlink" title="25、拖动 &amp; 放置 元素"></a>25、拖动 &amp; 放置 元素</h3><ul><li>当你想看看页面的某一部分在  <code>DOM</code>  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2.gif"></p><h3 id="26、使用-control-按钮-来移动元素"><a href="#26、使用-control-按钮-来移动元素" class="headerlink" title="26、使用 control (按钮) 来移动元素!"></a>26、使用 <code>control</code> (按钮) 来移动元素!</h3><ul><li>如果你只是想移动你当前选中的元素，在  <code>DOM</code>  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用<code>[ctrl]</code> + <code>[⬆]</code> / <code>[ctrl]</code> + <code>[⬇]</code> (<code>[⌘]</code> + <code>[⬆]</code> / <code>[⌘]</code> + <code>[⬇]</code> on Mac).</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3.gif"></p><h3 id="27、元素面板中类似于基础编辑器的操作"><a href="#27、元素面板中类似于基础编辑器的操作" class="headerlink" title="27、元素面板中类似于基础编辑器的操作"></a>27、元素面板中类似于基础编辑器的操作</h3><ul><li><p>从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 <code>[ctrl]</code> + <code>[v]</code> 来粘贴)， 所以我们可以在元素面板里把 <code>HTML</code> 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？</p></li><li><p>使用<code>[ctrl]</code> + <code>[z]</code> (<code>[⌘]</code> + <code>[z]</code> on Mac)撤销我们的任何改动。 使用 <code>[ctrl]</code> + <code>[shift]</code> + <code>[z]</code>重新编辑我们的任何修改。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="28、Shadow-editor-阴影编辑器"><a href="#28、Shadow-editor-阴影编辑器" class="headerlink" title="28、Shadow editor 阴影编辑器"></a>28、<code>Shadow editor</code> 阴影编辑器</h3><ul><li>你可以通过在  <code>Style</code>  面板中点击靠近  <code>box-shadow</code>  属性或者  <code>text-shadow</code>  属性的  <code>阴影方形符号</code>  来打开它：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="29、Timing-function-editor-定时函数编辑器"><a href="#29、Timing-function-editor-定时函数编辑器" class="headerlink" title="29、Timing function editor 定时函数编辑器"></a>29、Timing function editor 定时函数编辑器</h3><ul><li><p>也称为 <code>Cubic bezier(贝塞尔)</code> 编辑器。贝塞尔曲线是一串用来定义 <code>CSS</code> 的动画速度在整个动画过程中如何变化的 <code>魔法数值</code> 。我们将其定义为 <code>transition-timing-function</code> 或者 <code>animation-timing-function</code> CSS 属性。</p></li><li><p>像之前说的 <code>Color picker</code> 和 <code>Shadow editor</code> 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：<code>trasition</code>， <code>animation</code> - 请注意：如果<code>timing</code> 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="30、插入样式规则的按钮"><a href="#30、插入样式规则的按钮" class="headerlink" title="30、插入样式规则的按钮"></a>30、插入样式规则的按钮</h3><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 <code>Color</code> 和 <code>Shadow</code> 编辑器添加 <code>CSS</code> 属性的按钮：</p><ul><li><p><code>text-shadow</code></p></li><li><p><code>box-shadow</code></p></li><li><p><code>color</code></p></li><li><p><code>background-color</code></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="31、在元素面板中展开所有的子节点"><a href="#31、在元素面板中展开所有的子节点" class="headerlink" title="31、在元素面板中展开所有的子节点"></a>31、在元素面板中展开所有的子节点</h3><ul><li>一个一个的去点击级联的  <code>▶</code>  按钮太慢了，不如使用右击节点后的  <code>expand recursively</code>  命令：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p><h3 id="32、控制传感器"><a href="#32、控制传感器" class="headerlink" title="32、控制传感器"></a>32、控制传感器</h3><ul><li><p>如果你正在你的应用中使用一些获取位置信息的 <code>API</code> 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。</p></li><li><p><code>Drawer</code> 里的 <code>Sensors(传感器)</code> 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 <code>navigator.geolocation.watchPosition</code>（或 <code>.getCurrentPosition</code> ）报告。</p></li><li><p>如果你的 <code>App</code> 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 使用技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF/TypeScript%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF/TypeScript%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-基础类型"><a href="#一、-基础类型" class="headerlink" title="一、 基础类型"></a>一、 基础类型</h2><h3 id="1-1-类型断言"><a href="#1-1-类型断言" class="headerlink" title="1.1 类型断言"></a>1.1 类型断言</h3><blockquote><p>有时候你会遇到这样的情况，你会比 <code>TypeScript</code> 更了解某个值的详细信息。通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。类型断言好比其它语言里的类型转换，但是不尽兴特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p></blockquote><ul><li><p>类型断言有两种形式</p></li><li><p>第一种：尖括号语法 (当在 <code>TypeScript</code> 里使用 <code>JSX</code> 时，只有 <code>as</code> 语言断言是被允许的)</p></li></ul><pre><code class="typescript">let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length;</code></pre><ul><li>第二种：<code>as</code> 语法</li></ul><pre><code class="typescript">let _someValue: any = &quot;this is a string&quot;;let _strLength: number = (_someValue as string).length;</code></pre><h3 id="1-2-基础类型"><a href="#1-2-基础类型" class="headerlink" title="1.2 基础类型"></a>1.2 基础类型</h3><h4 id="1-2-1-布尔值"><a href="#1-2-1-布尔值" class="headerlink" title="1.2.1 布尔值"></a>1.2.1 布尔值</h4><pre><code class="typescript">let isDone: boolean = false;</code></pre><h4 id="1-2-2-数字"><a href="#1-2-2-数字" class="headerlink" title="1.2.2 数字"></a>1.2.2 数字</h4><blockquote><p>与 <code>javascript</code> 一样，<code>TypeScript</code> 里的所有数字都是浮点数。这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量， <code>TypeScript</code> 还支持 <code>ECMA2015</code> 中引入的二进制和八进制字面量。</p></blockquote><pre><code class="typescript">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744;</code></pre><h4 id="1-2-3-字符串"><a href="#1-2-3-字符串" class="headerlink" title="1.2.3 字符串"></a>1.2.3 字符串</h4><pre><code class="typescript">let strName: string = &quot;bob&quot;;</code></pre><h4 id="1-2-4-数组"><a href="#1-2-4-数组" class="headerlink" title="1.2.4 数组"></a>1.2.4 数组</h4><blockquote><p><code>TypeScript</code> 像 <code>JavaScript</code> 一样可以操作数组元素。有两种方法定义数组。</p></blockquote><ul><li>第一种：可以在元素类型后面接上 <code>[]</code>;</li></ul><pre><code class="typescript">let list1: number[] = [1, 2, 3];</code></pre><ul><li>第二种：使用数组泛型, <code>Array&lt;元素类型&gt;</code></li></ul><pre><code class="typescript">let list2: Array&lt;number&gt; = [1, 2, 3];</code></pre><h4 id="1-2-5-元组-Tuple"><a href="#1-2-5-元组-Tuple" class="headerlink" title="1.2.5 元组 Tuple"></a>1.2.5 元组 Tuple</h4><ul><li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</li></ul><pre><code class="typescript">let x: [string, number];x = [&quot;hello&quot;, 10]; // =&gt; Okx = [10, &quot;hello&quot;]; // =&gt; Error</code></pre><ul><li>当访问一个已知索引的元素，会得到正确的类型</li></ul><pre><code class="typescript">console.log(x[0].substr(1)); // =&gt; Okconsole.log(x[1].substr(1)); // =&gt; Error</code></pre><ul><li>当访问一个越界的元素，会使用联合类型替代</li></ul><pre><code class="typescript">x[3] = &quot;world&quot;; // Ok, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // Ok, &quot;string&quot;和&quot;number&quot;都有toString方法x[6] = true; // Error, 布尔不是(string | number)类型</code></pre><h4 id="1-2-6-枚举"><a href="#1-2-6-枚举" class="headerlink" title="1.2.6 枚举"></a>1.2.6 枚举</h4><ul><li><code>enum</code> 类型是对 <code>JavaScript</code> 标准数据类型的一个补充。像 <code>C#</code> 等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字</li></ul><pre><code class="typescript">enum Color &#123;  Red,  Green,  Blue&#125;let c: Color = Color.Green;</code></pre><ul><li>默认情况下，从 <code>0</code> 开始为元素编号。你也可以手动的指定成员的数值。</li></ul><pre><code class="typescript">enum Color1 &#123;  Red = 1,  Green,  Blue&#125;let c1: Color1 = Color1.Green;</code></pre><ul><li>或者全部采用赋值</li></ul><pre><code class="typescript">enum Color2 &#123;  Red = 1,  Green = 2,  Blue = 4&#125;let c2: Color2 = Color2.Green;</code></pre><ul><li>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。</li></ul><pre><code class="typescript">enum Color3 &#123;  Red = 1,  Green,  Blue&#125;let colorName: string = Color3[2];console.log(colorName);</code></pre><h4 id="1-2-7-Any"><a href="#1-2-7-Any" class="headerlink" title="1.2.7 Any"></a>1.2.7 Any</h4><ul><li>有时候，我们想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方库。这种情况下，我们不希望类型检查器对这些值进行检查而是让它们通过编译阶段的检查。那么我们可以使用 <code>any</code> 类型来标记这些变量</li></ul><pre><code class="typescript">let notSure: any = 4;notSure = &quot;maybe a string instead&quot;;notSure = false; // Ok</code></pre><ul><li>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。你可能认为 <code>Object</code> 有相似的作用，就像在其他语言中那样。但是 <code>Object</code> 类型的变量只是允许你给他赋任意值，但是却不能够在它上面调用任意的方法，即使它真有这些方法。</li></ul><pre><code class="typescript">let notSure1: any = 4;notSure1.ifItExists(); // OknotSure1.toFixed(); // Oklet prettySure: Object = 4;// prettySure.toFixed(); // Error, Property &#39;toFixed&#39; doesn&#39;t exist on type &#39;Object&#39;.</code></pre><ul><li>当你只知道一部分数据类型时，<code>any</code> 类型也是有用的。</li></ul><pre><code class="typescript">let list: any[] = [1, true, &quot;free&quot;];list[1] = 100;</code></pre><h4 id="1-2-8-Void"><a href="#1-2-8-Void" class="headerlink" title="1.2.8 Void"></a>1.2.8 Void</h4><ul><li>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>。</li></ul><pre><code class="typescript">function warnUser(): void &#123;  console.log(&quot;This is my warning message&quot;);&#125;</code></pre><ul><li>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code></li></ul><pre><code class="typescript">let unusbale: void = undefined;</code></pre><h4 id="1-2-9-Null-和-Undefined"><a href="#1-2-9-Null-和-Undefined" class="headerlink" title="1.2.9 Null 和 Undefined"></a>1.2.9 Null 和 Undefined</h4><ul><li><code>TypeScript</code> 里，<code>undefined</code> 和 <code>null</code> 两者各有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。和 <code>void</code> 相似，它们本身的类型用处不是很大。</li></ul><pre><code class="typescript">let u: undefined = undefined;let n: null = null;</code></pre><ul><li>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</li><li>然而，当你指定了一个 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自。这能避免很多常见的问题。也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。</li></ul><h4 id="1-2-10-Never"><a href="#1-2-10-Never" class="headerlink" title="1.2.10 Never"></a>1.2.10 Never</h4><ul><li><code>never</code> 类型表示的是那些永不存在的值的类型。例如：<code>never</code> 类型是那些总会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型；</li><li>变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</li><li><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；</li></ul><blockquote><p>然而，没有类型是 <code>never</code> 的子类型或可以赋值给 <code>never</code> 类型(除了 <code>never</code> 本身之外)。即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p></blockquote><pre><code class="typescript">// 返回 never 的函数必须存在无法达到的终点function error(message: string): never &#123;  throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123;  return error(&quot;Something failed&quot;);&#125;// 返回 never 的函数必须存在法达到的终点function infiniteLoop(): never &#123;  while (true) &#123;&#125;&#125;</code></pre><h4 id="1-2-11-Object"><a href="#1-2-11-Object" class="headerlink" title="1.2.11 Object"></a>1.2.11 Object</h4><ul><li><code>Object</code> 表示非原始类型，也就是除 <code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code> 或 <code>undefined</code> 之外的类型。</li><li>使用 <code>Object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。</li></ul><pre><code class="typescript">declare function create(o: object | null): void;create(&#123; prop: 0 &#125;); // Okcreate(null); // Okcreate(42); //Errorcreate(&quot;string&quot;); // Errorcreate(false); // Errorcreate(undefined); // Error</code></pre><h2 id="二、变量声明"><a href="#二、变量声明" class="headerlink" title="二、变量声明"></a>二、变量声明</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><blockquote><p><code>let</code> 和 <code>const</code> 是 <code>JavaScript</code> 里相对较新的变量声明方式。 像我们之前提到过的， <code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 <code>JavaScript</code> 里常见一些问题。 <code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。<br>因为 <code>TypeScript</code> 是 <code>JavaScript</code> 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code> 。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。<br>如果你之前使用 <code>JavaScript</code> 时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p></blockquote><h3 id="2-2-var-声明"><a href="#2-2-var-声明" class="headerlink" title="2.2 var 声明"></a>2.2 var 声明</h3><blockquote><p>一直以来我们都是通过 <code>var</code> 关键字定义 <code>JavaScript</code> 变量。</p></blockquote><pre><code class="typescript">var a = 10;</code></pre><blockquote><p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。<br>我们也可以在函数内部定义变量：</p></blockquote><pre><code class="typescript">function f() &#123;  var message = &quot;Hello, world!&quot;;  return message;&#125;</code></pre><blockquote><p>并且我们也可以在其它函数内部访问相同的变量。</p></blockquote><pre><code class="typescript">function f() &#123;  var a = 10;  return function g() &#123;    var b = a + 1;    return b;  &#125;;&#125;var g = f();g(); // returns 11;</code></pre><blockquote><p>上面的例子里，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问及修改 <code>a</code>。</p></blockquote><pre><code class="typescript">function f() &#123;  var a = 1;  a = 2;  var b = g();  a = 3;  return b;  function g() &#123;    return a;  &#125;&#125;f(); // returns 2</code></pre><h3 id="2-3-作用域规则"><a href="#2-3-作用域规则" class="headerlink" title="2.3 作用域规则"></a>2.3 作用域规则</h3><blockquote><p>对于熟悉其它语言的人来说，<code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p></blockquote><pre><code class="typescript">function f(shouldInitialize: boolean) &#123;  if (shouldInitialize) &#123;    var x = 10;  &#125;  return x;&#125;f(true); // returns &#39;10&#39;f(false); // returns &#39;undefined&#39;</code></pre><blockquote><p>有些读者可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面_，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 <code>var</code> 作用域或函数作用域。函数参数也使用函数作用域。<br>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p></blockquote><pre><code class="typescript">function sumMatrix(matrix: number[][]) &#123;  var sum = 0;  for (var i = 0; i &lt; matrix.length; i++) &#123;    var currentRow = matrix[i];    for (var i = 0; i &lt; currentRow.length; i++) &#123;      sum += currentRow[i];    &#125;  &#125;  return sum;&#125;</code></pre><blockquote><p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p></blockquote><h3 id="2-4-捕获变量怪异之处"><a href="#2-4-捕获变量怪异之处" class="headerlink" title="2.4 捕获变量怪异之处"></a>2.4 捕获变量怪异之处</h3><blockquote><p>快速的猜一下下面的代码会返回什么：</p></blockquote><pre><code class="typescript">for (var i = 0; i &lt; 10; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, 100 * i);&#125;</code></pre><blockquote><p>介绍一下，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。<br>好吧，看一下结果：</p></blockquote><pre><code class="typescript">10;10;10;10;10;10;10;10;10;10;</code></pre><blockquote><p>很多 <code>JavaScript</code> 程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p></blockquote><pre><code class="typescript">0;1;2;3;4;5;6;7;8;9;</code></pre><blockquote><p>还记得我们上面提到的捕获变量吗？<br>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。<br>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。 <code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10！</code><br>一个通常的解决方法是使用立即执行的函数表达式（<code>IIFE</code>）来捕获每次迭代时 <code>i</code> 的值：</p></blockquote><pre><code class="typescript">for (var i = 0; i &lt; 10; i++) &#123;  // capture the current state of &#39;i&#39;  // by invoking a function with its current value  (function (i) &#123;    setTimeout(function () &#123;      console.log(i);    &#125;, 100 * i);  &#125;)(i);&#125;</code></pre><blockquote><p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p></blockquote><h3 id="2-5-let-声明"><a href="#2-5-let-声明" class="headerlink" title="2.5 let 声明"></a>2.5 let 声明</h3><blockquote><p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， let 与 <code>var</code> 的写法一致。</p></blockquote><pre><code class="typescript">let hello = &quot;Hello!&quot;;</code></pre><blockquote><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p></blockquote><h3 id="2-6-块作用域"><a href="#2-6-块作用域" class="headerlink" title="2.6 块作用域"></a>2.6 块作用域</h3><blockquote><p>当用 <code>let</code> 声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p></blockquote><pre><code class="typescript">function f(input: boolean) &#123;  let a = 100;  if (input) &#123;    // Still okay to reference &#39;a&#39;    let b = a + 1;    return b;  &#125;  // Error: &#39;b&#39; doesn&#39;t exist here  return b;&#125;</code></pre><blockquote><p>这里我们定义了<code>2</code>个变量 <code>a</code> 和 <code>b</code> 。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。<br>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p></blockquote><pre><code class="typescript">try &#123;  throw &quot;oh no!&quot;;&#125; catch (e) &#123;  console.log(&quot;Oh well.&quot;);&#125;// Error: &#39;e&#39; doesn&#39;t exist hereconsole.log(e);</code></pre><blockquote><p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p></blockquote><pre><code class="typescript">a++; // illegal to use &#39;a&#39; before it&#39;s declared;let a;</code></pre><blockquote><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 <code>ES2015</code>，现代的运行时会抛出一个错误；然而，现今 <code>TypeScript</code> 是不会报错的。</p></blockquote><pre><code class="typescript">function foo() &#123;  // okay to capture &#39;a&#39;  return a;&#125;// 不能在&#39;a&#39;被声明前调用&#39;foo&#39;// 运行时应该抛出错误foo();let a;</code></pre><blockquote><p>关于暂时性死区的更多信息，查看这里 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener external nofollow noreferrer">Mozilla Developer Network.</a></p></blockquote><h3 id="2-7-重定义及屏蔽"><a href="#2-7-重定义及屏蔽" class="headerlink" title="2.7 重定义及屏蔽"></a>2.7 重定义及屏蔽</h3><blockquote><p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 <code>1</code> 个。</p></blockquote><pre><code class="typescript">function f(x) &#123;  var x;  var x;  if (true) &#123;    var x;  &#125;&#125;</code></pre><blockquote><p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的 <code>x</code>，并且这是完全有效的代码。 这经常会成为<code>bug</code> 的来源。 好的是， <code>let</code> 声明就不会这么宽松了。</p></blockquote><pre><code class="typescript">let x = 10;let x = 20; // 错误，不能在1个作用域里多次声明`x</code></pre><blockquote><p>并不是要求两个均是块级作用域的声明 <code>TypeScript</code> 才会给出一个错误的警告。</p></blockquote><pre><code class="typescript">function f(x) &#123;  let x = 100; // error: interferes with parameter declaration&#125;function g() &#123;  let x = 100;  var x = 100; // error: can&#39;t have both declarations of &#39;x&#39;&#125;</code></pre><blockquote><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p></blockquote><pre><code class="typescript">function f(condition, x) &#123;  if (condition) &#123;    let x = 100;    return x;  &#125;  return x;&#125;f(false, 0); // returns 0f(true, 0); // returns 100</code></pre><blockquote><p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p></blockquote><pre><code class="typescript">function sumMatrix(matrix: number[][]) &#123;  let sum = 0;  for (let i = 0; i &lt; matrix.length; i++) &#123;    var currentRow = matrix[i];    for (let i = 0; i &lt; currentRow.length; i++) &#123;      sum += currentRow[i];    &#125;  &#125;  return sum;&#125;</code></pre><blockquote><p>这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 <code>i</code>。<br>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p></blockquote><h3 id="2-8-块级作用域变量的获取"><a href="#2-8-块级作用域变量的获取" class="headerlink" title="2.8 块级作用域变量的获取"></a>2.8 块级作用域变量的获取</h3><blockquote><p>在我们最初谈及获取用 <code>var</code> 声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p></blockquote><pre><code class="typescript">function theCityThatAlwaysSleeps() &#123;  let getCity;  if (true) &#123;    let city = &quot;Seattle&quot;;    getCity = function () &#123;      return city;    &#125;;  &#125;  return getCity();&#125;</code></pre><blockquote><p>因为我们已经在 <code>city</code> 的环境里获取到了 <code>city</code> ，所以就算 if 语句执行结束后我们仍然可以访问它。<br>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。<br>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p></blockquote><pre><code class="typescript">for (let i = 0; i &lt; 10; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, 100 * i);&#125;</code></pre><blockquote><p>会输出与预料一致的结果：</p></blockquote><pre><code class="typescript">0;1;2;3;4;5;6;7;8;9;</code></pre><h3 id="2-9-const-声明"><a href="#2-9-const-声明" class="headerlink" title="2.9 const 声明"></a>2.9 const 声明</h3><blockquote><p><code>const</code> 声明是声明变量的另一种方式。</p></blockquote><pre><code class="typescript">const numLivesForCat = 9;</code></pre><blockquote><p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。<br>这很好理解，它们引用的值是不可变的。</p></blockquote><pre><code class="typescript">const numLivesForCat = 9;const kitty = &#123;  name: &quot;Aurora&quot;,  numLives: numLivesForCat&#125;;// Errorkitty = &#123;  name: &quot;Danielle&quot;,  numLives: numLivesForCat&#125;;// all &quot;okay&quot;kitty.name = &quot;Rory&quot;;kitty.name = &quot;Kitty&quot;;kitty.name = &quot;Cat&quot;;kitty.numLives--;</code></pre><blockquote><p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。 接口一章有详细说明。</p></blockquote><h3 id="2-10-let-vs-const"><a href="#2-10-let-vs-const" class="headerlink" title="2.10 let vs. const"></a>2.10 let vs. const</h3><blockquote><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。<br>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 <code>const</code> 也可以让我们更容易的推测数据的流动。<br>跟据你的自己判断，如果合适的话，与团队成员商议一下。<br>这个手册大部分地方都使用了 <code>let</code> 声明。</p></blockquote><h3 id="2-11-解构"><a href="#2-11-解构" class="headerlink" title="2.11 解构"></a>2.11 解构</h3><blockquote><p><code>Another TypeScript</code> 已经可以解析其它 <code>ECMAScript 2015</code> 特性了。 完整列表请参见 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener external nofollow noreferrer">the article on the Mozilla Developer Network</a>。 本章，我们将给出一个简短的概述。</p></blockquote><h4 id="2-11-1-解构数组"><a href="#2-11-1-解构数组" class="headerlink" title="2.11.1 解构数组"></a>2.11.1 解构数组</h4><blockquote><p>最简单的解构莫过于数组的解构赋值了：</p></blockquote><pre><code class="typescript">let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2</code></pre><blockquote><p>这创建了 <code>2</code> 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p></blockquote><pre><code class="typescript">first = input[0];second = input[1];</code></pre><blockquote><p>解构作用于已声明的变量会更好：</p></blockquote><pre><code class="typescript">// swap variables[first, second] = [second, first];</code></pre><blockquote><p>作用于函数参数：</p></blockquote><pre><code class="typescript">function f([first, second]: [number, number]) &#123;  console.log(first);  console.log(second);&#125;f(input);</code></pre><blockquote><p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p></blockquote><pre><code class="typescript">let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]</code></pre><blockquote><p>当然，由于是 <code>JavaScript</code>, 你可以忽略你不关心的尾随元素：</p></blockquote><pre><code class="typescript">let [first] = [1, 2, 3, 4];console.log(first); // outputs 1</code></pre><blockquote><p>或其它元素：</p></blockquote><pre><code class="typescript">let [, second, , fourth] = [1, 2, 3, 4];</code></pre><h4 id="2-11-2-对象解构"><a href="#2-11-2-对象解构" class="headerlink" title="2.11.2 对象解构"></a>2.11.2 对象解构</h4><blockquote><p>你也可以解构对象：</p></blockquote><pre><code class="typescript">let o = &#123;  a: &quot;foo&quot;,  b: 12,  c: &quot;bar&quot;&#125;;let &#123; a, b &#125; = o;</code></pre><blockquote><p>这通过 <code>o.a and o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。<br>就像数组解构，你可以用没有声明的赋值：</p></blockquote><pre><code class="typescript">(&#123; a, b &#125; = &#123; a: &quot;baz&quot;, b: 101 &#125;);</code></pre><blockquote><p>注意，我们需要用括号将它括起来，因为 <code>Javascript</code> 通常会将以 <code>&#123;</code> 起始的语句解析为一个块。<br>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p></blockquote><pre><code class="typescript">let &#123; a, ...passthrough &#125; = o;let total = passthrough.b + passthrough.c.length;</code></pre><h4 id="2-11-3-属性重命名"><a href="#2-11-3-属性重命名" class="headerlink" title="2.11.3 属性重命名"></a>2.11.3 属性重命名</h4><blockquote><p>你也可以给属性以不同的名字：</p></blockquote><pre><code class="typescript">let &#123; a: newName1, b: newName2 &#125; = o;</code></pre><blockquote><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 &quot;<code>a</code> 作为 <code>newName1</code>&quot;。 方向是从左到右，好像你写成了以下样子：</p></blockquote><pre><code class="typescript">let newName1 = o.a;let newName2 = o.b;</code></pre><blockquote><p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p></blockquote><pre><code class="typescript">let &#123; a, b &#125;: &#123; a: string; b: number &#125; = o;</code></pre><h4 id="2-11-4-默认值"><a href="#2-11-4-默认值" class="headerlink" title="2.11.4 默认值"></a>2.11.4 默认值</h4><blockquote><p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p></blockquote><pre><code class="typescript">function keepWholeObject(wholeObject: &#123; a: string; b?: number &#125;) &#123;  let &#123; a, b = 1001 &#125; = wholeObject;&#125;</code></pre><blockquote><p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p></blockquote><h4 id="2-11-5-函数声明"><a href="#2-11-5-函数声明" class="headerlink" title="2.11.5 函数声明"></a>2.11.5 函数声明</h4><blockquote><p>解构也能用于函数声明。 看以下简单的情况：</p></blockquote><pre><code class="typescript">type C = &#123; a: string; b?: number &#125;;function f(&#123; a, b &#125;: C): void &#123;  // ...&#125;</code></pre><blockquote><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p></blockquote><pre><code class="typescript">function f(&#123; a = &quot;&quot;, b = 0 &#125; = &#123;&#125;): void &#123;  // ...&#125;f();</code></pre><blockquote><p>上面的代码是一个类型推断的例子，将在本手册后文介绍。<br>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p></blockquote><pre><code class="typescript">function f(&#123; a, b = 0 &#125; = &#123; a: &quot;&quot; &#125;): void &#123;  // ...&#125;f(&#123; a: &quot;yes&quot; &#125;); // ok, default b = 0f(); // ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0f(&#123;&#125;); // error, &#39;a&#39; is required if you supply an argument</code></pre><blockquote><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p></blockquote><h4 id="2-11-6-展开"><a href="#2-11-6-展开" class="headerlink" title="2.11.6 展开"></a>2.11.6 展开</h4><blockquote><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p></blockquote><pre><code class="typescript">let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];</code></pre><blockquote><p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second</code> 的一份浅拷贝。 它们不会被展开操作所改变。<br>你还可以展开对象：</p></blockquote><pre><code class="typescript">let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; ...defaults, food: &quot;rich&quot; &#125;;</code></pre><blockquote><p><code>search</code> 的值为 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p></blockquote><pre><code class="typescript">let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; food: &quot;rich&quot;, ...defaults &#125;;</code></pre><blockquote><p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。<br>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="noopener external nofollow noreferrer">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p></blockquote><pre><code class="typescript">class C &#123;  p = 12;  m() &#123;&#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error!</code></pre><blockquote><p>其次，<code>TypeScript</code> 编译器不允许展开泛型函数上的类型参数。 这个特性会在 <code>TypeScript</code> 的未来版本中考虑实现。</p></blockquote><h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h2><h3 id="3-1-实现一个简单的接口"><a href="#3-1-实现一个简单的接口" class="headerlink" title="3.1 实现一个简单的接口"></a>3.1 实现一个简单的接口</h3><pre><code class="typescript">interface LabelledValue &#123;  label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123;  console.log(labelledObj.label);&#125;let myObj = &#123; size: 10, label: &quot;size 10 Object&quot; &#125;;printLabel(myObj);</code></pre><h3 id="3-2-可选属性"><a href="#3-2-可选属性" class="headerlink" title="3.2 可选属性"></a>3.2 可选属性</h3><pre><code class="typescript">interface SquareConfig &#123;  color?: string;  width?: number;&#125;function createConfig(config: SquareConfig): &#123; color: string; area: number &#125; &#123;  let newSquare = &#123; color: &quot;white&quot;, area: 100 &#125;;  if (config.color) &#123;    newSquare.color = config.color;  &#125;  if (config.width) &#123;    newSquare.area = config.width * config.width;  &#125;  return newSquare;&#125;let mySquare = createConfig(&#123; color: &quot;black&quot;, width: 20 &#125;);console.log(mySquare);</code></pre><h3 id="3-3-只读属性"><a href="#3-3-只读属性" class="headerlink" title="3.3 只读属性"></a>3.3 只读属性</h3><pre><code class="typescript">interface Point &#123;  readonly x: number;  readonly y: number;&#125;let p1: Point = &#123; x: 10, y: 20 &#125;;p1.x = 5; // error! 因为属性是只读的</code></pre><h3 id="3-4-额外的属性检查"><a href="#3-4-额外的属性检查" class="headerlink" title="3.4 额外的属性检查"></a>3.4 额外的属性检查</h3><blockquote><p>问题：将&quot; <em>可选属性</em> &quot;与&quot; <code>option bags</code> &quot;模式相结合而引发</p></blockquote><pre><code class="typescript">interface SquareConfig &#123;  color?: string;  width?: number;&#125;function createConfig(config: SquareConfig): &#123; color: string; area: number &#125; &#123;  let newSquare = &#123; color: &quot;white&quot;, area: 100 &#125;;  if (config.color) &#123;    newSquare.color = config.color;  &#125;  if (config.width) &#123;    newSquare.area = config.width * config.width;  &#125;  return newSquare;&#125;</code></pre><blockquote><p><code>let mySquare = createConfig(&#123; colour: &quot;red&quot;, width: 100 &#125;); //报错</code></p></blockquote><ul><li>解决方案一：采用类型断言</li></ul><pre><code class="typescript">let mySquare = createConfig(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig);</code></pre><ul><li>解决方案二：采用添加一个字符串索引签名(最佳方案)</li></ul><pre><code class="typescript">interface _SquareConfig &#123;  color?: string;  width?: number;  [propName: string]: any;&#125;</code></pre><ul><li>解决方案三：变量赋值</li></ul><h3 id="3-5-函数类型"><a href="#3-5-函数类型" class="headerlink" title="3.5 函数类型"></a>3.5 函数类型</h3><h4 id="3-5-1-函数类型"><a href="#3-5-1-函数类型" class="headerlink" title="3.5.1 函数类型"></a>3.5.1 函数类型</h4><pre><code class="typescript">interface SearchFunc &#123;  (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function (source: string, subString: string) &#123;  let result = source.search(subString);  return result &gt; -1;&#125;;</code></pre><h4 id="3-5-2-函数类型"><a href="#3-5-2-函数类型" class="headerlink" title="3.5.2 函数类型"></a>3.5.2 函数类型</h4><pre><code class="typescript">let add: (baseValue: number, increment: number) =&gt; number = (x, y) =&gt; x + y;let add2 = (x: number, y: number): number =&gt; x + y;let buildNameFun: (fname: string, ...rest: Array&lt;string&gt;) =&gt; string = (firstName: string, ...restOfName: Array&lt;string&gt;) =&gt; `$&#123;firstName&#125;, $&#123;restOfName.join(&quot; &quot;)&#125;`;let fn = (a: number, b: number): number =&gt; a + b;</code></pre><h4 id="3-5-3-函数类型"><a href="#3-5-3-函数类型" class="headerlink" title="3.5.3 函数类型"></a>3.5.3 函数类型</h4><pre><code class="typescript">interface func &#123;  (x: string, y: string): boolean;&#125;let func: func = (x: string, y: string) =&gt; &#123;  return x.search(y) &gt; -1;&#125;;</code></pre><h3 id="3-6-可索引类型"><a href="#3-6-可索引类型" class="headerlink" title="3.6 可索引类型"></a>3.6 可索引类型</h3><ul><li>例如：<code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code></li><li>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型</li></ul><pre><code class="typescript">interface StringArray &#123;  [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string = myArray[0];console.log(myStr);</code></pre><blockquote><p><code>Ts</code> 支持两种索引签名：字符串 和 数字。可以同时使用两种类型的索引，但数字索引的返回值必须是字符串索引返回值类型的子类型。</p></blockquote><h3 id="3-7-类类型"><a href="#3-7-类类型" class="headerlink" title="3.7 类类型"></a>3.7 类类型</h3><blockquote><p>接口描述了类的公共部分，而不是类的公有和私有两部分。它不会帮你检查类是否具有某些私有成员</p></blockquote><pre><code class="typescript">interface ClockInterface &#123;  currentTime: Date;  setTime(d: Date); // 在接口中描述的方法&#125;class Clock implements ClockInterface &#123;  currentTime: Date;  setTime(d: Date) &#123;    // 在类中的具体实现    this.currentTime = d;  &#125;  constructor(h: number, m: number) &#123;&#125;&#125;</code></pre><blockquote><p>当操作类的时候，我们需要知道类是具有两个类型的：<em>静态部分的类型</em> 和 _实例的类型_。<br>当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误。<br>因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p></blockquote><ul><li>因此应当直接操作 <em>类的静态部分</em></li></ul><pre><code class="typescript">interface err_ClockConstructor &#123;  new (hour: number, minute: number);&#125;class err_Clock implements err_ClockConstructor &#123;  currentTime: Date;  constructor(h: number, m: number) &#123;&#125;&#125;</code></pre><ul><li>下面是实现对 <em>静态类型</em> 的检查工作</li></ul><blockquote><p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名</p></blockquote><pre><code class="typescript">interface ClockConstructor &#123;  new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123;  tick();&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;  return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123;  constructor(h: number, m: number) &#123;&#125;  tick() &#123;    console.log(&quot;beep beep&quot;);  &#125;&#125;class AnalogClock implements ClockInterface &#123;  constructor(h: number, m: number) &#123;&#125;  tick() &#123;    console.log(&quot;tick tick&quot;);  &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32);console.log(digital);console.log(analog);</code></pre><h3 id="3-8-接口继承"><a href="#3-8-接口继承" class="headerlink" title="3.8 接口继承"></a>3.8 接口继承</h3><ul><li>和类一样，接口也可以相互继承。可以灵活地将接口分割到可重用的模块里。</li></ul><pre><code class="typescript">interface Shape &#123;  color: string;&#125;interface Square extends Shape &#123;  sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = &quot;blue&quot;;square.sideLength = 10;</code></pre><ul><li>一个接口可以继承多个接口，创建出多个接口的合成接口</li></ul><pre><code class="typescript">interface Shape &#123;  color: string;&#125;interface PenStroke &#123;  penWidth: number;&#125;interface Square extends Shape, PenStroke &#123;  sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = &quot;blue&quot;;square.sideLength = 10;square.penWidth = 5.0;</code></pre><ul><li>目的: <code>=&gt;</code> 灵活地将接口分割到可重用的模块中</li></ul><pre><code class="typescript">interface Lamp &#123;  lampOn(): void;  lampOff(): void;&#125;interface wx &#123;  wxNumber: number;  showWxNumber(): string;&#125;interface Photo extends Lamp, wx &#123;  photo(): string;&#125;class HuaWeiPhone implements Photo &#123;  public wxNumber: number;  photo(): string &#123;    return &quot;华为手机&quot;;  &#125;  lampOn(): void &#123;&#125;  lampOff(): void &#123;&#125;  constructor(wxNumber: number) &#123;    this.wxNumber = wxNumber;  &#125;  showWxNumber(): string &#123;    return &quot;我的微信号：123&quot;;  &#125;&#125;let huaWeiPhone = new HuaWeiPhone(12345678910);console.log(huaWeiPhone.showWxNumber());console.log(huaWeiPhone.photo());</code></pre><h3 id="3-9-混合类型"><a href="#3-9-混合类型" class="headerlink" title="3.9 混合类型"></a>3.9 混合类型</h3><blockquote><p>一个对象可以同时做为函数和对象使用，并带有额外的属性</p></blockquote><pre><code class="typescript">interface Counter &#123;  (start: number): string;  interval: number;  reset(): void;&#125;function getCounter(): Counter &#123;  let counter = &lt;Counter&gt;function (start: number) &#123;    // return start + &#39;string&#39;;  &#125;;  counter.interval = 123;  counter.reset = function () &#123;&#125;;  return counter;&#125;let c = getCounter();c(10);c.interval = 5.0;c.reset();</code></pre><h3 id="3-10-接口继承类"><a href="#3-10-接口继承类" class="headerlink" title="3.10 接口继承类"></a>3.10 接口继承类</h3><ol><li>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。</li><li>就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</li><li>接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。</li><li>这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现( <code>implement</code> )。</li><li>当你有一个庞大的继承接口时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承至基类外与基类没有任何关系。</li></ol><pre><code class="typescript">class Control &#123;  private state: any;&#125;interface SelectableControl extends Control &#123;  select(): void;&#125;class Button extends Control implements SelectableControl &#123;  select(): void &#123;&#125;&#125;class TextBox extends Control &#123;  select(): void &#123;&#125;&#125;// 错误：&quot;Image&quot;类型缺少&quot;state&quot;属性class Image implements SelectableControl &#123;  select(): void &#123;&#125;&#125;class Location &#123;&#125;</code></pre><blockquote><p>在上面的例子中，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员。包括私有成员 <code>state</code>。因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口，因为只有 <code>Control</code> 的子类才能够拥有一个声明于 <code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。<br>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code> 和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类(因为它们都继承自 <code>Control</code> 并有 <code>select</code> 方法，但 <code>Image</code> 和 <code>Location</code> 类并不是这样的。)</p></blockquote><h3 id="3-11-接口继承接口"><a href="#3-11-接口继承接口" class="headerlink" title="3.11 接口继承接口"></a>3.11 接口继承接口</h3><blockquote><p>目的: <code>=&gt;</code> 灵活地将接口分割到可重用的模块中</p></blockquote><pre><code class="typescript">interface Lamp &#123;  lampOn(): void;  lampOff(): void;&#125;interface wx &#123;  wxNumber: number;  showWxNumber(): string;&#125;interface Photo extends Lamp, wx &#123;  photo(): string;&#125;class HuaWeiPhone implements Photo &#123;  public wxNumber: number;  photo(): string &#123;    return &quot;华为手机&quot;;  &#125;  lampOn() &#123;&#125;  lampOff() &#123;&#125;  constructor(wxNumber: number) &#123;    this.wxNumber = wxNumber;  &#125;  showWxNumber() &#123;    return &quot;我的微信号是：123&quot;;  &#125;&#125;let huaWeiPhone = new HuaWeiPhone(13100970071);console.log(huaWeiPhone.showWxNumber());console.log(huaWeiPhone.photo());</code></pre><h3 id="3-12-类接口实现"><a href="#3-12-类接口实现" class="headerlink" title="3.12 类接口实现"></a>3.12 类接口实现</h3><blockquote><p>手机类是一个大类<br>华为是手机类下的一个类<br>华为手机有拍照和闪光灯功能，照相机也有拍照和闪光灯功能<br>因此华为手机和照相机的公共特性就是拍照和闪光灯<br>所以通过关键字 <code>implements</code> 来标识提取出来的接口</p></blockquote><pre><code class="typescript">// 拍照interface Photo &#123;  photo(): string;&#125;// 闪光灯interface Lamp &#123;  lampOn(): void;  lampOff(): void;&#125;class Phone &#123;&#125;class HuaWei extends Phone implements Photo, Lamp &#123;  photo(): string &#123;    return &quot;华为拍照&quot;;  &#125;  lampOn() &#123;&#125;  lampOff() &#123;&#125;&#125;class DigitalCamera implements Photo, Lamp &#123;  photo(): string &#123;    return &quot;照相机拍照&quot;;  &#125;  lampOn() &#123;&#125;  lampOff() &#123;&#125;&#125;</code></pre><h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><h3 id="4-1-创建一个基本类"><a href="#4-1-创建一个基本类" class="headerlink" title="4.1 创建一个基本类"></a>4.1 创建一个基本类</h3><pre><code class="typescript">class Gretter &#123;  public gretting: string;  constructor(message: string) &#123;    this.gretting = message;  &#125;  public greet() &#123;    return `Hello, $&#123;this.gretting&#125;`;  &#125;&#125;let gretter: Gretter = new Gretter(&quot;world!&quot;);console.log(gretter);</code></pre><h3 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2 继承"></a>4.2 继承</h3><pre><code class="typescript">class Animal &#123;  name: string;  constructor(theName: string) &#123;    this.name = theName;  &#125;  move(distanceInMeters: number = 0) &#123;    console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);  &#125;&#125;class Snake extends Animal &#123;  constructor(name: string) &#123;    super(name);  &#125;  move(distanceInMeters = 5) &#123;    console.log(&quot;Slithering...&quot;);    super.move(distanceInMeters);  &#125;&#125;class Horse extends Animal &#123;  constructor(name: string) &#123;    super(name);  &#125;  move(distanceInMeters = 45) &#123;    console.log(&quot;Galloping&quot;);    super.move(distanceInMeters);  &#125;&#125;let sam = new Snake(&quot;Sammy the Python&quot;);let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);sam.move();tom.move(34);</code></pre><h3 id="4-3-public-关键字"><a href="#4-3-public-关键字" class="headerlink" title="4.3 public 关键字"></a>4.3 public 关键字</h3><blockquote><p>默认为 <code>public</code><br>在 <code>TypeScript</code> 中,成员都默认为 <code>public</code></p></blockquote><pre><code class="typescript">class Animal_public &#123;  public name: string;  public constructor(theName: string) &#123;    this.name = theName;  &#125;  public move(distanceInMeters: number) &#123;    console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`);  &#125;&#125;</code></pre><h3 id="4-4-private-关键字"><a href="#4-4-private-关键字" class="headerlink" title="4.4 private 关键字"></a>4.4 private 关键字</h3><blockquote><p>理解 <code>private</code></p><ol><li>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问</li><li>如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。</li></ol></blockquote><pre><code class="typescript">class Animal_private &#123;  private name: string;  constructor(theName: string) &#123;    this.name = theName;  &#125;&#125;const cat = new Animal_private(&quot;Cat&quot;);// cat.name; // 错误：&#39;name&#39;是私有的class Animal_private_1 &#123;  private name: string;  constructor(theName: string) &#123;    this.name = theName;  &#125;&#125;class Rhino extends Animal_private_1 &#123;  constructor() &#123;    super(&quot;Rhino&quot;);  &#125;&#125;class Employee &#123;  private name: string;  constructor(theName: string) &#123;    this.name = theName;  &#125;&#125;let animal = new Animal_private_1(&quot;Goat&quot;);let rhino = new Rhino();let employee = new Employee(&quot;Bob&quot;);animal = rhino;// animal = employee; //错误：Animal与Employee不兼容</code></pre><h3 id="4-5-protected-关键字"><a href="#4-5-protected-关键字" class="headerlink" title="4.5 protected 关键字"></a>4.5 protected 关键字</h3><ul><li>理解 <code>protected</code></li></ul><blockquote><p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但是有一点不同，<code>protected</code> 成员在派生类中仍然可以访问。</p></blockquote><pre><code class="typescript">class Person &#123;  protected name: string;  constructor(name: string) &#123;    this.name = name;  &#125;&#125;class _Employee extends Person &#123;  private department: string;  constructor(name: string, department: string) &#123;    super(name);    this.department = department;  &#125;  public getElevatorPitch() &#123;    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;`;  &#125;&#125;let howard = new _Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());// console.log(howard.name); // 错误，因为 name 无法在外部访问，但是可以在派生类中访问</code></pre><ul><li>构造函数也可以被标记成 <code>protected</code></li></ul><blockquote><p>这意味着这个类不能在包含它的类外被实例化。但是能被继承。</p></blockquote><pre><code class="typescript">class __Person &#123;  protected name: string;  protected constructor(theName: string) &#123;    this.name = theName;  &#125;&#125;// __Employee 能够继承 Personclass __Employee extends __Person &#123;  private department: string;  constructor(name: string, department: string) &#123;    super(name);    this.department = department;  &#125;  public getElevatorPitch() &#123;    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;  &#125;&#125;let __howard = new __Employee(&quot;Howard&quot;, &quot;Sales&quot;);// let __join = new __Person(&quot;John&quot;);// 错误：&#39;Person&#39;的构造函数是被保护的</code></pre><h3 id="4-6-readonly-修饰符"><a href="#4-6-readonly-修饰符" class="headerlink" title="4.6 readonly 修饰符"></a>4.6 readonly 修饰符</h3><ul><li>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化</li></ul><pre><code class="typescript">class Octopus &#123;  readonly name: string;  readonly numberOfLegs: number = 8;  constructor(theName: string) &#123;    this.name = theName;  &#125;&#125;let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);// dad.name = &quot;Man with the 3-piece suit&quot;;// 错误，name是只读的</code></pre><ul><li>参数属性</li></ul><blockquote><ol><li>参数属性可以方便地让我们在一个地方定义并初始化一个成员。</li><li>参数属性通过给构造函数参数前面添加一个访问限定符来声明。</li><li>使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</li></ol></blockquote><pre><code class="typescript">class _Octopus &#123;  readonly numberOfLegs: number = 9;  constructor(readonly name: string) &#123;&#125;&#125;</code></pre><h3 id="4-7-存取器-get-amp-set"><a href="#4-7-存取器-get-amp-set" class="headerlink" title="4.7 存取器 get &amp; set"></a>4.7 存取器 get &amp; set</h3><blockquote><p>存取器 支持 <code>es5+</code>，不支持 <code>es3</code></p></blockquote><ol><li><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。</li><li>没有存取器的例子</li></ol><pre><code class="typescript">class _Employee &#123;  fullName: string;&#125;let _employee = new _Employee();_employee.fullName = &quot;Bob Smith&quot;;if (_employee.fullName) &#123;  console.log(_employee.fullName);&#125;</code></pre><ol start="3"><li>拥有存取器的例子</li></ol><blockquote><ol><li>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</li><li>只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。</li><li>这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</li></ol></blockquote><pre><code class="typescript">let passcode = &quot;secret passcode&quot;;class Employee &#123;  private _fullName: string;  get fullName(): string &#123;    return this._fullName;  &#125;  set fullName(newName: string) &#123;    if (passcode &amp;&amp; passcode === &quot;secret passcode&quot;) &#123;      this._fullName = newName;    &#125; else &#123;      console.log(&quot;Error: Unauthorized update of employee!&quot;);    &#125;  &#125;&#125;let employee = new Employee();employee.fullName = &quot;Bob smith&quot;;if (employee.fullName) &#123;  console.log(employee.fullName);&#125;</code></pre><h3 id="4-8-静态属性"><a href="#4-8-静态属性" class="headerlink" title="4.8 静态属性"></a>4.8 静态属性</h3><blockquote><p>我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p></blockquote><pre><code class="typescript">class Gird &#123;  public static origin = &#123; x: 0, y: 0 &#125;;  public calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123;    let xDist = point.x - Gird.origin.x;    let yDist = point.y - Gird.origin.y;    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;  &#125;  public constructor(public scale: number) &#123;&#125;&#125;console.log(Gird.origin.x);let grid1 = new Gird(1.0);let gird2 = new Gird(5.0);console.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(gird2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));</code></pre><h3 id="4-9-抽象类"><a href="#4-9-抽象类" class="headerlink" title="4.9 抽象类"></a>4.9 抽象类</h3><ol><li>抽象类作为其他派生类的基类使用，它们一般不会直接被实例化。</li><li>不同于接口，抽象类可以包含成员的实现细节</li><li><code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法</li></ol><pre><code class="typescript">abstract class Animal &#123;  abstract makeSound(): void;  move(): void &#123;    console.log(&quot;roaming the earth ...&quot;);  &#125;&#125;</code></pre><ol start="4"><li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</li><li>抽象方法的语法于接口方法相似，二者都是定义方法签名但不包含方法体。然而抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符</li></ol><pre><code class="typescript">abstract class Department &#123;  constructor(public name: string) &#123;&#125;  printName(): void &#123;    console.log(`Department name: $&#123;this.name&#125;`);  &#125;  abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123;  constructor() &#123;    super(&quot;Accounting and Auditing&quot;);  &#125;  printMeeting(): void &#123;    console.log(&quot;The Accounting Department meets each Monday at 10am.&quot;);  &#125;  generateReports(): void &#123;    console.log(&quot;Generating accounting reports...&quot;);  &#125;&#125;let department: Department; // 允许创建一个对抽象类的引用// department = new Departmemnt(); // 错误，不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();// department.generateReports(); // 错误，方法在声明的抽象类中不存在</code></pre><h3 id="4-10-高级技巧-构造函数"><a href="#4-10-高级技巧-构造函数" class="headerlink" title="4.10 高级技巧(构造函数)"></a>4.10 高级技巧(构造函数)</h3><blockquote><p>当在 <code>TypeScript</code> 里声明了一个类的时候，实际上声明了很多东西。首先就是类的实例类型</p></blockquote><pre><code class="typescript">class Greeter &#123;  greeting: string;  constructor(message: string) &#123;    this.greeting = message;  &#125;  greet() &#123;    return &quot;Hello,&quot; + this.greeting;  &#125;&#125;let greeter: Greeter; // =&gt;意思：Greeter类的实例的类型是Greetergreeter = new Greeter(&quot;world&quot;);console.log(greeter.greet());</code></pre><blockquote><p>可以认为类具有 <em>实例部分</em> 与 <em>静态部分</em></p></blockquote><pre><code class="typescript">class _Greeter &#123;  static standardGreeting = &quot;Hello, there&quot;;  greeting: string;  greet() &#123;    if (this.greeting) &#123;      return &quot;Hello,&quot; + this.greeting;    &#125; else &#123;      return _Greeter.standardGreeting;    &#125;  &#125;&#125;let _greeter: _Greeter;_greeter = new _Greeter();console.log(_greeter.greet());</code></pre><blockquote><p>此处创建了一个 <code>greeterMaker</code> 的变量，这个变量保存了这个 <em>类</em> 或者说保存了 _类构造函数_。然后使用 <code>typeof _Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，&quot;告诉我 <code>Greeter</code> 标识符的类型&quot;，也就是构造函数的类型。这个类型包含了类的所有静态成员和构造函数。</p></blockquote><pre><code class="typescript">let _greeterMaker: typeof _Greeter = _Greeter;_greeterMaker.standardGreeting = &quot;Hey there!&quot;;let _greeter2: _Greeter = new _greeterMaker();console.log(_greeter2.greet());</code></pre><h3 id="4-11-高级技巧-把类当作接口使用"><a href="#4-11-高级技巧-把类当作接口使用" class="headerlink" title="4.11 高级技巧(把类当作接口使用)"></a>4.11 高级技巧(把类当作接口使用)</h3><blockquote><p>类定义会创建两个东西：<em>类的实例类型</em> 和 _一个构造函数_。<br>因为类可以创建出类型，所以能够在允许使用接口的地方使用类</p></blockquote><pre><code class="typescript">class Point &#123;  x: number;  y: number;&#125;interface Point3d extends Point &#123;  z: number;&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 4 &#125;;</code></pre><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><blockquote><p>函数是 <code>JavaScript</code> 应用程序的基础。它帮助你实现抽象层，模拟层，信息隐藏和模块。在 <code>TypeScript</code> 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，让我们可以更容易的使用。</p></blockquote><h3 id="5-2-函数类型"><a href="#5-2-函数类型" class="headerlink" title="5.2 函数类型"></a>5.2 函数类型</h3><h4 id="5-2-1-为函数定义类型"><a href="#5-2-1-为函数定义类型" class="headerlink" title="5.2.1 为函数定义类型"></a>5.2.1 为函数定义类型</h4><blockquote><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。</p></blockquote><blockquote><p><code>TypeScript</code> 能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p></blockquote><pre><code class="typescript">function add(x: number, y: number): number &#123;  return x + y;&#125;let myAdd = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><h4 id="5-2-2-书写完整的函数类型"><a href="#5-2-2-书写完整的函数类型" class="headerlink" title="5.2.2 书写完整的函数类型"></a>5.2.2 书写完整的函数类型</h4><pre><code class="typescript">let myAdd1: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><blockquote><p>函数类型分为两个部分：<em>参数类型</em> 和 _返回值类型_。当写出完整函数类型的时候，这两部分都是需要的。我们以参数列表的形式写出参数类型，为每一个参数指定一个名字和类型。这个名字只是为了增加可读性。</p></blockquote><blockquote><ol><li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</li><li>第二部分是返回值类型。对于返回值，我们在函数和返回值类型之间使用 <code>=&gt;</code> 符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code>,而不能留空。</li></ol></blockquote><blockquote><p>函数的类型只是由参数类型和返回值组成的。函数中使用的捕获变量不会体现在类型里。实际上，这些变量是函数的隐藏状态并不是组成 <code>API</code> 的一部分。</p></blockquote><ul><li>我们也可以这么写：</li></ul><pre><code class="typescript">let myAdd2: (baseValue: number, increment: number) =&gt; number = function (x: number, y: number): number &#123;  return x + y;&#125;;</code></pre><h4 id="5-2-3-推断类型"><a href="#5-2-3-推断类型" class="headerlink" title="5.2.3 推断类型"></a>5.2.3 推断类型</h4><blockquote><p>在尝试下面这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。这叫做：&quot;按上下文归类&quot;，是类型推论的一种。它帮助我们更好地为程序指定类型。</p></blockquote><pre><code class="typescript">// myAdd has the full function typelet myAdd3 = function(x: number, y: number): number &#123; return x + y &#125;;// The parameters `x` and `y` have the type numberlet myAdd4: (baseValue: number, increment: number) =number = function (x, y) &#123;  return x + y;&#125;;</code></pre><h3 id="5-3-可选参数和默认参数"><a href="#5-3-可选参数和默认参数" class="headerlink" title="5.3 可选参数和默认参数"></a>5.3 可选参数和默认参数</h3><blockquote><p><code>TypeScript</code> 里的每个函数参数都是必须的。这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。</p></blockquote><ol><li>简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</li></ol><pre><code class="typescript">function buildName(firstName: string, lastName: string) &#123;  return firstName + &quot; &quot; + lastName;&#125;// let result1 =  buildName(&quot;Bob&quot;); // error// let result2 = buildName(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // errorlet result3 = buildName(&quot;Bob&quot;, &quot;Jack&quot;);</code></pre><ol start="2"><li><code>JavaScript</code>里，每个参数都是可选的，可传可不传。没传参的时候，它的值就是 <code>undefined</code>。在 <code>TypeScript</code> 里我们可以在参数旁边使用 <code>?</code> 实现可选参数的功能。</li><li>注意：可选参数必须跟在必选参数后面，不能放在前面</li></ol><pre><code class="typescript">function buildName1(firstName: string, lastName?: string) &#123;  if (lastName) &#123;    return firstName + &quot; &quot; + lastName;  &#125; else &#123;    return firstName;  &#125;&#125;let result_1 = buildName1(&quot;Bob&quot;);let result_2 = buildName1(&quot;Bob&quot;, &quot;Jack&quot;);// let result_3 = buildName1(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</code></pre><ol start="4"><li>可以设置默认初始化的参数</li><li>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。也就是说，可选参数与末尾的默认参数共享参数类型。</li></ol><pre><code class="typescript">function buildName2(firstName: string, lastName = &quot;Smith&quot;) &#123;  return firstName + &quot; &quot; + lastName;&#125;</code></pre><ol start="6"><li>与普通可选参数参数不同的是，带默认值的参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数的前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。</li></ol><pre><code class="typescript">function buildName3(firstName = &quot;Will&quot;, lastName: string) &#123;  return firstName + &quot; &quot; + lastName;&#125;// let result__1 = buildName3(&quot;Bob&quot;); // error// let result__2 = buildName3(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // errorlet result__3 = buildName3(&quot;Bob&quot;, &quot;Jack&quot;);let result__4 = buildName3(undefined, &quot;Jack&quot;);</code></pre><h3 id="5-4-剩余参数"><a href="#5-4-剩余参数" class="headerlink" title="5.4 剩余参数"></a>5.4 剩余参数</h3><blockquote><p>必要参数，默认参数 和 可选参数 有个共同点：它们表示某一个参数。有时，你想同时操作多个参数，或者你并不知道会有多少参数传进来。在 <code>JavaScript</code> 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。在 <code>TypeScript</code> 里，你可以把所有参数收集到一个变量里</p></blockquote><pre><code class="typescript">function buildName(firstName: string, ...restOfName: string[]) &#123;  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let employeeName = buildName(&quot;Jose&quot;, &quot;Smith&quot;, &quot;Bob&quot;, &quot;Alice&quot;);</code></pre><blockquote><p>剩余参数会被当作个数不限的可选参数。可以一个都没有，也可以有任意个。编译器创建参数数组，名字是你在省略号后面给定的名字，你可以在函数体内使用这个数组。</p></blockquote><pre><code class="typescript">function buildName1(firstName: string, ...restOfName: string[]) &#123;  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let buildNameFun: (fName: string, ...rest: string[]) =&gt; string = buildName1;</code></pre><blockquote><p><code>this</code> 参数。在使用了 <code>--noImplicitThis</code> 标记之后，<code>this</code> 类型可能会是 <code>any</code>。此时需要提供一个显示的 <code>this</code> 参数。</p></blockquote><pre><code class="typescript">interface Card &#123;  suit: string;  card: number;&#125;interface Deck &#123;  suits: string[];  cards: number[];  createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123;  suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],  cards: Array(52),  createCardPicker(): (this: Deck) =&gt; Card &#123;    return () =&gt; &#123;      let pickedCard = Math.floor(Math.random() * 52);      let pickedSuit = Math.floor(pickedCard / 13);      return &#123; suit: this.suits[pickedSuit], card: pickedCard % 13 &#125;;    &#125;;  &#125;&#125;;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log(`card: $&#123;pickedCard.card&#125; of $&#123;pickedCard.suit&#125;`);</code></pre><h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><blockquote><p>在软件工程中，我们不仅要创建一致的定义良好的 <code>API</code>，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像 <code>C#</code> 和 <code>Java</code> 这样的语言中，可以使用 <code>泛型</code> 来创建可重用组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。<br>除了泛型接口，我们还可以创建泛型类。注意，无法创建泛型枚举和泛型命名空间。</p></blockquote><h3 id="6-2-泛型之-hello-world"><a href="#6-2-泛型之-hello-world" class="headerlink" title="6.2 泛型之 hello world"></a>6.2 泛型之 hello world</h3><blockquote><p>创建一个 <code>identity</code> 函数，这个函数会返回任何传入它的值。</p></blockquote><ul><li>如果不使用泛型，函数可能是：</li></ul><pre><code class="typescript">function identity(arg: number): number &#123;  return arg;&#125;</code></pre><ul><li>也可以使用 <code>any</code> 类型定义函数，但是这样可能会导致传入的类型与返回的类型不相同。</li></ul><pre><code class="typescript">function identity1(arg: any): any &#123;  return arg;&#125;</code></pre><blockquote><p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。</p></blockquote><ul><li>这里我们使用了类型变量，它是一种特殊的变量，只能用于表示类型而不是值。</li></ul><pre><code class="typescript">function identity2&lt;T&gt;(arg: T): T &#123;  return arg;&#125;</code></pre><ul><li>使用方式一：传入所有的参数，包括类型参数</li></ul><pre><code class="typescript">let output = identity2&lt;string&gt;(&quot;myString&quot;);</code></pre><ul><li>使用方式二(更普遍)：利用了类型推论-即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型。</li></ul><pre><code class="typescript">let output2 = identity2(&quot;myString&quot;);</code></pre><h3 id="6-3-使用泛型变量"><a href="#6-3-使用泛型变量" class="headerlink" title="6.3 使用泛型变量"></a>6.3 使用泛型变量</h3><blockquote><p>使用泛型创建像 <code>identity</code> 这样的函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当作是任意或所有类型。</p></blockquote><ul><li>如果我们想打印出 <code>arg</code> 的长度，也许会这样做。</li></ul><pre><code class="typescript">function loggingIdentity&lt;T&gt;(arg: T): T &#123;  console.log(arg.length); // 错误，T 类型也许不会有.length属性  return arg;&#125;</code></pre><ul><li>如果我们像操作 <code>T</code> 类型的数组</li></ul><pre><code class="typescript">function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123;  console.log(arg.length);  return arg;&#125;function loggingIdentity2&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;  console.log(arg.length);  return arg;&#125;</code></pre><h3 id="6-4-泛型类型-泛型接口"><a href="#6-4-泛型类型-泛型接口" class="headerlink" title="6.4 泛型类型(泛型接口)"></a>6.4 泛型类型(泛型接口)</h3><ol><li>泛型函数的类型和非泛型函数的类型一样，首先列出类型参数，类似于函数声明。</li></ol><pre><code class="typescript">function identity&lt;T&gt;(arg: T): T &#123;  return arg;&#125;let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;</code></pre><ol start="2"><li>我们也可以为类型中的泛型类型参数使用不同的名称，只要在数量上和使用方式上能对应上就可以。</li></ol><pre><code class="typescript">function identity1&lt;T&gt;(arg: T): T &#123;  return arg;&#125;let myIdentity1: &lt;U&gt;(arg: U) =&gt; U = identity;</code></pre><ol start="3"><li>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</li></ol><pre><code class="typescript">function identity2&lt;T&gt;(arg: T): T &#123;  return arg;&#125;let myIdentity2: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</code></pre><ol start="4"><li>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</li></ol><pre><code class="typescript">interface GenericIdentityFn &#123;  &lt;T&gt;(arg: T): T;&#125;function identity3&lt;T&gt;(arg: T): T &#123;  return arg;&#125;let myIdentity3: GenericIdentityFn = identity3;</code></pre><ol start="5"><li>我们可能想把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型(比如：<code>Dictionary&lt;string&gt;</code> 而不只是 <code>Dictionary</code>)。这样接口里的其它成员也能知道这个参数的类型了。</li></ol><pre><code class="typescript">interface _GenericIdentityFn&lt;T&gt; &#123;  (arg: T): T;&#125;function _identity&lt;T&gt;(arg: T): T &#123;  return arg;&#125;let _myIdentity: _GenericIdentityFn&lt;number&gt; = _identity;</code></pre><blockquote><p>注意，我们的示例做了少许改动。不再描述泛型函数，而是把非泛型函数签名作为泛型类型的一部分。</p></blockquote><blockquote><p>当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型(这里是：<code>number</code>)，从而锁定之后代码里使用的类型。</p></blockquote><blockquote><p>对于描述哪部分类型属于泛型部分来说，理解何时把参数 &quot;放在调用签名里&quot; 和何时 &quot;放在接口上&quot; 是很有帮助的。</p></blockquote><h3 id="6-5-泛型类"><a href="#6-5-泛型类" class="headerlink" title="6.5 泛型类"></a>6.5 泛型类</h3><blockquote><p>泛型类和泛型接口差不多。泛型类使用 <code>&lt;&gt;</code> 括起泛型类型，跟在类名后面。类分为两部分：静态部分 和 实例部分。泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p></blockquote><blockquote><p><code>enericNumber</code> 类的使用是非常直观的，并没有什么去限制它只能使用 <code>number</code> 类型。</p></blockquote><ul><li>也可以使用字符串或其它更复杂的类型。</li></ul><pre><code class="typescript">class GenericNumber&lt;T&gt; &#123;  zeroValue: T;  add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = (x, y) =&gt; x + y;</code></pre><blockquote><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p></blockquote><pre><code class="typescript">let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = &quot; &quot;;stringNumeric.add = (x, y) =&gt; x + y;console.log(stringNumeric.add(stringNumeric.zeroValue, &quot;test&quot;));</code></pre><h3 id="6-6-泛型约束"><a href="#6-6-泛型约束" class="headerlink" title="6.6 泛型约束"></a>6.6 泛型约束</h3><blockquote><p>我们应该记得之前的一个例子，我们有时候想要操作某类型的一组值，并且我们知道这组值具有什么样的属性。</p></blockquote><blockquote><p>在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 length 属性。</p></blockquote><pre><code class="typescript">function loggingIdentity&lt;T&gt;(arg: T): T &#123;  console.log(arg.length);  return arg;&#125;</code></pre><blockquote><p>相比与操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p></blockquote><blockquote><p>为此，我们需要定义一个接口来描述约束条件。创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束。</p></blockquote><pre><code class="typescript">interface Lengthwise &#123;  length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;  console.log(arg.length);  return arg;&#125;</code></pre><ul><li>此时这个泛型函数被定义了约束。因此它不再适用于任意类型：</li></ul><pre><code class="typescript">loggingIdentity(3); // error</code></pre><ul><li>我们需要传入符合约束类型的值，必须包含的属性。</li></ul><pre><code class="typescript">loggingIdentity(&#123; length: 10, value: 3 &#125;);</code></pre><h3 id="6-7-在泛型约束中使用类型参数"><a href="#6-7-在泛型约束中使用类型参数" class="headerlink" title="6.7 在泛型约束中使用类型参数"></a>6.7 在泛型约束中使用类型参数</h3><blockquote><p>你可以声明一个类型参数，且它被另一个类型参数所约束。例如，现在我们需想要用属性名从对象里获取这个属性。并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p></blockquote><pre><code class="typescript">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123;  return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, &quot;a&quot;);getProperty(x, &quot;m&quot;); // error</code></pre><h3 id="6-8-在泛型里使用类类型"><a href="#6-8-在泛型里使用类类型" class="headerlink" title="6.8 在泛型里使用类类型"></a>6.8 在泛型里使用类类型</h3><blockquote><p>在 <code>TypeScript</code> 使用泛型创建工厂函数时，需要引用构造函数的类类型。</p></blockquote><pre><code class="typescript">function create&lt;T&gt;(c: &#123; new (): T &#125;): T &#123;  return new c();&#125;</code></pre><blockquote><p>下面是一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p></blockquote><pre><code class="typescript">class BeeKeeper &#123;  hasMask: boolean;&#125;class ZooKeeper &#123;  nameTag: string;&#125;class Animal &#123;  numLegs: number;&#125;class Bee extends Animal &#123;  keeper: BeeKeeper;&#125;class Lion extends Animal &#123;  keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123;  return new c();&#125;createInstance(Lion).keeper.nameTag;createInstance(Bee).keeper.hasMask;</code></pre><h3 id="6-9-多个类型变量"><a href="#6-9-多个类型变量" class="headerlink" title="6.9 多个类型变量"></a>6.9 多个类型变量</h3><pre><code class="typescript">function info&lt;S, N&gt;(name: S, age: N): [S, N] &#123;  return [name, age];&#125;console.log(info(&quot;pr&quot;, 10));console.log(info&lt;string, number&gt;(&quot;pr&quot;, 18));</code></pre><h2 id="七、枚举"><a href="#七、枚举" class="headerlink" title="七、枚举"></a>七、枚举</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><blockquote><p>使用枚举我们可以定义一些带有名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。<code>TypeScript</code> 支持数字的和基于字符串的枚举。</p></blockquote><h3 id="7-2-数字枚举"><a href="#7-2-数字枚举" class="headerlink" title="7.2 数字枚举"></a>7.2 数字枚举</h3><pre><code class="typescript">enum Direction &#123;  Up = 1,  Down,  Left,  Right&#125;</code></pre><blockquote><p>如上，我们定义了一个数字枚举，<code>Up</code>使用初始化为 <code>1</code>，其余成员会从 <code>1</code> 开始自动增长。 换句话说，<code>Direction.Up</code> 的值为 <code>1</code>，<code>Down</code> 值为 <code>2</code>，<code>Left</code> 值为 <code>3</code>，<code>Right</code> 值为 <code>4</code>。</p></blockquote><ol><li>我们还可以完全不使用初始化器</li></ol><pre><code class="typescript">enum Direction2 &#123;  Up,  Down,  Left,  Right&#125;</code></pre><blockquote><p>现在，<code>Up</code> 的值为 <code>0</code>，<code>Down</code> 的值为 <code>1</code> 等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p></blockquote><ol start="2"><li>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</li></ol><pre><code class="typescript">enum _Response &#123;  No = 0,  Yes = 1&#125;function respond(recipient: string, message: _Response): void &#123;&#125;respond(&quot;Princess Caroline&quot;, _Response.Yes);</code></pre><ol start="3"><li>数字枚举可以被混入到计算过的和常量成员（如下所示）。</li></ol><blockquote><p>简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的：</p></blockquote><pre><code class="typescript">enum E &#123;  A = getSomeValue(),  B // error! &#39;A&#39; is not constant-initialized, so &#39;B&#39; needs an initializer&#125;</code></pre><h3 id="7-3-字符串枚举"><a href="#7-3-字符串枚举" class="headerlink" title="7.3 字符串枚举"></a>7.3 字符串枚举</h3><blockquote><p>字符串枚举的概念很简单，但是有细微的运行时的差别。在一个字符串枚举里，每个成员都必须使用字符串字面量，或另外一个字符串枚举成员进行初始化。</p></blockquote><pre><code class="typescript">enum Direction &#123;  Up = &quot;UP&quot;,  Down = &quot;DOWN&quot;,  Left = &quot;LEFT&quot;,  Right = &quot;RIGHT&quot;&#125;</code></pre><blockquote><p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p></blockquote><h3 id="7-4-异构枚举"><a href="#7-4-异构枚举" class="headerlink" title="7.4 异构枚举"></a>7.4 异构枚举</h3><blockquote><p>从技术的角度来说，枚举可以混合字符串和数字成员，但是你似乎并不会这么做：</p></blockquote><pre><code class="typescript">enum BooleanLikeHeterogeneousEnum &#123;  No = 0,  Yes = &quot;YES&quot;&#125;</code></pre><blockquote><p>除非你真的想要利用 <code>JavaScript</code> 运行时的行为，否则我们不建议这样做。</p></blockquote><h3 id="7-5-计算的和常量成员"><a href="#7-5-计算的和常量成员" class="headerlink" title="7.5 计算的和常量成员"></a>7.5 计算的和常量成员</h3><blockquote><p>每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量</p></blockquote><ol><li>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 <code>0</code>：</li></ol><pre><code class="typescript">enum E &#123;  X&#125;</code></pre><ol start="2"><li>它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加 <code>1</code>。</li></ol><pre><code class="typescript">enum E1 &#123;  X,  Y,  Z&#125;enum E2 &#123;  A = 1,  B,  C&#125;</code></pre><ol start="3"><li>枚举成员使用 常量枚举表达式进行初始化。常量枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。</li></ol><blockquote><p>当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p><ol><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符 +，-，～ 其中之一应用在了常量枚举表达式</li><li>常量枚举表达式作为二元运算符 <code>+，-，*，/，%，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，|，^</code> 的操作对象</li></ol></blockquote><blockquote><p>若常量枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错。</p></blockquote><blockquote><p>所有其它情况的枚举成员被当作是需要计算得出的值</p></blockquote><pre><code class="typescript">enum FileAccess &#123;  // constant numbers  None,  Read = 1 &lt;&lt; 1,  White = 1 &lt;&lt; 2,  ReadWhite = Read | White,  // computed number  G = &quot;123&quot;.length&#125;</code></pre><h3 id="7-6-联合枚举与枚举成员的类型"><a href="#7-6-联合枚举与枚举成员的类型" class="headerlink" title="7.6 联合枚举与枚举成员的类型"></a>7.6 联合枚举与枚举成员的类型</h3><blockquote><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是被初始化为：</p><ol><li>任何字符串字面量(例如：<code>&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>)</li><li>任何数字字面量(例如：<code>1, 100</code>)</li><li>应用了一元 - 符号的数字字面量(例如：<code>-1, -100</code>) 当所有枚举成员都拥有字面量枚举值时，它就有了一种特殊的含义。</li></ol></blockquote><blockquote><p>首先，枚举成员成为了类型！例如，我们可以说某些成员只能是枚举成员的值：</p></blockquote><pre><code class="typescript">enum ShapeKind &#123;  Circle,  Square&#125;interface Circle &#123;  kind: ShapeKind.Circle;  radius: number;&#125;interface Square &#123;  kind: ShapeKind.Square;  sideLength: number;&#125;let c: Circle = &#123;  kind: ShapeKind.Square, // error  radius: 100&#125;;</code></pre><blockquote><p>另一个变化是枚举类型本身变成了每个枚举成员的联合。虽然我们还没有讨论 联合类型 。但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。因此，<code>TypeScript</code> 能够捕获在比较值的时候犯的愚蠢的错误。例如：</p></blockquote><pre><code class="typescript">enum E &#123;  Foo,  Bar&#125;function f(x: E) &#123;  if (x !== E.Foo || x !== E.Bar) &#123;    // // Error! Operator &#39;!==&#39; cannot be applied to types &#39;E.Foo&#39; and &#39;E.Bar&#39;.  &#125;&#125;</code></pre><blockquote><p>这个例子里，我们先检查 <code>x</code> 是否不是 <code>E.Foo</code>。 如果通过了这个检查，然后 <code>||</code> 会发生短路效果，<br><code>if</code> 语句体里的内容会被执行。 然而，这个检查没有通过，那么 x 则只能为 <code>E.Foo</code>，因此没理由再去检查它是否为 <code>E.Bar</code>。</p></blockquote><h3 id="7-7-运行时的枚举"><a href="#7-7-运行时的枚举" class="headerlink" title="7.7 运行时的枚举"></a>7.7 运行时的枚举</h3><ul><li>枚举是在运行时真正存在的对象。</li></ul><pre><code class="typescript">enum E &#123;  X,  Y,  Z&#125;</code></pre><ul><li>可以传递给函数么？</li></ul><pre><code class="typescript">function f(obj: &#123; X: number &#125;) &#123;  return obj.X;&#125;</code></pre><ul><li>没问题，因为 <code>&quot;E&quot;</code> 包含一个数值型属性 <code>&quot;X&quot;</code></li></ul><pre><code class="typescript">f(E);</code></pre><h3 id="7-8-编译时的枚举"><a href="#7-8-编译时的枚举" class="headerlink" title="7.8 编译时的枚举"></a>7.8 编译时的枚举</h3><blockquote><p>尽管一个枚举是在运行时真正存在的对象，但 <code>keyof</code> 关键字的行为与其作用在对象上时有所不同。应该使用 <code>keyof</code> <code>typeof</code> 来获取一个表示枚举里所有字符串 <code>key</code> 的类型。</p></blockquote><pre><code class="typescript">enum LogLevel &#123;  ERROR,  WARN,  INFO,  DEBUG&#125;</code></pre><ul><li>等同于：</li></ul><pre><code class="typescript">type LogLevelStrings = &quot;ERROR&quot; | &quot;WARN&quot; | &quot;INFO&quot; | &quot;DEBUG&quot;;type LogLevelStrings = keyof typeof LogLevel;</code></pre><pre><code class="typescript">function printImportant(key: LogLevelStrings, message: string) &#123;  const num = LogLevel[key];  if (num &lt;= LogLevel.WARN) &#123;    console.log(&quot;Log Level key is: &quot;, key);    console.log(&quot;Log Level value is: &quot;, num);    console.log(&quot;Log Level message is &quot;, message);  &#125;&#125;printImportant(&quot;ERROR&quot;, &quot;This is a message&quot;);</code></pre><h3 id="7-9-反向映射"><a href="#7-9-反向映射" class="headerlink" title="7.9 反向映射"></a>7.9 反向映射</h3><blockquote><p>除了创建一个以属性名作为对象成员的对象外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。</p></blockquote><ul><li>例如在下面的例子中：</li></ul><pre><code class="typescript">enum _Enum &#123;  A&#125;let _a = _Enum.A;let _nameOfA = _Enum[_a]; // &quot;A&quot;</code></pre><ul><li><code>TypeScript</code> 可能会将这段代码编译为下面的 <code>JavaScript</code>：</li></ul><pre><code class="typescript">var Enum;(function (Enum) &#123;  Enum[(Enum[&quot;A&quot;] = 0)] = &quot;A&quot;;&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[a]; // &quot;A&quot;</code></pre><blockquote><p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name -&gt; value</code>）和反向映射（<code>value -&gt; name</code>）。</p></blockquote><blockquote><p>引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p></blockquote><blockquote><p>要注意的是不会为字符串枚举成员生成反向映射。</p></blockquote><h3 id="7-10-const-枚举"><a href="#7-10-const-枚举" class="headerlink" title="7.10 const 枚举"></a>7.10 const 枚举</h3><blockquote><p>大多数情况下，枚举是十分有效的方案。然而在某些情况下需求很严格。为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 <code>const</code> 枚举。</p></blockquote><blockquote><p>常量枚举通过在枚举上使用 <code>const</code> 修饰符来定义。</p></blockquote><pre><code class="typescript">const enum Enum &#123;  A = 1,  B = A * 2&#125;</code></pre><blockquote><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p></blockquote><pre><code class="typescript">const enum Directions &#123;  Up,  Down,  Left,  Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];// 生成后的代码为：var directions1 = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</code></pre><h3 id="7-11-外部枚举"><a href="#7-11-外部枚举" class="headerlink" title="7.11 外部枚举"></a>7.11 外部枚举</h3><blockquote><p>外部枚举 用来描述已经存在的枚举类型的形状。</p></blockquote><pre><code class="typescript">declare enum Enum &#123;  A = 1,  B,  C = 2&#125;</code></pre><blockquote><p>外部枚举 和 非外部枚举 之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。</p></blockquote><blockquote><p>对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p></blockquote><h2 id="八、类型别名"><a href="#八、类型别名" class="headerlink" title="八、类型别名"></a>八、类型别名</h2><h3 id="8-1-类型别名"><a href="#8-1-类型别名" class="headerlink" title="8.1 类型别名"></a>8.1 类型别名</h3><ol><li>创建别名需要使用关键字 <code>type</code></li><li>使用别名通常用在有 联合类型 的场景下</li></ol><blockquote><p>注意：不要混淆了 <code>TypeScript</code> 中的 <code>=&gt;</code>; 和 <code>ES6</code> 中的 <code>=&gt;</code> 在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义。(左边是输入类型，需要用括号扩起来，右边是输出类型)；在 <code>ES6</code> 中，<code>=&gt;</code> 叫做箭头函数。</p></blockquote><pre><code class="typescript">type Name = string;type ShowName = () =&gt; string;type NameOrShowName = Name | ShowName;const getName = (name: NameOrShowName) =&gt; &#123;  if (typeof name === &quot;string&quot;) &#123;    return name;  &#125;  return name();&#125;;let showName = () =&gt; &quot;pr is a boy&quot;;console.log(getName(&quot;pr&quot;));console.log(getName(showName()));</code></pre><h3 id="8-2-字符串字面量类型"><a href="#8-2-字符串字面量类型" class="headerlink" title="8.2 字符串字面量类型"></a>8.2 字符串字面量类型</h3><pre><code class="typescript">type EventNames = &quot;click&quot; | &quot;scroll&quot; | &quot;mousemove&quot;;const handleEvent: (a: Element, b: EventNames) =&gt; string = (ele: Element, event: EventNames) =&gt; &#123;  return `$&#123;ele&#125; $&#123;event&#125;`;&#125;;handleEvent(document.getElementById(&quot;header&quot;), &quot;scroll&quot;);handleEvent(document.getElementById(&quot;footer&quot;), &quot;click&quot;);</code></pre><h2 id="九、类型推论"><a href="#九、类型推论" class="headerlink" title="九、类型推论"></a>九、类型推论</h2><h3 id="9-1-基础"><a href="#9-1-基础" class="headerlink" title="9.1 基础"></a>9.1 基础</h3><blockquote><p>在 <code>TypeScript</code> 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子：</p></blockquote><pre><code class="typescript">let x = 3;</code></pre><blockquote><p>变量 <code>x</code> 的类型被推断为数字。这种推断发生在初始化变量和成员，设置默认参数和决定函数返回值时。</p></blockquote><blockquote><p>大多数情况下，类型推论是直接了当地。</p></blockquote><h3 id="9-2-最佳通用类型"><a href="#9-2-最佳通用类型" class="headerlink" title="9.2 最佳通用类型"></a>9.2 最佳通用类型</h3><blockquote><p>当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最合适的通用类型。</p></blockquote><pre><code class="typescript">let x = [0, 1, null];</code></pre><blockquote><p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。这里有两种选择: <code>number</code> 和 <code>null</code>。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p></blockquote><blockquote><p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。</p></blockquote><pre><code class="typescript">let zoo = [new Rhino(), new Elephant(), new Snake()];</code></pre><blockquote><p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。</p></blockquote><blockquote><p>为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p></blockquote><pre><code class="typescript">let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];</code></pre><blockquote><p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p></blockquote><h3 id="9-3-上下文归类"><a href="#9-3-上下文归类" class="headerlink" title="9.3 上下文归类"></a>9.3 上下文归类</h3><ol><li><code>TypeScript</code> 类型推论也可能按照相反的方向进行，这被叫做&quot;上下文归类&quot;。按上下文归类会发生在表达式类型与所处的位置相关时。</li></ol><blockquote><p>在下面这个例子里，<code>TypeScript</code> 类型检查器会使用 <code>Window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。所以它能够推断出 <code>mouseEvent</code> 参数的类型中包含了 <code>button</code> 属性而不包含 <code>kangaroo</code> 属性。</p></blockquote><pre><code class="typescript">window.onmousedown = function (mouseEvent) &#123;  console.log(mouseEvent.button); // &lt;- Ok  console.log(mouseEvent.kangaroo); // &lt;- error&#125;;</code></pre><ol start="2"><li><code>TypeScript</code> 还能够很好地推断出其它上下文中的类型。</li></ol><pre><code class="typescript">window.onscroll = function (uiEvent) &#123;  console.log(uiEvent.button); // Error&#125;;</code></pre><blockquote><p>上面的函数被赋给 <code>window.onscroll``，TypeScript</code> 能够知道 <code>uiEvent</code> 是 <code>UIEvent</code>，而不是 <code>MouseEvent。UIEvent</code> 对象不包含 <code>button</code> 属性，因此 <code>TypeScript</code> 会报错。</p></blockquote><ol><li>如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为 <code>any</code> 类型，而且也不会报错(除非你开启了 <code>--noImplicitAny</code> 选项)</li></ol><pre><code class="typescript">const handler = function (uiEvent) &#123;  console.log(uiEvent.button); // &lt;- Ok&#125;;</code></pre><ul><li>我们也可以明确地为函数参数类型赋值来覆写上下文类型：</li></ul><pre><code class="typescript">window.onscroll = function (uiEvent: any) &#123;  console.log(uiEvent.button); // &lt;- Now, no error is given&#125;;</code></pre><blockquote><p>但这段代码会打印 <code>undefined</code>，因为 <code>uiEvent</code> 并不包含 <code>button</code> 属性。</p></blockquote><blockquote><p>上下文归类会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。</p></blockquote><ul><li>上下文类型也会做为最佳通用类型的候选类型。比如：</li></ul><pre><code class="typescript">function createZoo(): Animal[] &#123;  return [new Rhino(), new Elephant(), new Snake()];&#125;</code></pre><blockquote><p>上面这个例子里，最佳通用类型有 <code>4</code> 个候选者：<code>Animal, Rhino, Elephant, Snake</code>。当然，<code>Animal</code> 会被作为最佳通用类型。</p></blockquote><h2 id="十、类型兼容性"><a href="#十、类型兼容性" class="headerlink" title="十、类型兼容性"></a>十、类型兼容性</h2><h3 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1 介绍"></a>10.1 介绍</h3><blockquote><p><code>TypeScript</code> 里的兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。它正好与名义( <code>nominal</code> )类型形成对比。(译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。)看下面的例子：</p></blockquote><pre><code class="typescript">interface Named &#123;  name: string;&#125;class Person &#123;  name: string;&#125;let p: Named;// Ok, because of structural typingp = new Person();</code></pre><blockquote><p>在使用基于名义类型的断言，比如 <code>C#</code> 或 <code>Java</code> 中，这段代码会报错， 因为 <code>Person</code> 类没有明确说明其实现了 <code>Named</code> 接口。<br><code>TypeScript</code> 的结构性子类型是根据 <code>JavaScript</code> 代码的典型写法来设计的。 因为 <code>JavaScript</code> 里广泛地使用匿名对象，例如函数表达式和对象字面量， 所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p></blockquote><h3 id="10-2-关于可靠性的注意事项"><a href="#10-2-关于可靠性的注意事项" class="headerlink" title="10.2 关于可靠性的注意事项"></a>10.2 关于可靠性的注意事项</h3><blockquote><p><code>TypeScript</code> 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p></blockquote><h3 id="10-3-开始"><a href="#10-3-开始" class="headerlink" title="10.3 开始"></a>10.3 开始</h3><ul><li><code>TypeScript</code> 结构化类型系统的基本规则是，如果 <code>x</code> 要兼容 <code>y</code>，那么 <code>y</code> 至少具有与 <code>x</code> 相同的属性。比如：</li></ul><pre><code class="typescript">interface Named &#123;  name: string;&#125;let x: Named;// y&#39;s inferred type is &#123; name: string; location: string &#125;let y = &#123; name: &quot;Alice&quot;, location: &quot;Seattle&quot; &#125;;x = y;</code></pre><blockquote><p>这里要检查 <code>y</code> 是否能赋值给 <code>x</code>，编译器检查 <code>x</code> 中的每个属性，看是否能在 <code>y</code> 中也找到对应属性。</p></blockquote><blockquote><p>在这个例子中，<code>y</code> 必须包含名字是 <code>name</code> 的 <code>string</code> 类型成员。<code>y</code> 满足条件，因此赋值正确。</p></blockquote><ul><li>检查函数参数时使用相同的规则</li></ul><pre><code class="typescript">function greet(n: Named) &#123;  console.log(&quot;Hello, &quot; + n.name);&#125;greet(y); // OK</code></pre><blockquote><p>注意，<code>y</code> 有个额外的 <code>location</code> 属性，但这不会引发错误。<br>只有目标类型（这里是 <code>Named</code>）的成员会被一一检查是否兼容。<br>这个比较过程是递归进行的，检查每个成员及子成员。</p></blockquote><h3 id="10-4-比较两个函数"><a href="#10-4-比较两个函数" class="headerlink" title="10.4 比较两个函数"></a>10.4 比较两个函数</h3><ol><li>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。</li></ol><ul><li>下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</li></ul><pre><code class="typescript">let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // &lt;- Ok// x = y; // &lt;- Error</code></pre><blockquote><p>要查看 <code>x</code> 是否能赋值给 <code>y</code>，首先看它们的参数列表。 <code>x</code> 的每个参数必须能在 <code>y</code> 里找到对应类型的参数。注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code> 的每个参数在 <code>y</code> 中都能找到对应的参数，所以允许赋值。第二个赋值错误，因为 <code>y</code> 有个必需的第二个参数，但是 <code>x</code> 并没有，所以不允许赋值。<br>你可能会疑惑为什么允许忽略参数，像例子 <code>y = x</code> 中那样。 原因是忽略额外的参数在 <code>JavaScript</code> 里是很常见的。<br>例如，<code>Array.forEach</code> 给回调函数传 <code>3</code> 个参数：数组元素，索引 和 整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p></blockquote><pre><code class="typescript">let items = [1, 2, 3];// Don&#39;t force these extra argumentsitems.forEach((item, index, array) =&gt; console.log(item));// Should be Okitems.forEach(item =&gt; console.log(item));</code></pre><ol start="2"><li>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数。</li></ol><pre><code class="typescript">let x1 = () =&gt; (&#123; name: &quot;Alice&quot; &#125;);let y1 = () =&gt; (&#123; name: &quot;Alice&quot;, location: &quot;Seattle&quot; &#125;);x1 = y1; // Oky1 = x1; // Error, because x() lacks a location property</code></pre><ol start="3"><li>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</li></ol><h3 id="10-5-函数参数双向协变"><a href="#10-5-函数参数双向协变" class="headerlink" title="10.5 函数参数双向协变"></a>10.5 函数参数双向协变</h3><blockquote><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。实际上，这极少会发声错误，并且能够实现很多 <code>JavaScript</code> 里的常见模式。</p></blockquote><ul><li>例如：</li></ul><pre><code class="typescript">enum EventType &#123;  Mouse,  Keyboard&#125;interface Event &#123;  timestamp: number;&#125;interface MouseEvent extends Event &#123;  x1: number;  y1: number;&#125;interface keyEvent extends Event &#123;  keyCode: number;&#125;function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123;  /* …… */&#125;// Unsound, but useful and common 不完整，但是常用常见listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(`$&#123;e.x1&#125;,$&#123;e.y1&#125;`));// Undesirable alternatives in presence of soundness 完整但是不受欢迎listenEvent(EventType.Mouse, (e: Event) =&gt; console.log(`$&#123;(&lt;MouseEvent&gt;e).x1&#125;,$&#123;(&lt;MouseEvent&gt;e).y1&#125;`));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(`$&#123;e.x1&#125;,$&#123;e.y1&#125;`)));// Still disallowed (clear error). Type safety enforced for wholly incompatible types// 仍然不允许（清除错误）。完全不兼容类型所强制规定的类型安全// listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));</code></pre><h3 id="10-6-可选参数和剩余参数"><a href="#10-6-可选参数和剩余参数" class="headerlink" title="10.6 可选参数和剩余参数"></a>10.6 可选参数和剩余参数</h3><ol><li>比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</li><li>当一个函数有剩余参数时，它被当做无限个可选参数。</li><li>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些 undefined 。</li></ol><blockquote><p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数 但对类型系统来说是不确定的参数来调用：</p></blockquote><pre><code class="typescript">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;  /* ... Invoke callback with &#39;args&#39; ... 通过args调用callback */&#125;// Unsound - invokeLater &quot;might&quot; provide any number of arguments// 不健全的是 - 被调用时候可能会提供任意数量的参数invokeLater([1, 2], (x, y) =&gt; console.log(x + &quot;,&quot; + y));// Confusing (x and y are actually required) and unrecoverable// 令我们困惑(是否需要 x 和 y) 并且 不可恢复invokeLater([1, 2], (x?, y?) =&gt; console.log(x + &quot;,&quot; + y));</code></pre><h3 id="10-7-函数重载"><a href="#10-7-函数重载" class="headerlink" title="10.7 函数重载"></a>10.7 函数重载</h3><blockquote><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。这确保了目标函数可以在所有源函数可调用的地方调用。</p></blockquote><h3 id="10-8-枚举"><a href="#10-8-枚举" class="headerlink" title="10.8 枚举"></a>10.8 枚举</h3><blockquote><p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p></blockquote><ul><li>比如：</li></ul><pre><code class="typescript">enum Status &#123;  Ready,  Waiting&#125;enum Color &#123;  Red,  Blue,  Green&#125;let _status = Status.Ready;// _status = Color.Green; // Error</code></pre><h3 id="10-9-类"><a href="#10-9-类" class="headerlink" title="10.9 类"></a>10.9 类</h3><blockquote><p>类与对象字面量和接口差不多，但是有一点不同：类的静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。</p></blockquote><pre><code class="typescript">class Animal &#123;  feet: number;  constructor(name: string, numFeet: number, c: boolean) &#123;&#125;&#125;class Size &#123;  feet: number;  constructor(numFeet: number) &#123;&#125;&#125;let a: Animal;let s: Size;a = s; //Oks = a; //Ok/*  */</code></pre><h3 id="10-10-类的私有和受保护成员"><a href="#10-10-类的私有和受保护成员" class="headerlink" title="10.10 类的私有和受保护成员"></a>10.10 类的私有和受保护成员</h3><blockquote><p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p></blockquote><h3 id="10-11-泛型"><a href="#10-11-泛型" class="headerlink" title="10.11 泛型"></a>10.11 泛型</h3><blockquote><p>因为 <code>TypeScript</code> 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。</p></blockquote><ul><li>比如</li></ul><pre><code class="typescript">interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // Ok, because y matches structure of x</code></pre><blockquote><p>上面代码里，<code>x</code> 和 <code>y</code> 是兼容的，因为它们的结构使用类型参数时，并没有什么不同。</p></blockquote><ul><li>把这个例子改变一下，增加一个成员，就能看出是如何工作的了。</li></ul><pre><code class="typescript">interface NotEmpty&lt;T&gt; &#123;  data: T;&#125;let x1: NotEmpty&lt;number&gt;;let y1: NotEmpty&lt;string&gt;;x1 = y1; // Error，because x and y are not compatible</code></pre><blockquote><p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p></blockquote><blockquote><p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 <code>any</code> 比较。然后用结果类型进行比较，就像上面第一个例子。</p></blockquote><ul><li>比如：</li></ul><pre><code class="typescript">let identity = function &lt;T&gt;(x: T): T &#123;  // ...  return;&#125;;let reverse = function &lt;U&gt;(y: U): U &#123;  // ...  return;&#125;;identity = reverse; // Ok, because (x: any) =&gt; any matches (y: any) =&gt; any</code></pre><h3 id="10-12-高级主题"><a href="#10-12-高级主题" class="headerlink" title="10.12 高级主题"></a>10.12 高级主题</h3><ul><li>子类型和赋值</li></ul><blockquote><p>目前为止，我们使用了&quot;兼容性&quot;，它在语言规范里没有定义，在 <code>TypeScript</code> 里，有两种兼容性：子类型 和 赋值。它们的不同点在于：赋值扩展了子类型兼容性，增加了一些规则，允许和 <code>any</code> 来回赋值，以及 enum 和对应数字值之间的来回赋值。<br>语言里的不同地方分别使用了它们之中的机制。实际上，类型兼容性是由赋值兼容性来控制的，即使在 <code>implements</code> 和 <code>extends</code> 语句也不例外。</p></blockquote><h2 id="十一、高级类型"><a href="#十一、高级类型" class="headerlink" title="十一、高级类型"></a>十一、高级类型</h2><h3 id="11-1-交叉类型"><a href="#11-1-交叉类型" class="headerlink" title="11.1 交叉类型"></a>11.1 交叉类型</h3><blockquote><p>交叉类型 是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。例如，<code>Person &amp; Serializable &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Serializable</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这三种类型的成员。<br>我们大多数是在混入( <code>mixins</code> )或其它不适合典型面向对象模型的地方看到交叉类型的使用。(在 <code>JavaScript</code> 里发生这种情况的场合很多！)</p></blockquote><h4 id="11-1-1-ReadOnly-的实现"><a href="#11-1-1-ReadOnly-的实现" class="headerlink" title="11.1.1 ReadOnly 的实现"></a>11.1.1 <code>ReadOnly</code> 的实现</h4><pre><code class="typescript">type ReadOnly&lt;T&gt; = &#123;    readOnly [P in keyof T]: T[P];&#125;</code></pre><h4 id="11-1-2-Partial-的实现"><a href="#11-1-2-Partial-的实现" class="headerlink" title="11.1.2 Partial 的实现"></a>11.1.2 <code>Partial</code> 的实现</h4><pre><code class="typescript">type Partial&lt;T&gt; = &#123;  [P in keyof T]?: T[P];&#125;;</code></pre><h4 id="11-1-3-Pick-的实现"><a href="#11-1-3-Pick-的实现" class="headerlink" title="11.1.3 Pick 的实现"></a>11.1.3 <code>Pick</code> 的实现</h4><pre><code class="typescript">type Pick&lt;T, K extends keyof T&gt; = &#123;  [P in K]: T[P];&#125;;</code></pre><h4 id="11-1-4-Record-的实现"><a href="#11-1-4-Record-的实现" class="headerlink" title="11.1.4 Record 的实现"></a>11.1.4 <code>Record</code> 的实现</h4><pre><code class="typescript">type Record&lt;K extends string, T&gt; = &#123;  [P in K]: T;&#125;;</code></pre><blockquote><p>下面是如何创建混入的一个简单的例子(<code>&quot;target&quot;: &quot;es5&quot;</code>):</p></blockquote><pre><code class="typescript">function extend&lt;First, Second&gt;(first: First, second: Second): First &amp; Second &#123;    const result: Partial&lt;First &amp; Second&gt;= &#123;&#125;;    for (const prop in first) &#123;        if (first.hasOwnProperty(prop)) &#123;            (&lt;First&gt;result)[prop] = first[prop];        &#125;    &#125;    for (const prop in second) &#123;        if (second.hasOwnProperty(prop)) &#123;            (&lt;Second&gt;result)[prop] = second[prop];        &#125;    &#125;    return &lt;First &amp; Second&gt;result;&#125;&gt;class Person &#123;    constructor(public name: string) &#123;    &#125;&#125;interface Loggable &#123;    log(name: string): void;&#125;class ConsoleLogger implements Loggable &#123;    log(name) &#123;        console.log(`Hello, I&#39;m $&#123;name&#125;`)    &#125;&#125;const jim = extend(new Person(&quot;Jim&quot;), ConsoleLogger.prototype);let c = jim.log(jim.name);console.log(c);</code></pre><h3 id="11-2-联合类型"><a href="#11-2-联合类型" class="headerlink" title="11.2 联合类型"></a>11.2 联合类型</h3><blockquote><p>联合类型 和 交叉类型 很有关联，但是使用上却完全不同。偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。例如下面的函数：</p></blockquote><pre><code class="typescript">/** * Takes a string and adds &quot;padding&quot; to the left. * If &#39;padding&#39; is a string, then &#39;padding&#39; is appended to the left side. * If &#39;padding&#39; is a number, then that number of spaces is added to the left side. */function padLeft(value: string, padding: any) &#123;  if (typeof padding === &quot;number&quot;) &#123;    return Array(padding + 1).join(&quot; &quot;) + value;  &#125;  if (typeof padding === &quot;string&quot;) &#123;    return padding + value;  &#125;  throw new Error(`Expected string or number, got &#39;$&#123;padding&#125;&#39;.`);&#125;padLeft(&quot;Hello World&quot;, 4);</code></pre><blockquote><p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 <code>TypeScript</code> 却不会报错。</p><pre><code class="typescript">let indentedString = padLeft(&quot;Hello World&quot;, true); // 编译阶段通过，运行时报错。</code></pre></blockquote><pre><code>&gt;  在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。这么做显然是非常清晰的，但同时也存在了过度设计。`padLeft` 原始版本的好处之一就是允许我们传入原始类型。这样做的话使用起来既简单又方便。如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。代替 `any`，我们可以使用 联合类型 作为 `padding` 的参数。```typescript/** * Takes a string and adds &quot;padding&quot; to the left. * If &#39;padding&#39; is a string, then &#39;padding&#39; is appended to the left side. * If &#39;padding&#39; is a number, then that number of spaces is added to the left side. */function padLeft1(value: string, padding: string | number) &#123;    // ...&#125;// let indentedString1 = padLeft1(&quot;Hello world&quot;, true); // errors during compilation</code></pre><blockquote><p>联合类型 表示一个值可以是几种类型之一。我们使用竖线(<code>|</code>)分隔每个类型，所以 <code>number | string | boolean</code> 表示一个值可能是 <code>number</code>, <code>string</code>, <code>boolean</code></p></blockquote><pre><code class="typescript">interface Bird &#123;  fly();  lagEggs();&#125;interface Fish &#123;  swim();  layEggs();&#125;function getSmallPet(): Fish | Bird &#123;  // ...&#125;let pet = getSmallPet();pet.layEggs(); // &lt;- ok// pet.swim(); // &lt;- errors</code></pre><blockquote><p>这里的联合类型可能有点复杂，但是你很容易就习惯了。如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Bird</code> 具有一个 <code>fly</code> 成员。我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>fly</code> 方法。如果变量在运行时是 <code>Fish</code> 类型，那么调用 <code>pet.fly()</code> 就出错了。</p></blockquote><h3 id="11-3-类型守卫与类型区分"><a href="#11-3-类型守卫与类型区分" class="headerlink" title="11.3 类型守卫与类型区分"></a>11.3 类型守卫与类型区分</h3><blockquote><p>联合类型适用于那些值可以为不同类型的情况。但当我们想确切地了解是否为 <code>Fish</code> 时怎么办？<code>JavaScript</code> 里常用来区分 <code>2</code> 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p></blockquote><pre><code class="typescript">interface Fish &#123;  swim();  layEggs();&#125;interface Bird &#123;  fly();  layEggs();&#125;function getSmallPet(): Fish | Bird &#123;  return;&#125;let pet = getSmallPet();</code></pre><blockquote><p>每一个访问的成员都会报错</p></blockquote><pre><code class="typescript">if (pet.swim) &#123;  pet.swim();&#125; else if (pet.fly) &#123;  pet.fly();&#125;</code></pre><blockquote><p>为了让这段代码工作，我们需要使用类型断言</p></blockquote><pre><code class="typescript">if ((&lt;Fish&gt;pet).swim) &#123;  (&lt;Fish&gt;pet).swim();&#125; else if ((&lt;Bird&gt;pet).fly) &#123;  (&lt;Bird&gt;pet).fly();&#125;</code></pre><h3 id="11-4-用户自定义的类型守卫"><a href="#11-4-用户自定义的类型守卫" class="headerlink" title="11.4 用户自定义的类型守卫"></a>11.4 用户自定义的类型守卫</h3><blockquote><p>这里我们注意到不得不多次使用类型断言。假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p></blockquote><blockquote><p><code>TypeScript</code> 里的类型守卫机制让它成为了现实。类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。要想定义一个类型守卫，我们只需要简单地定义一个函数，它的返回值是一个类型谓词：</p></blockquote><pre><code class="typescript">interface Fish &#123;  swim();  layEggs();&#125;interface Bird &#123;  fly();  layEggs();&#125;function isFish(pet: Fish | Bird): pet is Fish &#123;  return (&lt;Fish&gt;pet).swim !== undefined;&#125;</code></pre><blockquote><p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。<br>每当使用一些变量调用 <code>isFish</code> <code>时，TypeScript</code> 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的<br><code>swim</code> 和 <code>fly</code> 的调用都没有问题了</p></blockquote><pre><code class="typescript">if (isFish(pet)) &#123;  pet.swim();&#125; else &#123;  pet.fly();&#125;</code></pre><blockquote><p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分之里，一定不是 <code>Fish</code> 类型，一定是 Bird 类型。</p></blockquote><h3 id="11-5-typeof-类型守卫"><a href="#11-5-typeof-类型守卫" class="headerlink" title="11.5 typeof 类型守卫"></a>11.5 typeof 类型守卫</h3><blockquote><p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。 我们可以像下面这样利用类型断言来写：</p></blockquote><pre><code class="typescript">function isNumber(x: any): x is number &#123;  return typeof x === &quot;number&quot;;&#125;function isString(x: any): x is string &#123;  return typeof x === &quot;string&quot;;&#125;function padLeft(value: string, padding: string | number) &#123;  if (isNumber(padding)) &#123;    return Array(padding + 1).join(&quot; &quot;) + value;  &#125;  if (isString(padding)) &#123;    return padding + value;  &#125;  throw new Error(`Expected string or number, go $&#123;padding&#125;.`);&#125;</code></pre><blockquote><p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。幸运的是，现在我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为 <code>TypeScript</code> 可以将它识别为一个类型守卫。也就是说，我们可以直接在代码里检查类型了。</p></blockquote><pre><code class="typescript">function newPadLeft(value: string, padding: string | number) &#123;  if (typeof padding === &quot;number&quot;) &#123;    return Array(padding + 1).join(&quot; &quot;) + value;  &#125;  if (typeof padding === &quot;string&quot;) &#123;    return padding + value;  &#125;  throw new Error(`Expected string or number, go $&#123;padding&#125;.`);&#125;</code></pre><blockquote><p>这些 <code>typeof</code> 类型守卫只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>, <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。但是 <code>TypeScript</code> 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。</p></blockquote><h3 id="11-6-instanceof-类型守卫"><a href="#11-6-instanceof-类型守卫" class="headerlink" title="11.6 instanceof 类型守卫"></a>11.6 instanceof 类型守卫</h3><blockquote><p><code>instanceof</code> 类型守卫是通过构造函数来细化类型的一种方式。比如，我们借鉴一下之前字符串填充的例子：</p></blockquote><pre><code class="typescript">interface Padder &#123;  getPaddingString(): string;&#125;class SpaceRepeatingPadder implements Padder &#123;  constructor(private numSpaces: number) &#123;&#125;  getPaddingString() &#123;    return Array(this.numSpaces + 1).join(&quot; &quot;);  &#125;&#125;class StringPadder implements Padder &#123;  constructor(private value: string) &#123;&#125;  getPaddingString() &#123;    return this.value;  &#125;&#125;function getRandomPadder() &#123;  return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(&quot; &quot;);&#125;// 类型为 SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123;  padder; // 类型细化为 &#39;SpaceRepeatingPadder&#39;&#125;if (padder instanceof StringPadder) &#123;  padder; // 类型细化为 &#39;StringPadder&#39;&#125;</code></pre><blockquote><p><code>instanceof</code> 的右侧要求是一个构造函数，<code>TypeScript</code> 将细化为:</p></blockquote><ol><li>此构造函数的 <code>prototype</code> 属性的类型，如果它的类型不为 <code>any</code> 的话</li><li>标签签名所返回的类型的联合</li></ol><blockquote><p>以此顺序。</p></blockquote><h3 id="11-7-可为-null-的类型"><a href="#11-7-可为-null-的类型" class="headerlink" title="11.7 可为 null 的类型"></a>11.7 可为 null 的类型</h3><blockquote><p><code>TypeScript</code> 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code> ，它们分别具有值 <code>null</code> 和 <code>undefined</code>。默认情况下，类型检查器会认为 <code>null</code> 和 <code>undefined</code> 可以赋值给任何类型。<code>null</code> 和 <code>undefined</code> 是所有其它类型的一个有效值。这意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p></blockquote><blockquote><p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。</p></blockquote><ul><li>你可以使用联合类型明确的包含它们：```typescript<br>let s = &quot;foo&quot;;<br>s = null; // --strictNullChecks 模式下 错误， &#39;null&#39; 不能赋值给 &#39;string&#39;<br>let sn: string | null = &quot;bar&quot;;<br>sn = null; // Ok<br>sn = undefined; // --strictNullChecks 模式下 error, 因为&#39;undefined&#39;不能赋值给&#39;string | null&#39;</li></ul><pre><code>&gt;  注意：按照 `JavaScript` `的语义，TypeScript` 会把 `null` 和 `undefined` 区别对待。&gt; `string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。### 11.8 可选参数和可选属性- 使用了 `--strictNullChecks` ，可选参数会被自动地加上 `| undefined`:```typescriptfunction f(x: number, y?: number) &#123;    return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, &#39;null&#39; is not assignable to &#39;number | undefined&#39;</code></pre><ul><li>可选属性也会有同样的处理</li></ul><pre><code class="typescript">class C &#123;  a: number;  b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, &#39;undefined&#39; is not assignable to &#39;number&#39;c.b = 13;c.b = undefined; // Okc.b = null; // error, &#39;null&#39; is not assignable to &#39;number | undefined&#39;</code></pre><h3 id="11-9-类型守卫和类型断言"><a href="#11-9-类型守卫和类型断言" class="headerlink" title="11.9 类型守卫和类型断言"></a>11.9 类型守卫和类型断言</h3><blockquote><p>由于可以为 <code>null</code> 的类型是通过联合类型实现，那么你需要使用类型守卫来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p></blockquote><pre><code class="typescript">function f(sn: string | null): string &#123;  if (sn == null) &#123;    return &quot;default&quot;;  &#125; else &#123;    return sn;  &#125;&#125;</code></pre><blockquote><p>这里很明显地去除了 <code>null</code>, 你也可以使用短路运算符:</p></blockquote><pre><code class="typescript">function f1(sn: string | null): string &#123;  return sn || &quot;default&quot;;&#125;</code></pre><blockquote><p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀：<code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p></blockquote><pre><code class="typescript">function broken(name: string | null): string &#123;  function postfix(epihet: string) &#123;    return name.charAt(0) + &quot;. the&quot; + epihet; // error, &#39;name&#39; is possibly null  &#125;  name = name || &quot;Bob&quot;;  return postfix(&quot;great&quot;);&#125;function fixed(name: string | null): string &#123;  function postfix(epihet: string) &#123;    return name!.charAt(0) + &quot;. the&quot; + epihet; // Ok  &#125;  name = name || &quot;Bob&quot;;  return postfix(&quot;great&quot;);&#125;</code></pre><blockquote><p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code> (除非是立即调用的函数表达式)。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数作为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p></blockquote><h3 id="11-10-类型别名"><a href="#11-10-类型别名" class="headerlink" title="11.10 类型别名"></a>11.10 类型别名</h3><ol><li>类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于 原始值，联合类型，元组 以及其它任何你需要手写的类型。</li></ol><pre><code class="typescript">type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123;  if (typeof n === &quot;string&quot;) &#123;    return n;  &#125; else &#123;    return n();  &#125;&#125;</code></pre><ol start="2"><li>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。</li></ol><p>3.给原始类型起别名通常没有什么用，尽管可以作为文档的一种形式使用。</p><ol start="4"><li>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入。</li></ol><pre><code class="typescript">type Container&lt;T&gt; = &#123; value: T &#125;;</code></pre><ol start="5"><li>我们也可以使用类型别名来在属性里引用自己：</li></ol><pre><code class="typescript">type Tree&lt;T&gt; = &#123;  value: T;  left: Tree&lt;T&gt;;  right: Tree&lt;T&gt;;&#125;;</code></pre><ol start="6"><li>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型</li></ol><pre><code class="typescript">type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123;  name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name;</code></pre><blockquote><p>然而，类型别名不能出现在声明右侧的任何地方</p></blockquote><pre><code class="typescript">// type Yikes = Array&lt;Yikes&gt;; // error</code></pre><h3 id="11-11-接口-vs-类型别名"><a href="#11-11-接口-vs-类型别名" class="headerlink" title="11.11 接口 vs 类型别名"></a>11.11 接口 vs 类型别名</h3><blockquote><p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p></blockquote><ol><li>接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新名字 - 比如，错误信息就不会使用别名。</li></ol><blockquote><p>在下面的示例代码里，在编译器中将鼠标悬停在 <code>interfaced</code> 上，显示它返回的是 <code>Interface</code>，但悬停在 <code>aliased</code> 上时，显示的却是对象字面量类型。</p></blockquote><pre><code class="typescript">type Alias = &#123; num: number &#125;;interface Interface &#123;  num: number;&#125;declare function aliased(arg: Alias): Alias;declare function interfaced(arg: Interface): Interface;</code></pre><ol start="2"><li>另一个重要区别是类型别名不能被 <code>extends</code> 和 <code>implements</code> (自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型)。因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。</li><li>另一方面，如果你无法通过接口来描述一个类型并且需要使用 联合类型 或 元组类型，这时通常会使用类型别名。</li></ol><h3 id="11-12-字符串字面量类型"><a href="#11-12-字符串字面量类型" class="headerlink" title="11.12 字符串字面量类型"></a>11.12 字符串字面量类型</h3><blockquote><p>字符串字面量类型允许你指定字符串必须的固定值。在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p></blockquote><pre><code class="typescript">type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;class UIElement &#123;  animate(dx: number, dy: number, easing: Easing) &#123;    if (easing === &quot;ease-in&quot;) &#123;      // ...    &#125; else if (easing === &quot;ease-out&quot;) &#123;      // ...    &#125; else if (easing === &quot;ease-in-out&quot;) &#123;      // ...    &#125; else &#123;      // error! should not pass null or undefined.    &#125;  &#125;&#125;let button = new UIElement();button.animate(0, 0, &quot;ease-in&quot;);// button.animate(0, 0,&quot;uneasy&quot;); // error: &quot;uneasy&quot; is not allowed here</code></pre><ul><li>你只能从三种允许的字符中选择其一来作为参数传递，传入其它值则会产生错误。</li></ul><pre><code class="typescript">// Argument of type &#39;&quot;uneasy&quot;&#39; is not assignable to parameter of type &#39;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#39;</code></pre><ul><li>字符串字面量类型还可以用于区分函数重载</li></ul><pre><code class="typescript">function createElement(tagName: &quot;img&quot;): HTMLImageElement;function createELement(tagName: &quot;input&quot;): HTMLInputElement;// ... more overloads ...function createElement(tagName: &quot;string&quot;): Element &#123;  // ... code goes here ...&#125;</code></pre><h3 id="11-13-数字字面量类型"><a href="#11-13-数字字面量类型" class="headerlink" title="11.13 数字字面量类型"></a>11.13 数字字面量类型</h3><ul><li><code>TypeScript</code> 还具有数字字面量类型</li></ul><pre><code class="typescript">function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 &#123;  // ...&#125;</code></pre><ul><li>我们很少直接这样使用，但它们可以用在缩小范围调试 <code>bug</code> 的时候。</li></ul><pre><code class="typescript">function foo(x: number) &#123;  if (x !== 1 || x !== 2) &#123;    // ~~~~~~    // Operator &#39;!==&#39; cannot be applied to types &#39;1&#39; and &#39;2&#39;  &#125;&#125;</code></pre><blockquote><p>换句话说，当 <code>x</code> 与 <code>2</code> 进行比较的时候，它的值必须为 <code>1</code>，这就意味着上面的比较检查是非法的。</p></blockquote><h3 id="11-14-枚举成员类型"><a href="#11-14-枚举成员类型" class="headerlink" title="11.14 枚举成员类型"></a>11.14 枚举成员类型</h3><blockquote><p>如我们在枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。在我们谈及“单例类型”的时候，多数是指 枚举成员类型 和 数字/字符串 字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p></blockquote><h3 id="11-15-可辨识联合"><a href="#11-15-可辨识联合" class="headerlink" title="11.15 可辨识联合"></a>11.15 可辨识联合</h3><blockquote><p>你可以合并 单例类型，联合类型，类型守卫 和 类型别名 来创建一个叫做 可辨识联合 的高级模式，它也称作 标签联合 或 代数数据类型。可辨识联合 在函数式编程里很有用处。一些语言会自动地为你辨识联合；而 <code>TypeScript</code> 则基于已有的 <code>JavaScript</code> 模式，。它具有 <code>3</code> 个要素：</p></blockquote><ol><li>具有普通的单例类型属性 - 可辨识的特征</li><li>一个类型别名包含了那些类型的联合 - 联合。</li><li>此属性上的类型守卫</li></ol><pre><code class="typescript">interface Square &#123;  kind: &quot;square&quot;;  size: number;&#125;interface Rectangle &#123;  kind: &quot;rectangle&quot;;  width: number;  height: number;&#125;interface Circle &#123;  kind: &quot;circle&quot;;  radius: number;&#125;</code></pre><blockquote><p>首先我们声明了将要联合的接口。每个接口都有 <code>kind</code> 属性但有不同的字符串字面量类型。<code>kind</code> 属性称作 可辨识的特征或标签。其它的属性则特定于各个接口。注意，目前各个接口间是没有联系的。</p></blockquote><ul><li>下面我们将它们联合到一起。</li></ul><pre><code class="typescript">type Shape = Square | Rectangle | Circle;</code></pre><ul><li>现在我们使用可辨识联合</li></ul><pre><code class="typescript">function area(s: Shape) &#123;  switch (s.kind) &#123;    case &quot;square&quot;:      return s.size * s.size;    case &quot;rectangle&quot;:      return s.width * s.height;    case &quot;circle&quot;:      return Math.PI * s.radius ** 2;  &#125;&#125;let areaSquare = area(&#123; kind: &quot;square&quot;, size: 12 &#125;);let areaRectangle = area(&#123; kind: &quot;rectangle&quot;, width: 14, height: 13 &#125;);let areaCircle = area(&#123; kind: &quot;circle&quot;, radius: 5 &#125;);console.log(areaSquare, areaRectangle, areaCircle);</code></pre><h3 id="11-16-完整性检查"><a href="#11-16-完整性检查" class="headerlink" title="11.16 完整性检查"></a>11.16 完整性检查</h3><blockquote><p>当没有涵盖所有 可辨识联合 的变化时，我们想让编译器可以通知我们。比如，如果我们添加了 <code>Triangle</code> 和 <code>Shape</code>，我们同时还需要更新 <code>area</code>：</p></blockquote><pre><code class="typescript">interface Square &#123;  kind: &quot;square&quot;;  size: number;&#125;interface Rectangle &#123;  kind: &quot;rectangle&quot;;  width: number;  height: number;&#125;interface Circle &#123;  kind: &quot;circle&quot;;  radius: number;&#125;// interface Triangle &#123; kind: &quot;triangle&quot;, bottom: number, height: number &#125;type Shape = Square | Rectangle | Circle;function area(s: Shape) &#123;  switch (s.kind) &#123;    case &quot;square&quot;:      return s.size * s.size;    case &quot;rectangle&quot;:      return s.width * s.height;    case &quot;circle&quot;:      return Math.PI * s.radius ** 2;  &#125;  // should error here - we didn&#39;t handle case &quot;triangle&quot;&#125;</code></pre><ul><li>有两种方式可以实现。</li></ul><ol><li>首先是启用 <code>--strictNullChecks</code> 并且指定一个返回值类型:</li></ol><pre><code class="typescript">function area1(s: Shape): number &#123;  switch (s.kind) &#123;    case &quot;square&quot;:      return s.size * s.size;    case &quot;rectangle&quot;:      return s.height * s.width;    case &quot;circle&quot;:      return Math.PI * s.radius ** 2;  &#125;&#125;</code></pre><blockquote><p>因为 <code>switch</code> 没有包含所有情况，所以 <code>TypeScript</code> 认为这个函数有时候会返回 <code>undefined</code>。如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值类型为 <code>number | undefined</code>。然而，这种方法存在些微妙之处且 <code>--strictNullChecks</code> 对旧代码支持不好。</p></blockquote><ol start="2"><li>第二种方法使用 <code>never</code> 类型，编译器用它来进行完整性检查</li></ol><pre><code class="typescript">function assertNever(x: never): never &#123; throw new Error(&quot;Unexpected object: &quot; + x);&#125;&gt;function area2(s: Shape) &#123; switch (s.kind) &#123;     case &quot;square&quot;:         return s.size * s.size;     case &quot;rectangle&quot;:         return s.width * s.height;     case &quot;circle&quot;:         return Math.PI * s.radius ** 2;     default:         return assertNever(s); // error here if there are missing cases &#125;&#125;</code></pre><blockquote><p>这里，<code>assertNever</code> 检查 <code>s</code> 是否为 <code>never</code> 类型 - 即为除去所有可能情况后剩下的类型。如果你忘记了某个 <code>case</code>，那么 <code>s</code> 将具有一个真实的类型并且你会得到一个错误。这种方式需要你定义一个额外的函数，但是在你忘记某个 <code>case</code> 的时候也更加明显。</p></blockquote><h3 id="11-17-多态的-this-类型"><a href="#11-17-多态的-this-类型" class="headerlink" title="11.17 多态的 this 类型"></a>11.17 多态的 this 类型</h3><blockquote><p>多态的 <code>this</code> 类型表示的是某个包含类或接口的子类型。这被称作是 <code>F-bounded</code> 多态性。它能很容易的表现连贯接口间的继承。</p></blockquote><ul><li>比如，在计算器的例子里，在每个操作之后都返回 <code>this</code> 类型。</li></ul><pre><code class="typescript">class BasicCalculator &#123;  public constructor(protected value: number = 0) &#123;&#125;  public currentValue(): number &#123;    return this.value;  &#125;  public add(operand: number): this &#123;    this.value += operand;    return this;  &#125;  public multiply(operand: number): this &#123;    this.value *= operand;    return this;  &#125;  //...other operations go here...&#125;let v = new BasicCalculator(2).multiply(5).add(1).currentValue();console.log(v);</code></pre><blockquote><p>由于这个类使用了 <code>this</code> 类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何改变。</p></blockquote><pre><code class="typescript">class ScientificCalculator extends BasicCalculator &#123;  public constructor(value = 0) &#123;    super(value);  &#125;  public sin() &#123;    this.value = Math.sin(this.value);    return this;  &#125;  // ... other operations go here ...&#125;let v1 = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();console.log(v1);</code></pre><blockquote><p>如果没有 <code>this</code> 类型，<code>ScientificCalculator</code> 就不能够在继承 <code>BasicCalculator</code> 的同时还保持接口的连贯性。<code>multiply</code> 将会返回 <code>BasicCalculator</code>，它并没有 <code>sin</code> 方法。然而，使用 <code>this</code> 类型，<code>multiply</code> 会返回 <code>this</code>，在这里就是 <code>ScientificCalculator</code>。</p></blockquote><h3 id="11-18-索引类型"><a href="#11-18-索引类型" class="headerlink" title="11.18 索引类型"></a>11.18 索引类型</h3><blockquote><p>使用索引类型，编译器就能够检查使用了动态属性名的代码。</p></blockquote><ul><li>例如，一个常见的 <code>JavaScript</code> 模式是从对象中选取属性的子集。</li></ul><pre><code class="typescript">function js_pluck(o, names) &#123;  return names.map(n =&gt; o[n]);&#125;</code></pre><ul><li>下面是如何在 <code>TypeScript</code> 里使用此函数，通过 索引类型查询和 索引访问 操作符：</li></ul><pre><code class="typescript">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123;  return names.map(n =&gt; o[n]);&#125;interface Person &#123;  name: string;  age: number;&#125;let person: Person = &#123;  name: &quot;Jarid&quot;,  age: 35&#125;;let strings: string[] = pluck(person, [&quot;name&quot;]);console.log(strings);</code></pre><blockquote><p>编译器会检查 <code>name</code> 是否真的是 <code>Person</code> 的一个属性。本例还引入了几个新的类型操作符。</p></blockquote><h4 id="11-18-1-首先是-keyof-T，索引类型查询操作符。"><a href="#11-18-1-首先是-keyof-T，索引类型查询操作符。" class="headerlink" title="11.18.1 首先是 keyof T，索引类型查询操作符。"></a>11.18.1 首先是 <code>keyof T</code>，索引类型查询操作符。</h4><blockquote><p>对于任何类型 <code>T</code> ，<code>keyof T</code> 的结果为 <code>T</code> 上已知的公共属性名的联合。</p></blockquote><ul><li>例如：</li></ul><pre><code class="typescript">let personProps: keyof Person; // &#39;name&#39; | &#39;age&#39;</code></pre><blockquote><p><code>keyof Person</code> 是完全可以与 <code>&#39;name&#39; \| &#39;age&#39;</code> 互相替换的。不同的是如果你添加了其它的属性到 <code>Person</code>, 例如 <code>address: string</code>，那么<code>keyof Person</code> 会自动变为 <code>&#39;name&#39; | &#39;age&#39; | &#39;address&#39;</code>。你可以像 <code>pluck</code> 函数这类上下文里使用 <code>keyof</code> ，因为在使用之前你并不清楚可能出现的属性名。但编译器会检查你是否传入了正确的属性名给 <code>pluck</code>：</p></blockquote><pre><code class="typescript">// pluck(person, [&#39;age&#39;, &#39;unknown&#39;]); // error, &#39;unknown&#39; is not in &#39;name&#39; | &#39;age&#39;</code></pre><h4 id="11-18-2-第二个操作符是-T-K-索引访问操作符。"><a href="#11-18-2-第二个操作符是-T-K-索引访问操作符。" class="headerlink" title="11.18.2 第二个操作符是 T[K], 索引访问操作符。"></a>11.18.2 第二个操作符是 <code>T[K]</code>, 索引访问操作符。</h4><blockquote><p>在这里，类型语法反应了表达式语法。这意味着 <code>person[&#39;name&#39;]</code> 具有类型 <code>Person[&#39;name&#39;]</code> -- 在我们的例子里则为 <code>string</code> 类型。然而，就像索引类型查询一样，你可以在普通的上下文里使用 <code>T[K]</code>，这正是它的强大所在。你只要确保类型变量 <code>K extends keyof T</code> 就可以了。</p></blockquote><ul><li>例如下面 <code>getProperty</code> 函数的例子：</li></ul><pre><code class="typescript">function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123;  return o[name]; // o[name] is of type T[K]&#125;</code></pre><blockquote><p><code>getProperty</code> 里的 <code>o: T</code> 和 <code>name: K</code>，意味着 <code>o[name]: T[K]</code>。当你返回 <code>T[K]</code> 的结果，</p></blockquote><blockquote><p>编译器会是实例化键的真实类型，因此 <code>getProperty</code> 的返回值类型会随着你需要的属性改变。</p></blockquote><pre><code class="typescript">let _name: string = getProperty(person, &quot;name&quot;);let _age: number = getProperty(person, &quot;age&quot;);// let unknown = getProperty(person, &quot;unknown&quot;); // error, &#39;unknown&#39; is not in &#39;name&#39; | &#39;age&#39;console.log(_name, &quot; &quot;, _age);</code></pre><h3 id="11-19-索引类型和字符串索引签名"><a href="#11-19-索引类型和字符串索引签名" class="headerlink" title="11.19 索引类型和字符串索引签名"></a>11.19 索引类型和字符串索引签名</h3><blockquote><p><code>keyof</code> 和 <code>T[K]</code> 与字符串索引签名进行交互。如果你有一个带有字符串索引签名的类型，那么 <code>keyof T</code> 会是 <code>string</code>。并且 <code>T[string]</code> 为索引签名的类型。</p></blockquote><pre><code class="typescript">interface Dictionary&lt;T&gt; &#123;  [key: string]: T;&#125;let keys: keyof Dictionary&lt;number&gt;; // stringlet value: Dictionary&lt;number&gt;[&quot;foo&quot;]; // number</code></pre><h3 id="11-20-映射类型"><a href="#11-20-映射类型" class="headerlink" title="11.20 映射类型"></a>11.20 映射类型</h3><ul><li>一个常见的任务是将一个已知的类型每个属性都变为可选的。</li></ul><pre><code class="typescript">interface PersonPartial &#123;  name?: string;  age?: number;&#125;</code></pre><ul><li>或者我们只想要一个只读版本</li></ul><pre><code class="typescript">interface PersonReadonly &#123;  readonly name: string;  readonly age: number;&#125;</code></pre><blockquote><p>这在 <code>JavaScript</code> 里经常出现。<code>TypeScript</code> 提供了从旧类型中创建新类型的一种方式 <code>--</code> 映射类型。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。假如，你可以令每个属性成为 <code>readonly</code> 类型或可选的。</p></blockquote><ul><li>下面是一些例子：</li></ul><pre><code class="typescript">type Readonly&lt;T&gt; = &#123;  readonly [P in keyof T]: T[P];&#125;;type Partial&lt;T&gt; = &#123;  [P in keyof T]?: T[P];&#125;;</code></pre><ul><li>像下面这样使用</li></ul><pre><code class="typescript">interface Person &#123;&#125;type PersonPartial = Partial;type PersonReadonly = Readonly;</code></pre><blockquote><p>需要注意的是，这个语法描述的是类型而非成员。若想添加额外的成员，则可以使用 交叉类型。</p></blockquote><ul><li>这样使用</li></ul><pre><code class="typescript">type PartialWithNewMember&lt;T&gt; = &#123;  [P in keyof T]?: T[P];&#125; &amp; &#123; newMember: boolean &#125;;</code></pre><ul><li>不要这样使用</li></ul><pre><code class="typescript">type PartialWithNewMember&lt;T&gt; = &#123;  [P in keyof T]?: T[P];  newMember: boolean;&#125;</code></pre><blockquote><p>下面来看看最简单的映射类型和它的组成部分</p></blockquote><pre><code class="typescript">type Keys = &quot;option1&quot; | &quot;option2&quot;;type Flags = &#123; [K in Keys]: boolean &#125;;</code></pre><blockquote><p>它的语法与索引签名的语法类型，内部使用了 <code>for...in</code>。具有三个部分：</p></blockquote><ol><li>类型变量 <code>K</code>，它会依次绑定到每个属性。</li><li>字符串字面量联合的 <code>Keys</code>，它包含了要迭代的属性名的集合。</li><li>属性的结果类型。</li></ol><blockquote><p>在上面这个简单的例子里，<code>Keys</code> 是硬编码的属性列表并且属性类型永远是 <code>boolean</code>，因此这个映射类型</p></blockquote><ul><li>等同于：</li></ul><pre><code class="typescript">type _FLags = &#123;  option1: boolean;  option2: boolean;&#125;;</code></pre><blockquote><p>在真正的应用里，可能不同于上面的 <code>Readonly</code> 或 <code>Partial</code>。它们会基于一些已存在的类型，且按照一定的方式转换字段。这就是 <code>keyof</code> 和 <code>索引访问类型</code> 要做的事情。</p></blockquote><pre><code class="typescript">type NullablePerson = &#123; [P in keyof Person]: Person[P] | null &#125;;type PartialPerson = &#123; [P in keyof Person]?: Person[P] &#125;;</code></pre><blockquote><p>但它更有用的地方是可以有一些通用版本。</p></blockquote><pre><code class="typescript">type Nullable&lt;T&gt; = &#123; [P in keyof T]: T[P] | null &#125;;type Partial1&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;</code></pre><blockquote><p>在这些例子里，属性列表是 <code>keyof T</code> 且结果类型是 <code>T[P]</code> 的变体。这是使用通用映射类型的一个好模版。因为这类转换是同态的，映射只作用于 <code>T</code> 的属性而没有其它的。编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。假如，假设 <code>Person.name</code> 是只读的，那么 <code>Partial1&lt;Person&gt;.name</code> 也将是只读的且为可选的。</p></blockquote><blockquote><p>下面是另一个例子，<code>T[P]</code> 被包装在 <code>Proxy&lt;T&gt;</code> 类里：</p></blockquote><pre><code class="typescript">type Proxy&lt;T&gt; = &#123;  get(): T;  set(value: T): void;&#125;;type Proxify&lt;T&gt; = &#123;  [P in keyof T]: Proxy&lt;T[P]&gt;;&#125;;function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; &#123;  // ...wrap proxies&#125;let proxyProps = proxify(props);</code></pre><blockquote><p>注意 <code>Readonly&lt;T&gt;</code> 和 <code>Partial&lt;T&gt;</code> 用处不小，因此它们于 <code>pick</code> 和 <code>Record</code> 一同被包含进了 <code>TypeScript</code> 的标准库里：</p></blockquote><pre><code class="typescript">type Pick&lt;T, K extends keyof T&gt; = &#123;  [P in K]: T[P];&#125;;type Record&lt;K extends keyof any, T&gt; = &#123;  [P in K]: T;&#125;;</code></pre><blockquote><p><code>Readonly</code>, <code>Partial</code> 和 <code>Pick</code> 是同态的，但 <code>Record</code> 不是。因为 <code>Record</code> 并不需要输入类型来拷贝属性，所以它不属于同态：</p></blockquote><pre><code class="typescript">type ThreeStringProps = Record&lt;&quot;prop1&quot; | &quot;prop2&quot; | &quot;prop3&quot;, string&gt;;</code></pre><blockquote><p>非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。</p></blockquote><h3 id="11-21-由映射类型进行判断"><a href="#11-21-由映射类型进行判断" class="headerlink" title="11.21 由映射类型进行判断"></a>11.21 由映射类型进行判断</h3><blockquote><p>现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。其实这也非常容易：</p></blockquote><pre><code class="typescript">type Proxify&lt;T&gt; = &#123;  get(): T;  set(value: T): void;&#125;;function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T &#123;  let result = &#123;&#125; as T;  for (const k in t) &#123;    result[k] = t[k].get();  &#125;  return result;&#125;// let originalProps = unproxify(proxyProps);</code></pre><blockquote><p>注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。</p></blockquote><h3 id="11-22-有条件类型"><a href="#11-22-有条件类型" class="headerlink" title="11.22 有条件类型"></a>11.22 有条件类型</h3><blockquote><p><code>TypeScript 2.8</code> 引入了有条件类型，它能够表示非统一的类型。有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p></blockquote><pre><code class="typescript">T extends U ? X : Y</code></pre><blockquote><p>上面的类型意思是：若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code></p></blockquote><blockquote><p>有条件的类型 <code>T extends U ? X : Y</code> 或者解析为 <code>X</code>，或者解析为 <code>Y</code>，再或者延迟解析，因为它可能依赖一个或多个类型变量。若 <code>T</code> 或 <code>U</code> 包含类型参数，那么是否解析为 <code>X</code> 或 <code>Y</code> 或推迟，取决于类型系统是否有足够的信息来确定 <code>T</code> 总是可以赋值给 <code>U</code>。</p></blockquote><ul><li>下面是一些类型可以被立即解析的例子：</li></ul><pre><code class="typescript">declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;// Type is &#39;string&#39; | &#39;number&#39;let x = f(Math.random() &lt; 0.5);</code></pre><blockquote><p>另外一个例子涉及 <code>TypeName</code> 类型别名，它使用了嵌套了有条件类型</p></blockquote><pre><code class="typescript">type TypeName&lt;T&gt; = T extends string ? &quot;string&quot; : T extends number ? &quot;number&quot; : T extends boolean ? &quot;boolean&quot; : T extends undefined ? &quot;undefined&quot; : T extends Function ? &quot;function&quot; : &quot;object&quot;;type T0 = TypeName&lt;string&gt;; // &quot;string&quot;type T1 = TypeName&lt;&quot;a&quot;&gt;; // &quot;string&quot;type T2 = TypeName&lt;true&gt;; // &quot;boolean&quot;type T3 = TypeName&lt;() =&gt; void&gt;; // &quot;function&quot;type T4 = TypeName&lt;string[]&gt;; // &quot;object&quot;</code></pre><ul><li>下面是一个有条件类型被推迟解析的例子</li></ul><pre><code class="typescript">interface Foo &#123;  propA: boolean;  propB: boolean;&#125;declare function f&lt;T&gt;(x: T): T extends Foo ? string : number;function foo&lt;U&gt;(x: U) &#123;  // Has type &#39;U extends Foo ? string : number&#39;  let a = f(x);  // This assignment is allowed though!  let b: string | number = a;&#125;</code></pre><blockquote><p>这里，<code>a</code> 变量含有未确定的有条件类型。当有另一段代码调用 <code>foo</code>，它会用其它类型替换 <code>U</code>，<code>TypeScript</code> 将重新计算有条件类型，决定它是否可以选择一个分支。与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支，都可以赋值给目标类型。因此在我们的例子里，我们可以将 <code>U extends Foo ? string : number</code> 赋值给 <code>string | number</code>，因为不管这个有条件类型最终结果是什么，它只能是 <code>string | number</code>。</p></blockquote><h3 id="11-23-分布式有条件类型"><a href="#11-23-分布式有条件类型" class="headerlink" title="11.23 分布式有条件类型"></a>11.23 分布式有条件类型</h3><blockquote><p>如果有条件类型里待检查的类型是 <code>naked type parameter</code> ，那么它也被称为&quot;分布式有条件类型&quot;。分布式有条件类型在实例化时会自动分发成联合类型。例如：实例化 <code>T extends U ? X : Y</code>，<code>T</code> 的类型为 <code>A | B | C</code>，会被解析为 <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p></blockquote><ul><li>例子：```typescript<br>type TypeName<T> =<br>T extends string ? &quot;string&quot; :<br>T extends number ? &quot;number&quot; :<br>T extends boolean ? &quot;boolean&quot; :<br>T extends undefined ? &quot;undefined&quot; :<br>T extends Function ? &quot;function&quot; : &quot;object&quot;;<br>type T10 = TypeName&lt;string | (() =&gt; void)&gt;; // &quot;string&quot; | &quot;function&quot;<br>type T11 = TypeName&lt;string | string[] | undefined&gt;; // &quot;string&quot; | &quot;object&quot; | &quot;undefined&quot;<br>type T12 = TypeName&lt;string[] | number[]&gt;; // &quot;object&quot;</li></ul><pre><code>&gt;  在 `T extends U ? X : Y` 的实例化里，对 `T` 的引用被解析为联合类型的一部分(比如，`T` 指向某一单个部分，在有条件类型分布到联合类型之后)。此外，在 `X` 内对 `T` 的引用有一个附加的类型参数约束 `U`(例如，`T` 被当成在 `X` 内可赋值给 `U`)。- 例子：```typescripttype BoxedValue&lt;T&gt; = &#123; value: T &#125;;type BoxedArray&lt;T&gt; = &#123; array: T[] &#125;;type Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;type T20 = Boxed&lt;string&gt;; // BoxedValue&lt;string&gt;;type T21 = Boxed&lt;number[]&gt;; // BoxedArray&lt;number&gt;;type T22 = Boxed&lt;string | number[]&gt;; // BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;</code></pre><h4 id="11-23-1-有条件类型的分布式的属性可以方便地用来过滤联合类型："><a href="#11-23-1-有条件类型的分布式的属性可以方便地用来过滤联合类型：" class="headerlink" title="11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型："></a>11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：</h4><pre><code class="typescript">type Diff&lt;T, U&gt; = T extends U ? never : T; // Remove types from T that are assignable to U(从 T 中删除可分配给 U 的类型)type Filter&lt;T, U&gt; = T extends U ? T : never; // Remove types from T that are not assignable to U(从 T 中删除不可赋值给 U 的类型)type T30 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;; // &quot;b&quot; | &quot;d&quot;type T31 = Filter&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;; // &quot;a&quot; | &quot;c&quot;type T32 = Diff&lt;string | number | (() =&gt; void), Function&gt;; // string | numbertype T33 = Filter&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; voidtype _NonNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;; // Remove null and undefined from Ttype T34 = _NonNullable&lt;string | number | undefined&gt;; // string | numbertype T35 = _NonNullable&lt;string | string[] | null | undefined&gt;; // string | string[]function f1&lt;T&gt;(x: T, y: _NonNullable&lt;T&gt;) &#123;  x = y; // Ok  // y = x ;// Error&#125;function f2&lt;T extends string | undefined&gt;(x: T, y: _NonNullable&lt;T&gt;) &#123;  x = y; // Ok  // y = x; //Error  // let s1: string = x; // Error  let s2: string = y; // Ok&#125;</code></pre><h4 id="11-23-2-有条件类型与映射类型结合时特别有用"><a href="#11-23-2-有条件类型与映射类型结合时特别有用" class="headerlink" title="11.23.2 有条件类型与映射类型结合时特别有用"></a>11.23.2 有条件类型与映射类型结合时特别有用</h4><pre><code class="typescript">type FunctionPropertyNames&lt;T&gt; = &#123; [K in keyof T]: T[K] extends Function ? K : never &#125;[keyof T];type FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;type NonFunctionPropertyNames&lt;T&gt; = &#123; [K in keyof T]: T[K] extends Function ? never : K &#125;[keyof T];type NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;interface Part &#123;  id: number;  name: string;  subparts: Part[];  updatePart(newName: string): void;&#125;type T40 = FunctionPropertyNames&lt;Part&gt;; // &quot;updatePart&quot;type T41 = NonFunctionPropertyNames&lt;Part&gt;; // &quot;id&quot; | &quot;name&quot; | &quot;subparts&quot;type T42 = FunctionProperties&lt;Part&gt;; // &#123; updatePart(newName: string): void &#125;type T43 = NonFunctionProperties&lt;Part&gt;; // &#123; id: number, name: string, suparts: Part[] &#125;</code></pre><h4 id="11-23-3-与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。"><a href="#11-23-3-与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。" class="headerlink" title="11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。"></a>11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。</h4><ul><li>比如下面的错误：</li></ul><pre><code class="typescript">// type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt;: T; // Error</code></pre><h3 id="11-24-有条件类型中的类型推断"><a href="#11-24-有条件类型中的类型推断" class="headerlink" title="11.24 有条件类型中的类型推断"></a>11.24 有条件类型中的类型推断</h3><blockquote><p>现在有条件类型的 <code>extends</code> 子语句中，允许出现 <code>infer</code> 声明，它会引入一个待推断的类型变量。这个推断的类型变量可以在有条件类型的 <code>true</code> 分支中被引用。允许出现多个同类型变量的 <code>infer</code>。</p></blockquote><blockquote><p>例如：下面代码会提取函数类型的返回值</p></blockquote><pre><code class="typescript">type _ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</code></pre><blockquote><p>有条件类型 可以嵌套来构成一系列的匹配模式，按顺序进行求值：</p></blockquote><pre><code class="typescript">type Unpacked&lt;T&gt; = T extends (infer U)[] ? U : T extends (...args: any[]) =&gt; infer U ? U : T extends Promise&lt;infer U&gt; ? U : T;type T0 = Unpacked&lt;string&gt;; // stringtype T1 = Unpacked&lt;string[]&gt;; // stringtype T2 = Unpacked&lt;() =&gt; string&gt;; // stringtype T3 = Unpacked&lt;Promise&lt;string&gt;&gt;; // stringtype T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;; // Promise&lt;string&gt;type T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; // string</code></pre><blockquote><p>下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：</p></blockquote><pre><code class="typescript">type Foo&lt;T&gt; = T extends &#123; a: infer U; b: infer U &#125; ? U : never;type T10 = Foo&lt;&#123; a: string; b: string &#125;&gt;; // stringtype T11 = Foo&lt;&#123; a: string; b: number &#125;&gt;; // string | number</code></pre><blockquote><p>相似地，在抗变位置上同一个类型变量的多个候选类型会被推断为交叉类型：</p><pre><code class="typescript">type Bar&lt;T&gt; = T extends &#123; a: (x: infer U) =&gt; void; b: (x: infer U) =&gt; void &#125; ? U : never;type T20 = Bar&lt;&#123; a: (x: string) =&gt; void; b: (x: string) =&gt; void &#125;&gt;; // stringtype T21 = Bar&lt;&#123; a: (x: string) =&gt; void; b: (x: number) =&gt; void &#125;&gt;; // string &amp; number</code></pre></blockquote><pre><code>&gt; 当推断具有多个调用签名(例如函数重载类型)的类型时，用最后的签名(大概是最自由的包含所有情况的签名) 进行推断。无法根据参数类型列表来进行解析重载。```typescriptdeclare function foo(x: string): number;declare function foo(x: number): string;declare function foo(x: string | number): string | number;type T30 = ReturnType&lt;typeof foo&gt;; // string | number</code></pre><blockquote><p>无法在正常类型参数的约束子语句中使用 <code>infer</code> 声明：</p></blockquote><pre><code class="typescript">// type ReturnType1&lt;T extends (...args: any[]) =&gt; infer R&gt; = R; // Error</code></pre><blockquote><p>但是，可以这样达到同样的效果，在约束里删掉类型变量，用 有条件类型 来替换：</p></blockquote><pre><code class="typescript">type AnyFunction = (...args: any[]) =&gt; any;type ReturnType2&lt;T extends AnyFunction&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</code></pre><blockquote><p>实际上，就是 <code>ReturnType</code></p></blockquote><pre><code class="typescript">type __ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : never;</code></pre><h3 id="11-25-预定义的有条件类型"><a href="#11-25-预定义的有条件类型" class="headerlink" title="11.25 预定义的有条件类型"></a>11.25 预定义的有条件类型</h3><blockquote><p><code>TypeScript 2.8</code> 在 <code>lib.d.ts</code> 里增加了一些预定义的有条件类型</p></blockquote><blockquote><ol><li><code>Exclude&lt;T, U&gt;</code> -- 从 <code>T</code> 中剔除可以赋值给 <code>U</code> 的类型</li><li><code>Extract&lt;T, U&gt;</code> -- 提取 <code>T</code> 中可以赋值给 <code>U</code> 的类型</li><li><code>NonNullable&lt;T&gt;</code> -- 从 <code>T</code> 中剔除 <code>null</code> 和 <code>undefined</code></li><li><code>ReturnType&lt;T&gt;</code> -- 获取函数返回值类型</li><li><code>InstanceType&lt;T&gt;</code> -- 获取构造函数类型的实例类型</li></ol></blockquote><ul><li><code>Example</code>:</li></ul><pre><code class="typescript">type T00 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;; // &quot;b&quot; | &quot;d&quot;type T01 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;, &quot;a&quot; | &quot;c&quot; | &quot;f&quot;&gt;; // &quot;a&quot; | &quot;c&quot;type T02 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // &quot;string&quot; | &quot;number&quot;type T03 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; voidtype T04 = NonNullable&lt;string | number | undefined&gt;; // string | numbertype T05 = NonNullable&lt;(() =&gt; string) | string[] | null | undefined&gt;; // (() =&gt; string) | string[]function f1(s: string) &#123;  return &#123; a: 1, b: s &#125;;&#125;class C &#123;  x = 0;  y = 0;&#125;type T10 = ReturnType&lt;() =&gt; string&gt;; // stringtype T11 = ReturnType&lt;(s: string) =&gt; void&gt;; // voidtype T12 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // &#123;&#125;type T13 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // number[]type T14 = ReturnType&lt;typeof f1&gt;; // &#123; a: number, b: string &#125;type T15 = ReturnType&lt;any&gt;; // anytype T16 = ReturnType&lt;never&gt;; // never// type T17 = ReturnType&lt;string&gt;; // Error// type T18 = ReturnType&lt;Function&gt;; // Errortype T20 = InstanceType&lt;typeof C&gt;; // Ctype T21 = InstanceType&lt;any&gt;; // anytype T22 = InstanceType&lt;never&gt;; // never// type T23 = InstanceType&lt;string&gt;; // Error// type T24 = InstanceType&lt;Function&gt;; // Error</code></pre><blockquote><p>注意：<code>Exclude</code> 类型是建议的 <code>Diff</code> 类型的一种实现，我们使用 <code>Exclude</code> 这个名字是为了避免破坏已经定义了的 <code>Diff</code> 的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加 <code>Omit&lt;T, K&gt;</code> 类型，因为它可以很容易的用 <code>Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code> 来表示</p></blockquote><h2 id="十二、实用工具类型"><a href="#十二、实用工具类型" class="headerlink" title="十二、实用工具类型"></a>十二、实用工具类型</h2><blockquote><p><code>TypeScript</code> 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。</p></blockquote><h3 id="12-1-Partial-局部的"><a href="#12-1-Partial-局部的" class="headerlink" title="12.1 Partial 局部的"></a>12.1 Partial 局部的</h3><blockquote><p>构造类型 <code>T</code>, 并将它所有的属性设置成可选的，它的返回类型表示输入类型的所有子类型。</p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">interface PartialTodo &#123;  title: string;  description: string;&#125;function updateTodo(todo: PartialTodo, fieldsToUpdate: Partial&lt;PartialTodo&gt;) &#123;  return &#123; ...todo, ...fieldsToUpdate &#125;;&#125;const partialTodo1 = &#123;  title: &quot;organize desk&quot;,  description: &quot;clear clutter&quot;&#125;;const partialTodo2 = updateTodo(partialTodo1, &#123;  description: &quot;throw out trash&quot;&#125;);</code></pre><h3 id="12-2-Readonly-只读的"><a href="#12-2-Readonly-只读的" class="headerlink" title="12.2 Readonly 只读的"></a>12.2 Readonly 只读的</h3><blockquote><p>构造类型 T<strong>，并将它所有的属性设置为</strong> readonly<strong>，也就是说构造出的类型的属性不能被再次赋值</strong></p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">interface ReadonlyTodo &#123;  title: string;&#125;const readonlyTodo: Readonly&lt;ReadonlyTodo&gt; = &#123;  title: &quot;Delete inactive users&quot;&#125;;readonlyTodo.title = &quot;Hello&quot;; // Error: cannot reassign a readonly property// Object.freezefunction freeze&lt;T&gt;(obj: T): Readonly&lt;T&gt;;</code></pre><h3 id="12-3-Record-lt-T-K-gt-记录"><a href="#12-3-Record-lt-T-K-gt-记录" class="headerlink" title="12.3 Record&lt;T, K&gt; 记录"></a>12.3 Record&lt;T, K&gt; 记录</h3><blockquote><p>构造一个类型，其属性名的类型为 <code>K</code>，属性值的类型为 <code>T</code>。这个工具可用来将某个类型的属性映射到另一个类型上。</p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">interface PageInfo &#123;  title: string;&#125;type Page = &quot;home&quot; | &quot;about&quot; | &quot;contact&quot;;const x: Record&lt;Page, PageInfo&gt; = &#123;  about: &#123; title: &quot;about&quot; &#125;,  contact: &#123; title: &quot;concat&quot; &#125;,  home: &#123; title: &quot;home&quot; &#125;&#125;;</code></pre><h3 id="12-4-Pick-lt-T-K-gt-挑选"><a href="#12-4-Pick-lt-T-K-gt-挑选" class="headerlink" title="12.4 Pick&lt;T, K&gt; 挑选"></a>12.4 Pick&lt;T, K&gt; 挑选</h3><blockquote><p>从类型 <code>T</code> 中挑选部分属性 <code>K</code> 来构造类型</p></blockquote><pre><code class="typescript">interface PickTodo &#123;  title: string;  description: string;  completed: boolean;&#125;type TodoPreview = Pick&lt;PickTodo, &quot;title&quot; | &quot;completed&quot;&gt;;const pickTodo: TodoPreview = &#123;  title: &quot;Clean room&quot;,  completed: false&#125;;</code></pre><h3 id="12-5-Exclude-lt-T-U-gt-剔除"><a href="#12-5-Exclude-lt-T-U-gt-剔除" class="headerlink" title="12.5 Exclude&lt;T, U&gt; 剔除"></a>12.5 Exclude&lt;T, U&gt; 剔除</h3><blockquote><p>从类型 <code>T</code> 中剔除所有可以赋值给 <code>U</code> 的属性，然后构造一个类型。</p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">type T0 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &quot;b&quot; | &quot;c&quot;type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &quot;c&quot;type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number</code></pre><h3 id="12-6-Extract-lt-T-U-gt-提取"><a href="#12-6-Extract-lt-T-U-gt-提取" class="headerlink" title="12.6 Extract&lt;T, U&gt; 提取"></a>12.6 Extract&lt;T, U&gt; 提取</h3><blockquote><p>从类型 <code>T</code> 中提取所有可以赋值给 <code>U</code> 的类型，然后构造一个类型。</p></blockquote><pre><code class="typescript">type T01 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;f&quot;&gt;; // &quot;a&quot;type T02 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt; void</code></pre><h3 id="12-7-NonNullable"><a href="#12-7-NonNullable" class="headerlink" title="12.7 NonNullable"></a>12.7 NonNullable</h3><blockquote><p>从类型 <code>T</code> 中剔除 <code>null</code> 和 <code>undefined</code>，然后构造一个类型</p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">type T10 = NonNullable&lt;string | number | undefined&gt;; // string | numbertype T11 = NonNullable&lt;string[] | null | undefined&gt;; // string[]</code></pre><h3 id="12-8-ReturnType-返回值类型"><a href="#12-8-ReturnType-返回值类型" class="headerlink" title="12.8 ReturnType 返回值类型"></a>12.8 ReturnType 返回值类型</h3><blockquote><p>由函数类型 <code>T</code> 的返回值类型构造一个类型</p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">function f1(s: string) &#123;  return &#123; a: 1, b: s &#125;;&#125;type _T0 = ReturnType&lt;() =&gt; string&gt;; // stringtype _T1 = ReturnType&lt;(s: string) =&gt; void&gt;; // voidtype _T2 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // &#123;&#125;type _T3 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // number[]type _T4 = ReturnType&lt;typeof f1&gt;; // &#123; a: number, b: string &#125;type _T5 = ReturnType&lt;any&gt;; // anytype _T6 = ReturnType&lt;never&gt;; // nevertype _T7 = ReturnType&lt;string&gt;; // Errortype _T8 = ReturnType&lt;Function&gt;; // Error</code></pre><h3 id="12-9-InstanceType-构造函数-实例类型"><a href="#12-9-InstanceType-构造函数-实例类型" class="headerlink" title="12.9 InstanceType 构造函数 实例类型"></a>12.9 InstanceType 构造函数 实例类型</h3><blockquote><p>由构造函数类型 <code>T</code> 的实例类型构造一个类型。</p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">class C &#123;  x = 0;  y = 0;&#125;type _T01 = InstanceType&lt;typeof C&gt;; // Ctype _T02 = InstanceType&lt;any&gt;; // anytype _T03 = InstanceType&lt;never&gt;; // nevertype _T04 = InstanceType&lt;string&gt;; // Errortype _T05 = InstanceType&lt;Function&gt;; // Error</code></pre><h3 id="12-10-Required"><a href="#12-10-Required" class="headerlink" title="12.10 Required"></a>12.10 Required</h3><blockquote><p>构造一个类型，使类型 <code>T</code> 的所有属性为 <code>required</code></p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">interface Props &#123;  a?: number;  b?: string;&#125;const obj: Props = &#123; a: 5 &#125;; // Okconst obj2: Required&lt;Props&gt; = &#123; a: 5 &#125;; // Error, property &#39;b&#39; missing</code></pre><h3 id="12-11-ThisType-this"><a href="#12-11-ThisType-this" class="headerlink" title="12.11 ThisType this"></a>12.11 ThisType this</h3><blockquote><p>这个工具不会返回一个转换后的类型。它作为上下文的 <code>this</code> 类型的一个标记。<br>注意：若想要使用此类型，必须启用 <code>--noImplicitThis</code></p></blockquote><ul><li>例子：</li></ul><pre><code class="typescript">// Compile with --noImplicitThistype ObjectDescriptor&lt;D, M&gt; = &#123;  data?: D;  methods?: M &amp; ThisType&lt;D &amp; M&gt;; // Type of &#39;this&#39; in methods is D &amp; M&#125;;function makeObject&lt;D, M&gt;(desc: ObjectDescriptor&lt;D, M&gt;): D &amp; M &#123;  let data: object = desc.data || &#123;&#125;;  let methods: object = desc.methods || &#123;&#125;;  return &#123; ...data, ...methods &#125; as D &amp; M;&#125;let _obj = makeObject(&#123;  data: &#123; x: 0, y: 0 &#125;,  methods: &#123;    moveBy(dx: number, dy: number) &#123;      this.x += dx; // Strongly typed this      this.y += dy; // Strongly typed this    &#125;  &#125;&#125;);_obj.x = 10;_obj.y = 10;_obj.moveBy(5, 5);</code></pre><blockquote><p>上面例子中，<code>makeObject</code> 参数里的 <code>methods</code> 对象具有一个上下文类型 <code>ThisType&lt;D &amp; M&gt;</code>，因此 <code>methods</code> 对象的方法里 this 的类型为 <code>&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;</code>。<br>在 <code>lib.d.ts</code> 里，<code>ThisType&lt;T&gt;</code> 标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。</p></blockquote><h2 id="十三、Symbols"><a href="#十三、Symbols" class="headerlink" title="十三、Symbols"></a>十三、Symbols</h2><blockquote><p>介绍：自 <code>ECMAScript 2015</code> 起，<code>symbol</code> 成为了一种新的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。</p></blockquote><h3 id="13-1-symbol-类型的值是通过-Symbol-构造函数创建的。"><a href="#13-1-symbol-类型的值是通过-Symbol-构造函数创建的。" class="headerlink" title="13.1 symbol 类型的值是通过 Symbol 构造函数创建的。"></a>13.1 <code>symbol</code> 类型的值是通过 <code>Symbol</code> 构造函数创建的。</h3><pre><code class="typescript">let sym1 = Symbol();let sym2 = Symbol(&quot;key&quot;); // 可选的字符串 key</code></pre><h3 id="13-2-Symbols-是不可改变且唯一的"><a href="#13-2-Symbols-是不可改变且唯一的" class="headerlink" title="13.2 Symbols 是不可改变且唯一的"></a>13.2 <code>Symbols</code> 是不可改变且唯一的</h3><pre><code class="typescript">let sym3 = Symbol(&quot;key&quot;);let sym4 = Symbol(&quot;key&quot;);sym3 === sym4; // false symbols 是唯一的</code></pre><h3 id="13-3-像字符串一样，symbols-也可以被用作对象属性的键。"><a href="#13-3-像字符串一样，symbols-也可以被用作对象属性的键。" class="headerlink" title="13.3 像字符串一样，symbols 也可以被用作对象属性的键。"></a>13.3 像字符串一样，<code>symbols</code> 也可以被用作对象属性的键。</h3><pre><code class="typescript">const sym = Symbol();let obj = &#123;  [sym]: &quot;value&quot;&#125;;console.log(obj[sym]); // &quot;value&quot;</code></pre><h3 id="13-4-Symbols-也可以与计算出的属性名相结合来声明对象的属性和类成员。"><a href="#13-4-Symbols-也可以与计算出的属性名相结合来声明对象的属性和类成员。" class="headerlink" title="13.4 Symbols 也可以与计算出的属性名相结合来声明对象的属性和类成员。"></a>13.4 <code>Symbols</code> 也可以与计算出的属性名相结合来声明对象的属性和类成员。</h3><pre><code class="typescript">const getClassNameSymbol = Symbol();class C &#123;  [getClassNameSymbol]() &#123;    return &quot;C&quot;;  &#125;&#125;let c = new C();let className = c[getClassNameSymbol](); // &quot;C&quot;</code></pre><h3 id="13-5-众所周知的-Symbols"><a href="#13-5-众所周知的-Symbols" class="headerlink" title="13.5 众所周知的 Symbols"></a>13.5 众所周知的 <code>Symbols</code></h3><blockquote><p>除了用户定义的 <code>Symbols</code>，还有一些已经众所周知的内置 <code>symbols</code>。内置 <code>symbols</code> 用来表示语言内部的行为。<br>以下为这些 <code>symbols</code> 的列表：</p></blockquote><ul><li><code>Symbol.hasInstance</code></li></ul><blockquote><p>该方法会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p></blockquote><ul><li><code>Symbol.isConcatSpreadable</code></li></ul><blockquote><p>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p></blockquote><ul><li><code>Symbol.iterator</code></li></ul><blockquote><p>方法，被 <code>for-of</code> 语句调用，。返回对象的默认迭代器</p></blockquote><ul><li><code>Symbol.match</code></li></ul><blockquote><p>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串</p></blockquote><ul><li><code>Symbol.replace</code></li></ul><blockquote><p>方法，被 <code>String.prototype.replac</code>e 调用。正则表达式用来替换字符串中匹配的子串。</p></blockquote><ul><li><code>Symbol.search</code></li></ul><blockquote><p>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p></blockquote><ul><li><code>Symbol.species</code></li></ul><blockquote><p>函数值，为一个构造函数。用来创建派生对象。</p></blockquote><ul><li><code>Symbol.split</code></li></ul><blockquote><p>方法，被 <code>String.prototype.split</code> 调用。正则表达式用来分割字符串。</p></blockquote><ul><li><code>Symbol.toPrimitive</code></li></ul><blockquote><p>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p></blockquote><ul><li><code>Symbol.toStringTag</code></li></ul><blockquote><p>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p></blockquote><ul><li><code>Symbol.unscopables</code></li></ul><blockquote><p>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p></blockquote><h2 id="十四、迭代器和生成器"><a href="#十四、迭代器和生成器" class="headerlink" title="十四、迭代器和生成器"></a>十四、迭代器和生成器</h2><ul><li>可迭代性</li></ul><blockquote><p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p></blockquote><h3 id="14-1-for-of-语句"><a href="#14-1-for-of-语句" class="headerlink" title="14.1 for ... of 语句"></a>14.1 for ... of 语句</h3><blockquote><p><code>for ... of</code> 会遍历可迭代对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p></blockquote><ul><li>下面是在数组上使用 <code>for ... of</code> 的简单例子</li></ul><pre><code class="typescript">let someArray = [1, &quot;string&quot;, false];for (let entry of someArray) &#123;  console.log(entry); // 1, &quot;string&quot;, false&#125;</code></pre><h3 id="14-2-for-of-Vs-for-in-语句"><a href="#14-2-for-of-Vs-for-in-语句" class="headerlink" title="14.2 for ... of Vs for ... in 语句"></a>14.2 for ... of Vs for ... in 语句</h3><blockquote><p><code>for ... of</code> 和 <code>for ... in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for ... in</code> 迭代的是对象的 <code>键</code> 的列表，而 <code>for ... of</code> 则迭代对象的键对应的值。</p></blockquote><ul><li>下面的例子展示了两者之间的区别：</li></ul><pre><code class="typescript">let list = [4, 5, 6];for (let i in list) &#123;  console.log(i); // &quot;0&quot; &quot;1&quot; &quot;2&quot;&#125;for (let i of list) &#123;  console.log(i); // &quot;4&quot; &quot;5&quot; &quot;6&quot;&#125;</code></pre><blockquote><p>另一个区别是 <code>for ... in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。但是 <code>for ... of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p></blockquote><pre><code class="typescript">let pets = new Set([&quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;]);pets[&quot;species&quot;] = &quot;mammals&quot;;for (let pet in pets) &#123;  console.log(pet);&#125;for (let pet of pets) &#123;  console.log(pet); // &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;&#125;</code></pre><h3 id="14-3-代码生成目标为-ES5-和-ES3"><a href="#14-3-代码生成目标为-ES5-和-ES3" class="headerlink" title="14.3 代码生成目标为 ES5 和 ES3"></a>14.3 代码生成目标为 <code>ES5</code> 和 <code>ES3</code></h3><blockquote><p>当生成目标为 <code>ES5</code> 或 <code>ES3</code>，迭代器只允许在 <code>Array</code> 类型上使用。在非数组值上使用 <code>for ... of</code> 语句会得到一个错误，就算这些非数组值已经实现了 <code>Symbol.iterator</code> 属性。</p></blockquote><blockquote><p>编译器会生成一个简单的 <code>for</code> 循环做为 <code>for ... of</code> 循环，比如：</p></blockquote><pre><code class="typescript">let numbers = [1, 2, 3];for (let num of numbers) &#123;  console.log(num);&#125;// 生成的代码为：var number = [1, 2, 3];for (var _i = 0; _i &lt; numbers.length; _i++) &#123;  var num = numbers[_i];  console.log(num);&#125;</code></pre><h3 id="14-4-目标为-ECMAScript-2015-或更高"><a href="#14-4-目标为-ECMAScript-2015-或更高" class="headerlink" title="14.4 目标为 ECMAScript 2015 或更高"></a>14.4 目标为 <code>ECMAScript 2015</code> 或更高</h3><blockquote><p>当目标为兼容 <code>ECMAScript 2015</code> 的引擎时，编译器会生成相应引擎的 <code>for ... of</code> 内置迭代器实现方式。</p></blockquote><h2 id="十五、模块"><a href="#十五、模块" class="headerlink" title="十五、模块"></a>十五、模块</h2><h3 id="15-1-关于术语的一点说明"><a href="#15-1-关于术语的一点说明" class="headerlink" title="15.1 关于术语的一点说明"></a>15.1 关于术语的一点说明</h3><blockquote><p>请务必注意一点：<code>TypeScript 1.5</code> 里术语名已经发生了变化。&quot;<code>内部模块</code>&quot; 现在被称作 &quot;<code>命名空间</code>&quot;。&quot;<code>外部模块</code>&quot; 现在则简称为 &quot;<code>模块</code>&quot;。这是为了与 <code>ECMAScript 2015</code> 里的术语保持已一致， (也就是说 <code>module X</code> { 相当于现在推荐的写法 <code>namespace X</code> })</p></blockquote><h3 id="15-2-介绍"><a href="#15-2-介绍" class="headerlink" title="15.2 介绍"></a>15.2 介绍</h3><ol><li>从 <code>ECMAScript 2015</code> 开始，<code>JavaScript</code> 引入了模块的概念。<code>TypeScript</code> 也沿用这个概念。</li><li>模块在其自身的作用域里执行，而不是在全局作用域；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用 <code>export</code> 形式之一导出它们。相反，如果想使用其它模块导出的 <code>变量</code>，<code>函数</code>，<code>类</code>，<code>接口</code> 等的时候，你必须要导入它们，可以使用 <code>import</code> 形式之一。</li><li>模块是自声明的；两个模块之间的关系是通过在文件级别上使用 <code>import</code> 和 <code>exports</code> 建立的。</li><li>模块使用模块加载器去导入其它的模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。大家最熟知的 <code>JavaScript</code> 模块加载器是服务与 <code>Node.js</code> 的 <code>CommonJS</code> 和 服务于 <code>Web</code> 应用的 <code>Require.js</code>。</li><li><code>TypeScript</code> 和 <code>ECMAScript 2015</code> 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 <code>import</code> 或者 <code>export</code> 声明，那么它的内容将被视为全局可见的 (因此对模块也是可见的)。</li></ol><h3 id="15-3-导出"><a href="#15-3-导出" class="headerlink" title="15.3 导出"></a>15.3 导出</h3><h4 id="15-3-1-导出声明"><a href="#15-3-1-导出声明" class="headerlink" title="15.3.1. 导出声明"></a>15.3.1. 导出声明</h4><blockquote><p>任何声明( 比如 <code>变量</code>，<code>函数</code>，<code>类</code>，<code>类型别名</code> 或 <code>接口</code> )都能够通过添加 <code>export</code> 关键字来导出。</p></blockquote><pre><code class="typescript">export interface StringValidator &#123;  isAcceptable(s: string): boolean;&#125;export const numberRegexp = /^[0-9]+$/;export class ZipCodeValidator implements StringValidator &#123;  isAcceptable(s: string): boolean &#123;    return s.length === 5 &amp;&amp; numberRegexp.test(s);  &#125;&#125;</code></pre><h4 id="15-3-2-导出语句"><a href="#15-3-2-导出语句" class="headerlink" title="15.3.2 导出语句"></a>15.3.2 导出语句</h4><blockquote><p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p></blockquote><pre><code class="typescript">class ZipCodeValidator1 implements StringValidator &#123;  isAcceptable(s: string): boolean &#123;    return s.length === 5 &amp;&amp; numberRegexp.test(s);  &#125;&#125;export &#123; ZipCodeValidator1 &#125;;export &#123; ZipCodeValidator1 as mainValidator &#125;;</code></pre><h4 id="15-3-3-重新导出"><a href="#15-3-3-重新导出" class="headerlink" title="15.3.3 重新导出"></a>15.3.3 重新导出</h4><blockquote><p>我们经常会去扩展其它模块，并且只导出那个模块的那部分内容。</p></blockquote><blockquote><p>重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p></blockquote><pre><code class="typescript">export class ParseIntBasedZipCodeValidator &#123;  isAcceptable(s: string) &#123;    return s.length === 5 &amp;&amp; parseInt();  &#125;&#125;// 导出原先的验证器但做了重命名export &#123; ZipCodeValidator as RegExpBasedZipCodeValidator &#125; from &quot;./ZipCodeValidator&quot;;</code></pre><blockquote><p>或者一个模块可以包裹多个模块，并把它们导出的内容联合在一起，通过语法：<code>export * from &quot;module&quot;</code></p></blockquote><pre><code class="typescript">export * from &quot;./StringValidator&quot;;export * from &quot;./LetterOnlyValidator&quot;;export * from &quot;./ZipCodeValidator&quot;;</code></pre><h3 id="15-4-导入"><a href="#15-4-导入" class="headerlink" title="15.4 导入"></a>15.4 导入</h3><blockquote><p>模块的导入操作与导出一样简单，可以使用以下 <code>import</code> 形式之一来导入其它模块中的导出内容。</p></blockquote><h4 id="15-4-1-导入一个模块中的某个导出内容"><a href="#15-4-1-导入一个模块中的某个导出内容" class="headerlink" title="15.4.1 导入一个模块中的某个导出内容"></a>15.4.1 导入一个模块中的某个导出内容</h4><pre><code class="typescript">import &#123; ZipCodeValidator &#125; from &quot;./ZipCodeValidator&quot;;let myValidator = new ZipCodeValidator();</code></pre><blockquote><p>可以对导入内容重命名</p></blockquote><pre><code class="typescript">import &#123; ZipCodeValidator as ZCV &#125; from &quot;./ZipCodeValidator&quot;;let myValidator = new ZCV();</code></pre><h4 id="15-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分"><a href="#15-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分" class="headerlink" title="15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分"></a>15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分</h4><pre><code class="typescript">import * as validator from &quot;./ZipCodeValidator&quot;;let myValidator = new validator.ZipCodeValidator();</code></pre><h4 id="15-4-3-具有副作用的导入模块"><a href="#15-4-3-具有副作用的导入模块" class="headerlink" title="15.4.3 具有副作用的导入模块"></a>15.4.3 具有副作用的导入模块</h4><blockquote><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本</p></blockquote><blockquote><p>就不关注它的导出。使用下面的方法来导入这些模块。</p></blockquote><pre><code class="typescript">import &quot;./my-module.js&quot;;</code></pre><h3 id="15-5-默认导出"><a href="#15-5-默认导出" class="headerlink" title="15.5 默认导出"></a>15.5 默认导出</h3><blockquote><p>每个模块都可以有一个 <code>default</code> 导出。默认导出使用 <code>default</code> 关键字标记；并且一个模块只能够有一个 <code>default</code> 导出。需要使用 一种特殊的导入形式来导入 <code>default</code> 导出。</p></blockquote><blockquote><p><code>default</code> 导出十分便利。比如，像 <code>JQuery</code> 这样的类库可能有一个默认导出 <code>jQuery</code> 或 <code>$</code>，并且我们基本上也会使用同样的名字 <code>jQuery</code> 或 <code>$</code> 导出 <code>JQuery</code>。</p></blockquote><ul><li><code>JQuery.d.ts</code></li></ul><pre><code class="typescript">declare let $: JQuery;export default $;</code></pre><ul><li><code>App.ts</code></li></ul><pre><code class="typescript">import $ from &quot;JQuery&quot;;$(&quot;button.continue&quot;).html(&quot;Next step ...&quot;);</code></pre><blockquote><p>类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的。</p></blockquote><ul><li><code>ZipCodeValidator.ts</code></li></ul><pre><code class="typescript">export default class ZipCodeValidator &#123;  static numberRegExp = /^[0-9]+$/;  isAcceptable(s: string) &#123;    return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegExp.test(s);  &#125;&#125;</code></pre><ul><li><code>Test.ts</code></li></ul><pre><code class="typescript">import validator from &quot;./ZipCodeValidator&quot;;let myValidator = new validator();</code></pre><blockquote><p><code>或者</code></p></blockquote><ul><li><code>StaticZipCodeValidator.ts</code></li></ul><pre><code class="typescript">const numberRegExp = /^[0-9]+$/;export default function (s: string) &#123;  return s.length === 5 &amp;&amp; numberRegExp.test(s);&#125;</code></pre><ul><li><code>Test.ts</code></li></ul><pre><code class="typescript">import validate from &quot;./StaticZipCodeValidator&quot;;let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// use function validatestrings.forEach(s =&gt; &#123;  console.log(`&quot;$&#123;s&#125;&quot; $&#123;validate(s)&#125; ? &quot; matches&quot; : &quot; does not match&quot;`);&#125;);</code></pre><blockquote><p><code>default</code> 导出也可以是一个值</p></blockquote><ul><li><code>OneTwoThree.ts</code></li></ul><pre><code class="typescript">export default &quot;123&quot;;</code></pre><ul><li><code>Log.ts</code></li></ul><pre><code class="typescript">import num from &quot;./OneTwoThree&quot;;console.log(num); // 123</code></pre><blockquote><p><code>export =</code> 和 <code>import = require()</code></p></blockquote><ol><li><code>CommonJS</code> 和 <code>AMD</code> 的环境里都有一个 <code>exports</code> 变量，这个变量包含了一个模块的所有导出内容。</li><li><code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code> 都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 <code>export default</code> 语法了。虽然作用相似，但是 <code>export default</code> 语法并不能兼容 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code>。</li><li>为了支持 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code>，<code>TypeScript</code> 提供了 <code>export =</code> 语法。</li><li><code>export =</code> 语法定义一个模块的导出对象。这里的对象一词指的是类，接口，命名空间，函数或枚举。</li><li>若使用 <code>export =</code> 导出一个模块，则必须使用 <code>TypeScript</code> 的特定语法 <code>import module = require(&#39;module&#39;)</code> 来导入此模块。</li></ol><ul><li><code>ZipCodeValidator.ts</code></li></ul><pre><code class="typescript">let numberRegExp = /^[0-9]+$/;class ZipCodeValidator &#123;  isAcceptable(s: string) &#123;    return s.length === 5 &amp;&amp; numberRegExp.test(s);  &#125;&#125;export = ZipCodeValidator; // 重点</code></pre><ul><li><code>Test.ts</code></li></ul><pre><code class="typescript">import zip = require(&quot;./ZipCodeValidator&quot;); // 重点let strings = [&quot;Hello&quot;, &quot;98502&quot;, &quot;101&quot;];let validator = new zip();strings.forEach(s =&gt; &#123;  console.log(`&quot;$&#123;s&#125;&quot; - $&#123;validator.isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot;&#125;`);&#125;);</code></pre><h3 id="15-6-生成模块代码"><a href="#15-6-生成模块代码" class="headerlink" title="15.6 生成模块代码"></a>15.6 生成模块代码</h3><blockquote><p>根据编译时指定的模块目标参数，编译器会生成相应的供 <code>Node.js\(CommonJS\)，Require.js\(AMD\)</code>，<code>UMD</code>，<code>SystemJS</code> 或 <code>ECMAScript 2015 native module\(ES6\)</code> 模块加载系统使用的代码。</p></blockquote><blockquote><p>想要了解生成代码中 <code>define</code>，<code>require</code> 和 <code>register</code> 的意义，需要参考相应的模块加载器的文档。</p></blockquote><ul><li><code>SimpleModule.ts</code></li></ul><pre><code class="typescript">import m = require(&quot;mod&quot;);export let t = m.something + 1;</code></pre><ul><li><code>AMD / RequireJS SimpleModule.js</code></li></ul><pre><code class="typescript">define([&quot;require&quot;, &quot;exports&quot;, &quot;./mod&quot;], function (require, exports, mod_1) &#123;  exports.t = mod_1.something + 1;&#125;);</code></pre><ul><li><code>CommonJS / Node SimpleModule.js</code></li></ul><pre><code class="typescript">import mod_1 = require(&quot;./mod&quot;);exports.t = mod_1.something + 1;</code></pre><ul><li><code>UMD SimpleModule.js</code></li></ul><pre><code class="typescript">(function (factory) &#123;  if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) &#123;    let v = factory(require, exports);    if (v !== undefined) module.exports = v;  &#125; else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;    define([&quot;require&quot;, &quot;exports&quot;, &quot;./mod&quot;], factory);  &#125;&#125;)(function (require, exports) &#123;  let mod_1 = require(&quot;./mod&quot;);  exports.t = mod_1.something + 1;&#125;);</code></pre><ul><li><code>System SimpleModule.js</code></li></ul><pre><code class="typescript">System.register([&quot;./mod&quot;], function (exports_1) &#123;  let mod_1;  let t;  return &#123;    setters: [      function (mod_1_1) &#123;        mod_1 = mod_1_1;      &#125;    ],    execute: function () &#123;      exports_1(&quot;t&quot;, (t = mod_1.something + 1));    &#125;  &#125;;&#125;);</code></pre><ul><li><code>Native ECMAScript 2015 modules SimpleModule.js</code></li></ul><pre><code class="typescript">import &#123; something &#125; from &quot;./mod&quot;;export let t = something + 1;</code></pre><h3 id="15-7-简单示例"><a href="#15-7-简单示例" class="headerlink" title="15.7 简单示例"></a>15.7 简单示例</h3><blockquote><p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p></blockquote><blockquote><p>为了编译，我们必须要在命令行上指定一个模块目标。对于 <code>Node.js</code> 来说，使用 <code>--module commonjs</code>；对于 <code>Require.js</code> 来说，使用 <code>--module amd</code>。</p></blockquote><ul><li>比如：</li></ul><pre><code class="typescript">tsc --module commonjs Test.ts</code></pre><blockquote><p>编译完成后，每个模块会生成一个单独的 <code>.js</code> 文件。好比使用了 <code>reference</code> 标签，编译器会根据 <code>import</code> 语句编译相应的文件。</p></blockquote><ul><li><code>Validation.ts</code></li></ul><pre><code class="typescript">export interface StringValidator &#123;  isAcceptable(s: string): boolean;&#125;</code></pre><ul><li><code>LetterOnlyValidator.ts</code></li></ul><pre><code class="typescript">import &#123; StringValidator &#125; from &quot;./Validation&quot;;const lettersRegExp = /^[A-Za-z]+$/;export class LetterOnlyValidator implements StringValidator &#123;  isAcceptable(s: string): boolean &#123;    return lettersRegExp.test(s);  &#125;&#125;</code></pre><ul><li><code>ZipCodeValidator.ts</code></li></ul><pre><code class="typescript">import &#123; StringValidator &#125; from &quot;./Validation&quot;;const numberRegExp = /^[0-9]+$/;export class ZipCodeValidator implements StringValidator &#123;  isAcceptable(s: string): boolean &#123;    return s.length === 5 &amp;&amp; numberRegExp.test(s);  &#125;&#125;</code></pre><ul><li><code>Test.ts</code></li></ul><pre><code class="typescript">import &#123; StringValidator &#125; from &quot;./Validation&quot;;import &#123; ZipCodeValidator &#125; from &quot;./ZipCodeValidator&quot;;import &#123; LetterOnlyValidator &#125; from &quot;./LetterOnlyValidator&quot;;// Some samples to trylet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// Validators to uselet validators: &#123; [s: string]: StringValidator &#125; = &#123;&#125;;validators[&quot;ZIP code&quot;] = new ZipCodeValidator();validators[&quot;Letters only&quot;] = new LetterOnlyValidator();// Show whether each string passed each validatorstrings.forEach(s =&gt; &#123;  for (let name in validators) &#123;    console.log(`&quot;$&#123;s&#125;&quot; - $&#123;validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot;&#125; $&#123;name&#125;`);  &#125;&#125;);</code></pre><h3 id="15-8-可选的模块加载和其它高级加载场景"><a href="#15-8-可选的模块加载和其它高级加载场景" class="headerlink" title="15.8 可选的模块加载和其它高级加载场景"></a>15.8 可选的模块加载和其它高级加载场景</h3><ol><li>有时候，你只想在某种条件下才加载某个模块。在 <code>TypeScript</code> 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且保证类型完全。</li><li>编译器会检测是否每个模块都会在生成的 <code>JavaScript</code> 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 <code>require</code> 这个模块的代码。省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</li><li>这种模式的核心是 <code>import id = require(&quot;...&quot;)</code> 语句可以让我们访问模块导出的类型。模块加载器会被动态调用(通过 <code>require</code>)，就像下面的 <code>if</code> 代码块里那样。它利用了省略引用的优化，所以模块只在被需要时加载。为了让这个模块工作，一定要注意 <code>import</code> 定义的标识符只能在表示类型处使用(不能在会转换成 <code>JavaScript</code> 的地方。)</li><li>为了确保类型安全性，我们可以使用 <code>typeof</code> 关键字。<code>typeof</code> 关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</li></ol><ul><li><code>示例 1</code>. <code>Node.js</code> 里的动态模块加载</li></ul><pre><code class="typescript">declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from &quot;./ZipCodeValidator&quot;;if (needZipValidator) &#123;  let ZipCodeValidator: typeof Zip = require(&quot;./ZipCodeValidator&quot;);  let validator = new ZipCodeValidator();  if (validator.isAcceptable(&quot;...&quot;)) &#123;    /!* ... *!/;  &#125;&#125;</code></pre><ul><li><code>示例 2</code>. <code>require.js</code> 里的动态模块加载</li></ul><pre><code class="typescript">declare function require(moduleNames: string[], onLoad: (...args: any[]) =&gt; void): void;import * as Zip from &quot;./ZipCodeValidator&quot;;if (needZipValidator) &#123;  require([&quot;./ZipCodeValidator&quot;], (ZipCodeValidator: typeof Zip) =&gt; &#123;    let validator = new ZipCodeValidator.ZipCodeValidator();    if (validator.isAcceptable(&quot;...&quot;)) &#123;      /!* ... *!/;    &#125;  &#125;);&#125;</code></pre><ul><li><code>示例 3</code>. <code>System.js</code> 里的动态模块加载</li></ul><pre><code class="typescript">declare const System: any;import &#123; ZipCodeValidator as Zip &#125; from &quot;./ZipCodeValidator&quot;;if (needZipValidator) &#123;  System.import(&quot;./ZipCodeValidator&quot;).then((ZipCodeValidator: typeof Zip) =&gt; &#123;    var x = new ZipCodeValidator();    if (x.isAcceptable(&quot;...&quot;)) &#123;      /!*...*!/;    &#125;  &#125;);&#125;</code></pre><h3 id="15-9-使用其它的-JavaScript-库"><a href="#15-9-使用其它的-JavaScript-库" class="headerlink" title="15.9 使用其它的 JavaScript 库"></a>15.9 使用其它的 JavaScript 库</h3><blockquote><p>要想描述非 <code>TypeScript</code> 编写的类库的类型，我们需要声明类库所暴露的 <code>API</code>。</p></blockquote><blockquote><p>我们叫它声明因为它不是&#39;外部程序&#39;的具体实现，它们通常是在 <code>.d.ts</code> 文件里定义的。类似于 <code>C/C++</code> 里的 <code>.h</code> 文件。</p></blockquote><h4 id="15-9-1-外部模块"><a href="#15-9-1-外部模块" class="headerlink" title="15.9.1 外部模块"></a>15.9.1 外部模块</h4><blockquote><p>在 <code>Node.js</code> 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的 <code>export</code> 声明来为每个模块都定义一个 <code>.d.ts</code> 文件，但最好还是写在一个大的 <code>.d.ts</code> 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code> 关键字并且把名字用引号括起来，方便之后 <code>import</code>。</p></blockquote><ul><li><code>例如：</code></li><li><code>node.d.ts(simplified except)</code></li></ul><pre><code class="typescript">declare module &quot;url&quot; &#123;  export interface Url &#123;    protocol?: string;    hostname?: string;    pathname?: string;  &#125;  export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;&#125;declare module &quot;path&quot; &#123;  export function normalize(p: string): string;  export function join(...paths: any[]): string;  export let sep: string;&#125;</code></pre><blockquote><p>现在我们可以 <code>/// &lt;reference&gt; node.d.ts</code> 并且使用 <code>import url = require(&#39;url&#39;)</code>；或 <code>import * as URl from &quot;url&quot;</code> 加载模块。`</p></blockquote><pre><code class="typescript">/// &lt;reference path=&quot;node.d.ts&quot;&gt;import * as URL from &quot;url&quot;;let myUrl = URL.parse(&quot;http://www.typescriptlang.org&quot;);</code></pre><h4 id="15-9-2-外部模块简写"><a href="#15-9-2-外部模块简写" class="headerlink" title="15.9.2 外部模块简写"></a>15.9.2 外部模块简写</h4><blockquote><p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p></blockquote><blockquote><p><code>declarations.d.ts</code></p></blockquote><pre><code class="typescript">declare module &quot;hot-new-module&quot;;</code></pre><ul><li>简写模块里所有导出类型将是 <code>any</code></li></ul><pre><code class="typescript">import x, &#123; y &#125; from &quot;hot-new-module&quot;;x(y);</code></pre><h4 id="15-9-3-模块声明通配符"><a href="#15-9-3-模块声明通配符" class="headerlink" title="15.9.3 模块声明通配符"></a>15.9.3 模块声明通配符</h4><blockquote><p>某些模块加载器如 <code>SystemJS</code> 和 <code>AMD</code> 支持导入非 <code>JavaScript</code> 内容。它们通常会使用一个前缀或后缀来表示特殊的加载语法，模块声明通配符可以用来表示这些情况。</p></blockquote><pre><code class="typescript">declare module &quot;*!text&quot; &#123;  const content: string;  export default content;&#125;</code></pre><ul><li><code>some do it the other way around</code></li></ul><pre><code class="typescript">declare module &quot;json!*&quot; &#123;  const value: any;  export default value;&#125;</code></pre><ul><li>现在你可以就导入匹配 <code>&quot;!text&quot;</code> 或 <code>&quot;json!&quot;</code> 的内容了。</li></ul><pre><code class="typescript">import fileContent from &quot;./xyz.txt!txt&quot;;import data from &quot;json!http://example.com/data.json&quot;;console.log(data, fileContent);</code></pre><h4 id="15-9-4-UMD-模块"><a href="#15-9-4-UMD-模块" class="headerlink" title="15.9.4 UMD 模块"></a>15.9.4 <code>UMD</code> 模块</h4><blockquote><p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器(全局变量)。它们以 <code>UMD</code> 模块为代表。这些库可以通过导入的形式或全局变量的形式访问。</p></blockquote><ul><li><code>例如：</code></li><li><code>math-lib.d.ts</code></li></ul><pre><code class="typescript">export function isPrime(x: number): boolean;export as namespace mathLib;</code></pre><ul><li>之后，这个库可以在某个模块里通过导入来使用:</li></ul><pre><code class="typescript">import &#123; isPrime &#125; from &quot;math-lib&quot;;isPrime(2);mathLib.isPrime(2);</code></pre><ul><li>它同样可以通过全局变量的形式使用，但只能在某个脚本(指不带有模块导入或导出的脚本文件)里。</li></ul><pre><code class="typescript">mathLib.isPrime(2);</code></pre><h3 id="15-10-创建模块结构指导"><a href="#15-10-创建模块结构指导" class="headerlink" title="15.10 创建模块结构指导"></a>15.10 创建模块结构指导</h3><h4 id="15-10-1-尽可能地在顶层导出"><a href="#15-10-1-尽可能地在顶层导出" class="headerlink" title="15.10.1 尽可能地在顶层导出"></a>15.10.1 尽可能地在顶层导出</h4><ol><li>用户应该更容易地使用你模块导出的内容。嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</li><li>从你的模块中导出一个命名空间就是一个增加嵌套的例子。虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。这对用户来说是很不方便的并且通常是多余的。</li><li>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。除非它能方便地表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</li></ol><h4 id="15-10-2-如果仅导出单个-class-或-function，使用-export-default"><a href="#15-10-2-如果仅导出单个-class-或-function，使用-export-default" class="headerlink" title="15.10.2 如果仅导出单个 class 或 function，使用 export default"></a>15.10.2 如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></h4><blockquote><p>就像&quot; <code>在顶层导出</code> &quot;帮助减少用户使用的难度，一个默认的导出也能起到这个效果。如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。这会令模块的导入和使用变得些许简单，比如：</p></blockquote><ul><li><code>MyClass.ts</code></li></ul><pre><code class="typescript">export default class SomeType &#123;  constructor() &#123;    /!* ... *!/;  &#125;&#125;</code></pre><ul><li><code>MyFunc.ts</code></li></ul><pre><code class="typescript">export default function getThing() &#123;  return &quot;thing&quot;;&#125;</code></pre><ul><li><code>Consumer.ts</code></li></ul><pre><code class="typescript">import t from &quot;./MyClass&quot;;import f from &quot;./MyFunc&quot;;let x = new t();console.log(f());</code></pre><blockquote><p>对用户来说这是最理想的。他们可以随意命名导入模块的类型 (本例为 <code>t</code> ) 并且不需要多余的 ( <code>.</code> ) 来找到相关对象。</p></blockquote><h4 id="15-10-3-如果要导出多个对象，把它们放在顶层里导出"><a href="#15-10-3-如果要导出多个对象，把它们放在顶层里导出" class="headerlink" title="15.10.3 如果要导出多个对象，把它们放在顶层里导出"></a>15.10.3 如果要导出多个对象，把它们放在顶层里导出</h4><ul><li><code>MyThings.ts</code></li></ul><pre><code class="typescript">export class SomeType &#123;/!*...*!/&#125;export function someFunc() &#123;    /*...*/&#125;</code></pre><h4 id="15-10-4-相反地，当导入的时候-明确地列出导入的名字。"><a href="#15-10-4-相反地，当导入的时候-明确地列出导入的名字。" class="headerlink" title="15.10.4 (相反地，当导入的时候)明确地列出导入的名字。"></a>15.10.4 (相反地，当导入的时候)明确地列出导入的名字。</h4><ul><li><code>Consumer.ts</code></li></ul><pre><code class="typescript">import &#123; SomeType, someFunc &#125; from &quot;./MyThings&quot;;let x = new SomeType();let y = someFunc();</code></pre><h4 id="15-10-5-使用命名空间导入模式当你要导出大量内容的时候"><a href="#15-10-5-使用命名空间导入模式当你要导出大量内容的时候" class="headerlink" title="15.10.5 使用命名空间导入模式当你要导出大量内容的时候"></a>15.10.5 使用命名空间导入模式当你要导出大量内容的时候</h4><ul><li><code>MyLargeModule.ts</code></li></ul><pre><code class="typescript">export class Dog &#123;&#125;export class Cat &#123;&#125;export class Tree &#123;&#125;export class Flower &#123;&#125;</code></pre><ul><li><code>Consumer.ts</code></li></ul><pre><code class="typescript">import * as myLargeModule from &quot;./MyLargeModule.ts&quot;;let x = new myLargeModule.Dog();</code></pre><h4 id="15-10-6-使用重新导出进行扩展"><a href="#15-10-6-使用重新导出进行扩展" class="headerlink" title="15.10.6 使用重新导出进行扩展"></a>15.10.6 使用重新导出进行扩展</h4><blockquote><p>你可能经常需要扩展一个模块的功能。<code>JS</code> 里常用的一个模式是 <code>JQuery</code> 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间那样去合并。推荐的方案是 不要去改变原来的对象，而是导出一个新的实体来提供新的功能。</p></blockquote><blockquote><p>假设 <code>Calculator.ts</code> 模块里定义了一个简单的计算器实现。这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p></blockquote><ul><li><code>Calculator.ts</code></li></ul><pre><code class="typescript">export class Calculator &#123;  private current = 0;  private memory = 0;  private operator: string;  protected static processDigit(digit: string, currentValue: number) &#123;    if (digit &gt;= &quot;0&quot; &amp;&amp; digit &lt;= &quot;9&quot;) &#123;      return currentValue * 10 + (digit.charCodeAt(0) - &quot;0&quot;.charCodeAt(0));    &#125;  &#125;  protected static processOperator(operator: string) &#123;    if ([&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;].indexOf(operator) &gt;= 0) &#123;      return operator;    &#125;  &#125;  protected evaluateOperator(operator: string, left: number, right: number): number &#123;    switch (this.operator) &#123;      case &quot;+&quot;:        return left + right;      case &quot;-&quot;:        return left - right;      case &quot;*&quot;:        return left * right;      case &quot;/&quot;:        return left / right;    &#125;  &#125;  private evaluate() &#123;    if (this.operator) &#123;      this.memory = this.evaluateOperator(this.operator, this.memory, this.current);    &#125; else &#123;      this.memory = this.current;    &#125;    this.current = 0;  &#125;  public handleChar(char: string) &#123;    if (char === &quot;=&quot;) &#123;      this.evaluate();      return;    &#125; else &#123;      let value = Calculator.processDigit(char, this.current);      if (value !== undefined) &#123;        this.current = value;        return;      &#125; else &#123;        let value = Calculator.processOperator(char);        if (value !== undefined) &#123;          this.evaluate();          this.operator = value;          return;        &#125;      &#125;    &#125;    throw new Error(`Unsupported input: &#39;$&#123;char&#125;&#39;`);  &#125;  public getResult() &#123;    return this.memory;  &#125;&#125;export function test(c: Calculator, input: string) &#123;  for (let i = 0; i &lt; input.length; i++) &#123;    c.handleChar(input[i]);  &#125;  console.log(`result of &#39;$&#123;input&#125;&#39; is &#39;$&#123;c.getResult()&#125;&#39;`);&#125;</code></pre><ul><li>下面使用导出的 <code>test</code> 函数来测试计算器</li><li><code>TestCalculator.ts</code></li></ul><pre><code class="typescript">import &#123; Calculator, test &#125; from &quot;./Calculator&quot;;let c = new Calculator();test(c, &quot;1+2*33/11=&quot;); // prints 9</code></pre><ul><li>现在扩展它，添加支持输入其它进制(十进制以外)。</li><li><code>ProgrammerCalculator.ts</code></li></ul><pre><code class="typescript">import &#123; Calculator &#125; from &quot;./Calculator&quot;;class ProgrammerCalculator extends Calculator &#123;  static digits = [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;];  constructor(public base: number) &#123;    super();    const maxBase = ProgrammerCalculator.digits.length;    if (base &lt;= 0 || base &gt; maxBase) &#123;      throw new Error(`base has to be within 0 to $&#123;maxBase&#125; inclusive`);    &#125;  &#125;  protected processDigit(digit: string, currentValue: number) &#123;    if (ProgrammerCalculator.digits.indexOf(digit) &gt;= 0) &#123;      return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);    &#125;  &#125;&#125;export &#123; ProgrammerCalculator as Calculator &#125;;export &#123; test &#125; from &quot;./Calculator&quot;;</code></pre><blockquote><p>新的 <code>ProgrammerCalculator</code> 模块导出的 API 与原先的 <code>Calculator</code> 模块很相似，但却没有改变原模块里的对象。</p></blockquote><ul><li><code>TestProgrammerCalculator.ts</code></li></ul><pre><code class="typescript">import &#123; Calculator, test &#125; from &quot;./ProgrammerCalculator&quot;;let c = new Calculator(2);test(c, &quot;001+010=&quot;); // prints 3</code></pre><h4 id="15-10-7-模块里不要使用命名空间"><a href="#15-10-7-模块里不要使用命名空间" class="headerlink" title="15.10.7 模块里不要使用命名空间"></a>15.10.7 模块里不要使用命名空间</h4><blockquote><p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。记住这点，命名空间在使用模块时几乎没什么价值。</p></blockquote><blockquote><p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型分组是很便利的。例如，在 <code>C\#</code> 里，你会从 <code>System.Collections</code> 里找到所有集合的类型。通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。然而，模块本身已经存在于文件系统之中，这是必须的。我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。我们可以创建 <code>/collections/generic/</code> 文件夹，把相应模块放在这里。</p></blockquote><blockquote><p>命名空间对解决全局作用域里命名冲突来说是很重要的。比如，你有一个 <code>My.Application.Customer.AddFrom</code> 和 <code>My.Application.Order.AddForm</code> <code>--</code> 两个类型的名字相同，但命名空间不同。然而，这对于模块来说却不是一个问题。在一个模块里，没有理由两个对象拥有同一个名字。从模块的使用角度来说，使用者会挑出它们用来引用模块的名字，所以也没有理由发声重名的情况。</p></blockquote><h4 id="15-10-8-危险信号"><a href="#15-10-8-危险信号" class="headerlink" title="15.10.8 危险信号"></a>15.10.8 危险信号</h4><blockquote><p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间。</p></blockquote><ol><li>文件的顶层声明是 <code>export namespace Foo &#123;...&#125;</code> ( 删除 <code>Foo</code> 并把所有内容向上层移动一层)</li><li>文件只有一个 <code>export class</code> 或 <code>export function</code> (考虑使用 <code>export default</code>)</li><li>多个文件的顶层具有同样的 <code>export namespace Foo</code> {( 不要以为这些会合并到一个 <code>Foo</code> 中! )}</li></ol><h2 id="十六、命名空间"><a href="#十六、命名空间" class="headerlink" title="十六、命名空间"></a>十六、命名空间</h2><h3 id="16-1-介绍"><a href="#16-1-介绍" class="headerlink" title="16.1 介绍"></a>16.1 介绍</h3><blockquote><p>这篇文章描述了如何在 <code>TypeScript</code> 里使用命名空间(之前叫做&quot;内部模块&quot;)来组织你的代码。就像我们在术语说明里提到的那样，<code>&quot;内部模块&quot;</code> 现在叫做 <code>&quot;命名空间&quot;</code>。另外，任何使用 <code>module</code> 关键字来声明一个内部模块的地方都应该使用 <code>namespace</code> 关键字来替换。这就避免了让新的使用者被相似的名称所迷惑。</p></blockquote><ul><li><code>第一步</code></li></ul><blockquote><p>我们先来写一段程序并将在整篇文章中都使用这个例子。我们定义几个简单的字符串验证器，</p></blockquote><blockquote><p>假设你会使用它们来验证表单里的用户输入或验证外部数据。</p></blockquote><ul><li><code>所有验证器都放在一个文件里</code></li></ul><pre><code class="typescript">interface StringValidator &#123;  isAcceptable(s: string): boolean;&#125;let letterRegExp = /^[A-Za-z]$/;let numberRegExp = /^[0-9]+$/;class LetterOnlyValidator implements StringValidator &#123;  isAcceptable(s: string): boolean &#123;    return letterRegExp.test(s);  &#125;&#125;class ZipCodeValidator implements StringValidator &#123;  isAcceptable(s: string): boolean &#123;    return s.length === 5 &amp;&amp; numberRegExp.test(s);  &#125;&#125;let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];let validators: &#123; [s: string]: StringValidator &#125; = &#123;&#125;;validators[&quot;ZIP code&quot;] = new ZipCodeValidator();validators[&quot;Letters Only&quot;] = new LetterOnlyValidator();// show whether each string passed each validatorfor (let s of strings) &#123;  for (let name in validators) &#123;    let isMatch = validators[name].isAcceptable(s);    console.log(`&#39;$&#123;s&#125;&#39; $&#123;isMatch ? &quot;matches&quot; : &quot;does not match&quot;&#125; &#39;$&#123;name&#125;&#39;.`);  &#125;&#125;</code></pre><h3 id="16-2-命名空间"><a href="#16-2-命名空间" class="headerlink" title="16.2 命名空间"></a>16.2 命名空间</h3><blockquote><p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。因此，我们把验证器包裹到一个命名空间里内，而不是把它们放在全局空间下。</p></blockquote><blockquote><p>下面的例子里，把所有与验证器相关的类型都放到一个叫做 <code>Validation</code> 的命名空间里。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 <code>export</code>。相反的，变量 <code>LetterRegExp</code> 和 <code>numberRegExp</code> 是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。在文件末尾的测试代码里，由于是在命名空间之外访问的，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p></blockquote><ul><li>使用命名空间的验证器</li></ul><pre><code class="typescript">namespace Validation &#123;  export interface StringValidator &#123;    isAcceptable(s: string): boolean;  &#125;  const LetterRegExp = /^[A-Za-z]+$/;  const numberRegExp = /^[0-9]+$/;  export class LetterOnlyValidator implements StringValidator &#123;    isAcceptable(s: string): boolean &#123;      return LetterRegExp.test(s);    &#125;  &#125;  export class ZipCodeValidator implements StringValidator &#123;    isAcceptable(s: string): boolean &#123;      return s.length === 5 &amp;&amp; numberRegExp.test(s);    &#125;  &#125;&#125;let strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];let validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[&quot;ZIP Code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters Only&quot;] = new Validation.LetterOnlyValidator();for (let s of strings) &#123;  for (let name in validators) &#123;    console.log(`&#39;$&#123;s&#125;&#39; $&#123;validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot;&#125; &#39;$&#123;name&#125;&#39;.`);  &#125;&#125;</code></pre><h3 id="16-3-分离到多文件"><a href="#16-3-分离到多文件" class="headerlink" title="16.3 分离到多文件"></a>16.3 分离到多文件</h3><blockquote><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以方便维护。</p></blockquote><h4 id="16-3-1-多文件中的命名空间"><a href="#16-3-1-多文件中的命名空间" class="headerlink" title="16.3.1 多文件中的命名空间"></a>16.3.1 多文件中的命名空间</h4><blockquote><p>现在，我们把 <code>Validation</code> 命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。</p></blockquote><ul><li><code>Validation.ts</code></li></ul><pre><code class="typescript">namespace Validation &#123;  export interface StringValidator &#123;    isAcceptable(s: string): boolean;  &#125;&#125;</code></pre><ul><li><code>LetterOnlyValidator.ts</code></li></ul><pre><code class="typescript">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;;namespace Validation &#123;  const lettersRegExp = /^[A-Za-z]+$/;  export class LettersOnlyValidator implements StringValidator &#123;    isAcceptable(s: string): boolean &#123;      return lettersRegExp.test(s);    &#125;  &#125;&#125;</code></pre><ul><li><code>ZipCodeValidator.ts</code></li></ul><pre><code class="typescript">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;namespace Validation &#123;  const numberRegExp = /^[0-9]+$/;  export class ZipCodeValidator implements StringValidator &#123;    isAcceptable(s: string): boolean &#123;      return s.length === 5 &amp;&amp; numberRegExp.test(s);    &#125;  &#125;&#125;</code></pre><ul><li><code>Test.ts</code></li></ul><pre><code class="typescript">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;// Some samples to trylet strings = [&quot;Hello&quot;, &quot;98052&quot;, &quot;101&quot;];// Validators to uselet validators: &#123; [s: string]: Validation.StringValidator &#125; = &#123;&#125;;validators[&quot;ZIP code&quot;] = new Validation.ZipCodeValidator();validators[&quot;Letters only&quot;] = new Validation.LettersOnlyValidator();// Show whether each string passed each validatorfor (let s of strings) &#123;  for (let name in validators) &#123;    console.log(`&quot;$&#123;s&#125;&quot; - $&#123;validators[name].isAcceptable(s) ? &quot;matches&quot; : &quot;does not match&quot;&#125; $&#123;name&#125;`);  &#125;&#125;</code></pre><blockquote><p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。我们有两种方式。</p></blockquote><ol><li>第一种方式，把所有的输入文件编译为一个输出文件，需要使用 <code>--outFile</code> 标记： <code>tsc --outFile sample.js Test.ts</code> 编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。 <code>tsc --outFile sample.js Validation.ts LetterOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></li><li>第二种方式，我们可以编写每一个文件(默认方式)，那么每个源文件都会对应生成一个 <code>JavaScript</code> 文件。然后，在页面上通过 <code>&lt;script&gt;</code> 标签把所有生成的 <code>JavaScript</code> 文件按正确的顺序引进来，比如：</li></ol><pre><code class="html">MyTestPage.html (excerpt)&lt;script src=&quot;Validation.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;LettersOnlyValidator.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;ZipCodeValidator.js&quot; type=&quot;text/javascript&quot; /&gt;&lt;script src=&quot;Test.js&quot; type=&quot;text/javascript&quot; /&gt;</code></pre><h3 id="16-4-别名"><a href="#16-4-别名" class="headerlink" title="16.4 别名"></a>16.4 别名</h3><blockquote><p>另一种简化命名空间操作的方法是用 <code>import q = x.y.z</code> 给常用的对象起一个短的名字。不要与用来加载模块的 <code>import x = require(&#39;name&#39;)</code> 语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p></blockquote><pre><code class="typescript">namespace Shapes &#123;  export namespace Polygons &#123;    export class Triangle &#123;&#125;    export class Square &#123;&#125;  &#125;&#125;import Polygons = Shapes.Polygons;let sq = new Polygons.Square(); // Same as &quot;new Shapes.Polygons.Square()&quot;</code></pre><blockquote><p>注意：我们并没有使用 <code>require</code> 关键字，而是直接使用导入符号的限定名赋值。这与使用 <code>var</code> 相似，但它还适用于类型和导入的具有命名空间含义的符号。重要的是，对于值来讲，<code>import</code> 会生成与原始符号不同的引用，所以改变别名的 <code>var</code> 值并不会影响原始变量的值。</p></blockquote><h3 id="16-5-使用其它的-JavaScript-库"><a href="#16-5-使用其它的-JavaScript-库" class="headerlink" title="16.5 使用其它的 JavaScript 库"></a>16.5 使用其它的 JavaScript 库</h3><blockquote><p>为了描述不是用 <code>TypeScript</code> 编写的类库的类型，我们需要声明类库导出的 <code>API</code>。由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。我们称其为声明是因为它不是外部程序的具体实现。我们通常在 <code>.d.ts</code> 里写这些声明。如果你熟悉 <code>C/C+</code>+，你可以把它们当作 <code>.h</code> 文件。</p></blockquote><blockquote><p>外部命名空间 (<code>declare namespace =&gt;</code>; 声明全局对象)</p></blockquote><blockquote><p>流行的程序库 <code>D3</code> 在全局对象 <code>d3</code> 里定义它的功能。因为这个库通过一个<code>&lt;script&gt;</code> 标签加载 (不是通过模块加载器)，它的声明文件使用内部模块来定义它的类型。为了让 <code>TypeScript</code> 编译器识别它的类型，我们使用外部命名空间声明。</p></blockquote><ul><li>比如，我们可以像下面这样写</li><li><code>D3.d.ts</code></li></ul><pre><code class="typescript">declare namespace D3 &#123;  export interface Selectors &#123;    select: &#123;      (selector: string): Selection;      (element: EventTarget): Selection;    &#125;;  &#125;  export interface Event &#123;    x: number;    y: number;  &#125;  export interface Base extends Selectors &#123;    event: Event;  &#125;&#125;declare var d3: D3.Base;</code></pre><h2 id="十七、命名空间和模块"><a href="#十七、命名空间和模块" class="headerlink" title="十七、命名空间和模块"></a>十七、命名空间和模块</h2><h3 id="17-1-介绍"><a href="#17-1-介绍" class="headerlink" title="17.1 介绍"></a>17.1 介绍</h3><blockquote><p>这篇文章将概括介绍在 <code>TypeScript</code> 里使用模块与命名空间来组织代码的方法。我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。</p></blockquote><h3 id="17-2-使用命名空间"><a href="#17-2-使用命名空间" class="headerlink" title="17.2 使用命名空间"></a>17.2 使用命名空间</h3><blockquote><p>命名空间是位于全局命名空间下的一个普通的带有名字的 <code>JavaScript</code> 对象。这令命名空间十分容易使用。它们可以在多文件中同时使用，并通过 <code>--outFile</code> 结合在一起。命名空间是帮你组织 <code>Web</code> 应用不错的方式，你可以把所有依赖都放在 <code>HTML</code> 页面的 <code>&lt;script&gt;</code> 标签里。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型应用中。</p></blockquote><h3 id="17-3-使用模块"><a href="#17-3-使用模块" class="headerlink" title="17.3 使用模块"></a>17.3 使用模块</h3><ol><li>像命名空间一样，模块可以包含代码和声明。不同的模块可以声明它的依赖。</li><li>模块会把依赖添加到模块加载器上(像是 <code>CommonJS</code> / <code>RequireJS</code>)。对于小型的 JS 应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。</li><li>对于 <code>Node.js</code> 应用来说，模块是默认并推荐的组织代码的方式。</li><li>从 <code>ECMAScript 2015</code> 开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。</li></ol><blockquote><p>因此，对于新项目来说推荐使用模块作为组织代码的方式。</p></blockquote><h3 id="17-4-命名空间和模块的陷阱"><a href="#17-4-命名空间和模块的陷阱" class="headerlink" title="17.4 命名空间和模块的陷阱"></a>17.4 命名空间和模块的陷阱</h3><blockquote><p>这部分我们会描述常见的命名空间和模块的使用陷阱和如何其避免它们。</p></blockquote><h4 id="17-4-1-对模块使用-lt-reference-gt"><a href="#17-4-1-对模块使用-lt-reference-gt" class="headerlink" title="17.4.1 对模块使用 /// &lt;reference&gt;"></a>17.4.1 对模块使用 <code>/// &lt;reference&gt;</code></h4><blockquote><p>一个常见的错误是使用 <code>/// &lt;reference&gt;</code> 引用模块文件，应该使用 <code>import</code>。要理解这之间的差别，我们首先应该弄清编译器是如何根据 <code>import</code> 路径(例如：<code>import x from &quot;...&quot;</code>；或 <code>import x = require(&quot;...&quot;)</code> 里面的 <code>...</code>，等等)来定位模块的类型信息的。</p></blockquote><blockquote><p>编译器首先尝试去查找相应路径下的 <code>.ts</code>，<code>.tsx</code> 再或者 <code>.d.ts</code>。如果这些文件都找不到，编译器会查找外部模块声明。回想一下，它们是在 <code>.d.ts</code> 文件里声明的。</p></blockquote><ul><li><code>myModules.d.ts</code></li></ul><pre><code class="typescript">// In a .d.ts file or .ts file that is not a moduledeclare module &quot;SomeModule&quot; &#123;  export function fn(): string;&#125;</code></pre><ul><li><code>myOtherModule.ts</code></li></ul><pre><code class="typescript">/// &lt;reference path=&quot;myModules.d.ts&quot;&gt;import * as m from &quot;SomeModule&quot;;</code></pre><blockquote><p>这里的引用标签指定了外来模块的位置。这就是一些 <code>TypeScript</code> 例子中引用 <code>node.d.ts</code> 的方法。</p></blockquote><h4 id="17-4-2-不必要的命名空间"><a href="#17-4-2-不必要的命名空间" class="headerlink" title="17.4.2 不必要的命名空间"></a>17.4.2 不必要的命名空间</h4><blockquote><p>如果你想把命名空间转换为模块，它可能会像下面这个文件一样。</p></blockquote><ul><li><code>shapes.ts</code></li></ul><pre><code class="typescript">export namespace Shapes &#123;  export class Triangle &#123;    /* ... */  &#125;  export class Square &#123;    /* ... */  &#125;&#125;</code></pre><blockquote><p>顶层的模块 <code>Shapes</code> 包裹了 <code>Triangle</code> 和 <code>Square</code>。对于使用它的人来说这是令人迷惑和讨厌的。</p></blockquote><ul><li><code>shapeConsumer.ts</code></li></ul><pre><code class="typescript">import * as shapes from &quot;./shapes&quot;;let t = new shapes.Shapes.Triangle(); // shapes.Shapes?</code></pre><blockquote><p><code>TypeScript</code> 里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。再次重申，不应该对模块使用命名空间。使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。</p></blockquote><ul><li>下面是改进的例子：</li><li><code>shape.ts</code></li></ul><pre><code class="typescript">export class Triangle &#123;  /* ... */&#125;export class Square &#123;  /* ... */&#125;</code></pre><ul><li><code>shapeConsumer.ts</code></li></ul><pre><code class="typescript">import * as shapes from &quot;./shapes&quot;;let t = new shapes.Triangle();</code></pre><h4 id="17-4-3-模块的取舍"><a href="#17-4-3-模块的取舍" class="headerlink" title="17.4.3 模块的取舍"></a>17.4.3 模块的取舍</h4><blockquote><p>就像每个 <code>JS</code> 文件对应一个模块一样，<code>TypeScript</code> 里模块文件与生成的 <code>JS</code> 文件也是一一对应的。这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。例如当目标模块系统为 <code>commonjs</code> 或 <code>umd</code> 时，无法使用 <code>outFile</code> 选项，但是 <code>TypeScript 1.8</code> 以上的版本能够使用 <code>outFile</code> 当目标为 <code>amd</code> 或 <code>system</code>。</p></blockquote><h2 id="十八、模块解析"><a href="#十八、模块解析" class="headerlink" title="十八、模块解析"></a>十八、模块解析</h2><h3 id="18-1-说明"><a href="#18-1-说明" class="headerlink" title="18.1 说明"></a>18.1 说明</h3><ol><li>模块解析是指编译器在查找导入模块内容时所遵循的流程。假设有一个导入语句 <code>import &#123; a &#125; from &quot;moduleA&quot;</code>; 为了去检查任何对 <code>a</code> 的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义 <code>moduleA</code>。</li><li>这时候，编译器会有个疑问“ <code>moduleA</code> 的结构是怎样的？” 这听上去很简单，但 moduleA 可能在你写的某个 .ts/.tsx 文件里或者在你的代码所依赖的 <code>.d.ts</code> 里。</li><li>首先，编译器会尝试定位表示导入模块的文件。编译器会遵循以下二种策略之一： <code>Classic</code> 或 <code>Node</code>。这些策略会告诉编译器到哪里去查找 <code>moduleA</code>。</li><li>如果上面的解析失败了并且模块名是非相对的（且是在&quot; <code>moduleA</code> &quot;的情况下），编译器会尝试定位一个外部模块声明。我们接下来会讲到非相对导入。</li></ol><p><code>5</code>. 最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为 <code>error TS2307: Cannot find module &#39;moduleA&#39;.</code></p><h3 id="18-2-相对-vs-非相对模块导入"><a href="#18-2-相对-vs-非相对模块导入" class="headerlink" title="18.2 相对 vs. 非相对模块导入"></a>18.2 相对 vs. 非相对模块导入</h3><blockquote><p>根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。</p></blockquote><ol><li>相对导入是以 <code>/，./</code> 或 <code>../</code> 开头的。 下面是一些例子：</li></ol><pre><code class="typescript">import Entry from &quot;./components/Entry&quot;;import &#123; Default &#125; from &quot;../constants/http&quot;;import &quot;/mod&quot;;</code></pre><ol start="2"><li>所有其它形式的导入被当作非相对的。下面是一些例子：</li></ol><pre><code class="typescript">import * as $ from &quot;JQuery&quot;;import &#123; Component &#125; from &quot;@angular/core&quot;;</code></pre><blockquote><p>相对导入在解析时是相对于导入它的文件，并不能解析为一个外部模块声明。你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。</p></blockquote><blockquote><p>非相对模块的导入可以相对于 baseUrl 或 通过下文会讲到的路径映射来解析。它们还可以被解析成 外部模块声明。</p></blockquote><blockquote><p>使用非相对路径来导入你的外部依赖。</p></blockquote><h3 id="18-3-模块解析策略"><a href="#18-3-模块解析策略" class="headerlink" title="18.3 模块解析策略"></a>18.3 模块解析策略</h3><blockquote><p>共有两种可用的模块解析策略：<code>Node</code> 和 <code>Classic</code>。 你可以使用 <code>--moduleResolution</code> 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 -<code>-module AMD \| System \| ES2015</code> 时的默认值为 <code>Classic</code>，其它情况时则为 <code>Node</code>。</p></blockquote><h4 id="18-3-1-Classic"><a href="#18-3-1-Classic" class="headerlink" title="18.3.1 Classic"></a>18.3.1 Classic</h4><blockquote><p>这种策略在以前是 <code>TypeScript</code> 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。</p></blockquote><blockquote><p>相对导入的模块是相对于导入它的文件进行解析的。 因此 <code>/root/src/folder/A.ts</code> 文件里的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 会使用下面的查找流程：</p></blockquote><ol><li>/root/src/folder/moduleB.ts``</li><li>/root/src/folder/moduleB.d.ts``</li></ol><blockquote><p>对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。</p></blockquote><ul><li><code>比如：</code></li></ul><blockquote><p>有一个对 <code>moduleB</code> 的非相对导入 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>，它是在 <code>/root/src/folder/A.ts</code> 文件里，会以如下的方式来定位&quot;<code>moduleB</code>&quot;：</p></blockquote><blockquote><ol><li><code>/root/src/folder/moduleB.ts</code></li><li><code>/root/src/folder/moduleB.d.ts</code></li><li><code>/root/src/moduleB.ts</code></li><li><code>/root/src/moduleB.d.ts</code></li><li><code>/root/moduleB.ts</code></li><li><code>/root/moduleB.d.ts</code></li><li><code>/moduleB.ts</code></li><li><code>/moduleB.d.ts</code></li></ol></blockquote><h4 id="18-3-2-Node"><a href="#18-3-2-Node" class="headerlink" title="18.3.2 Node"></a>18.3.2 Node</h4><blockquote><p>这个解析策略试图在运行时模仿 <code>Node.js</code> 模块解析机制。完整的 <code>Node.js</code> 解析算法可以在 <code>Node.js module documentation</code> 找到。</p></blockquote><ul><li>Node.js 如何解析模块</li></ul><blockquote><p>为了理解 <code>TypeScript</code> 编译依照的解析步骤，先弄明白<code>Node.js</code>模块是非常重要的。</p></blockquote><blockquote><p>通常，在 <code>Node.js</code> 里导入是通过 <code>require</code> 函数调用进行的。 <code>Node.js</code> 会根据 <code>require</code> 是相对路径还是非相对路径做出不同的行为。</p></blockquote><blockquote><p>相对路径很简单。 例如，假设有一个文件路径为 <code>/root/src/moduleA.js</code>，包含了一个导入 <code>var x = require(&quot;./moduleB&quot;)</code>;</p></blockquote><ul><li>Node.js 以下面的顺序解析这个导入</li></ul><ol><li>检查 <code>/root/src/moduleB.js</code> 文件是否存在。</li><li>检查 <code>/root/src/moduleB</code> 目录是否包含一个 <code>package.json</code> 文件，且 <code>package.json</code> 文件指定了一个&quot;<code>main</code>&quot;模块。</li></ol><blockquote><p>在我们的例子里，如果 <code>Node.js</code> 发现文件 <code>/root/src/moduleB/package.json</code> 包含了 <code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，那么 <code>Node.js</code> 会引用 <code>/root/src/moduleB/lib/mainModule.js</code>。</p></blockquote><ol start="3"><li>检查 <code>/root/src/moduleB</code> 目录是否包含一个 <code>index.js</code> 文件。 这个文件会被隐式地当作那个文件夹下的&quot;<code>main</code>&quot;模块。</li></ol><p>你可以阅读 <code>Node.js</code> 文档了解更多详细信息：<a href="https://nodejs.org/api/modules.html#modules_file_modules" target="_blank" rel="noopener external nofollow noreferrer">file modules</a> 和 <a href="https://nodejs.org/api/modules.html#modules_folders_as_modules" target="_blank" rel="noopener external nofollow noreferrer">folder modules</a>。</p><blockquote><p>但是，非相对模块名的解析是个完全不同的过程。<code>Node</code> 会在一个特殊的文件夹 <code>node\_modules</code> 里查找你的模块。<code>node\_modules</code> 可能与当前文件在同一级目录下，或者在上层目录里。<code>Node</code> 会向上级目录遍历，查找每个 <code>node\_modules</code>直到它找到要加载的模块。<br>还是用上面例子，但假设 <code>/root/src/moduleA.js</code> 里使用的是非相对路径导入 <code>var x = require(&quot;moduleB&quot;)</code>;</p></blockquote><ul><li><code>Node</code> 则会以下面的顺序去解析 <code>moduleB</code>，直到有一个匹配上。</li></ul><blockquote><p>1.<code>/root/src/node_modules/moduleB.js</code> 2.<code>/root/src/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 3.<code>/root/src/node_modules/moduleB/index.js</code> 4.<code>/root/node_modules/moduleB.js</code> 5.<code>/root/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 6.<code>/root/node_modules/moduleB/index.js</code> 7.<code>/node_modules/moduleB.js</code> 8.<code>/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 9.<code>/node_modules/moduleB/index.js</code></p></blockquote><blockquote><p>注意 <code>Node.js</code> 在步骤（<code>4</code>）和（<code>7</code>）会向上跳一级目录。<br>你可以阅读 <code>Node.js</code> 文档了解更多详细信息：<a href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders" target="_blank" rel="noopener external nofollow noreferrer">loading modules from node_modules</a>。</p></blockquote><ul><li>TypeScript 如何解析模块</li></ul><blockquote><p><code>TypeScript</code> 是模仿 <code>Node.js</code> 运行时的解析策略来在编译阶段定位模块定义文件。因此，<code>TypeScript</code> 在 <code>Node</code> 解析逻辑基础上增加了 TypeScript 源文件的扩展名（ <code>.ts</code>，<code>.tsx</code> 和 <code>.d.ts</code>）。同时，<code>TypeScript</code> 在 <code>package.json</code> 里使用字段&quot;<code>types</code>&quot;来表示类似&quot;<code>main</code>&quot;的意义 <code>-</code> 编译器会使用它来找到要使用的&quot;<code>main</code>&quot;定义文件。</p></blockquote><blockquote><p>比如，有一个导入语句 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 在 <code>/root/src/moduleA.ts</code> 里，会以下面的流程来定位 <code>&quot;./moduleB&quot;</code> ：</p><ol><li><code>/root/src/moduleB.ts</code></li><li><code>/root/src/moduleB.tsx</code></li><li><code>/root/src/moduleB.d.ts</code></li><li><code>/root/src/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li><li><code>/root/src/moduleB/index.ts</code></li><li><code>/root/src/moduleB/index.tsx</code></li><li><code>/root/src/moduleB/index.d.ts</code></li></ol></blockquote><blockquote><p>回想一下 <code>Node.js</code> 先查找 <code>moduleB.js</code> 文件，然后是合适的 <code>package.json</code>，再之后是 <code>index.js</code>。</p></blockquote><blockquote><p>类似地，非相对的导入会遵循 <code>Node.js</code> 的解析逻辑，首先查找文件，然后是合适的文件夹。因此 <code>/root/src/moduleA.ts</code> 件里的 <code>import &#123; b &#125; from &quot;moduleB&quot;</code> 会以下面的查找顺序解析：</p><ol><li><code>/root/src/node_modules/moduleB.ts</code></li><li><code>/root/src/node_modules/moduleB.tsx</code></li><li><code>/root/src/node_modules/moduleB.d.ts</code></li><li><code>/root/src/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li><li><code>/root/src/node_modules/moduleB/index.ts</code></li><li><code>/root/src/node_modules/moduleB/index.tsx</code></li><li><code>/root/src/node_modules/moduleB/index.d.ts</code></li><li><code>/root/node_modules/moduleB.ts</code></li><li><code>/root/node_modules/moduleB.tsx</code></li><li><code>/root/node_modules/moduleB.d.ts</code></li><li><code>/root/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li><li><code>/root/node_modules/moduleB/index.ts</code></li><li><code>/root/node_modules/moduleB/index.tsx</code></li><li><code>/root/node_modules/moduleB/index.d.ts</code></li><li><code>/node_modules/moduleB.ts</code></li><li><code>/node_modules/moduleB.tsx</code></li><li><code>/node_modules/moduleB.d.ts</code></li><li><code>/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li><li><code>/node_modules/moduleB/index.ts</code></li><li><code>/node_modules/moduleB/index.tsx</code></li><li><code>/node_modules/moduleB/index.d.ts</code></li></ol></blockquote><blockquote><p>不要被这里步骤的数量吓到 <code>-</code> <code>TypeScript</code> 只是在步骤（<code>8</code>）和（<code>15</code>）向上跳了两次目录。 这并不比 <code>Node.js</code> 里的流程复杂。</p></blockquote><h3 id="18-4-附加的模块解析标记"><a href="#18-4-附加的模块解析标记" class="headerlink" title="18.4 附加的模块解析标记"></a>18.4 附加的模块解析标记</h3><blockquote><ol><li>有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将 <code>.ts</code> 编译成 <code>.js</code>，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。</li><li><code>TypeScript</code> 编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪个转换。</li><li>有一点要特别注意的是编译器不会进行这些转换操作；它只是利用这些信息来指导模块的导入。</li></ol></blockquote><ul><li><code>Base URL</code></li></ul><blockquote><p>在利用 <code>AMD</code> 模块加载器的应用里使用 <code>baseUrl</code> 是常见做法，它要求在运行时模块都被放到了一个文件夹里。这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。</p></blockquote><blockquote><p>设置 <code>baseUrl</code> 来告诉编译器到哪里去查找模块。 所有 <code>非相对模块</code> 导入都会被当做相对于 <code>baseUrl</code>。</p></blockquote><ul><li><code>baseUrl</code> 的值由以下两者之一决定：</li></ul><blockquote><ol><li>命令行中 <code>baseUrl</code> 的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）</li><li><code>tsconfig.json</code>里的 <code>baseUrl</code> 属性（如果给定的路径是相对的，那么将相对于‘<code>tsconfig.json</code>’路径进行计算）</li></ol></blockquote><blockquote><p>注意相对模块的导入不会被设置的 <code>baseUrl</code> 所影响，因为它们总是相对于导入它们的文件。</p></blockquote><blockquote><p>阅读更多关于 <code>baseUrl</code> 的信息 <a href="https://requirejs.org/docs/api.html#config-baseUrl" target="_blank" rel="noopener external nofollow noreferrer">RequireJS</a> 和 <a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl" target="_blank" rel="noopener external nofollow noreferrer"><code>SystemJS</code></a>。</p></blockquote><h3 id="18-5-路径映射"><a href="#18-5-路径映射" class="headerlink" title="18.5 路径映射"></a>18.5 路径映射</h3><blockquote><p>有时模块不是直接放在 <code>baseUrl</code> 下面。 比如，充分 &quot;<code>jquery</code>&quot;模块地导入，在运行时可能被解释为&quot;<code>node\_modules/jquery/dist/jquery.slim.min.js</code>&quot;。 加载器使用映射配置来将模块名映射到运行时的文件，查看 <a href="https://requirejs.org/docs/api.html#config-paths" target="_blank" rel="noopener external nofollow noreferrer">RequireJs documentation</a> 和 <a href="https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths" target="_blank" rel="noopener external nofollow noreferrer">SystemJS documentation</a>。</p></blockquote><blockquote><p><code>TypeScript</code> 编译器通过使用 <code>tsconfig.json</code> 文件里的 &quot;<code>paths</code>&quot; 来支持这样的声明映射。 下面是一个如何指定 <code>jquery</code> 的&quot;<code>paths</code>&quot;的例子。</p></blockquote><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;, // This must be specified if &quot;paths&quot; is.    &quot;paths&quot;: &#123;      &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery&quot;] // 此处映射是相对于&quot;baseUrl&quot;    &#125;  &#125;&#125;</code></pre><blockquote><p>请注意&quot;<code>paths</code>&quot;是相对于&quot;<code>baseUrl</code>&quot;进行解析。 如果 &quot;<code>baseUrl</code>&quot; 被设置成了除&quot;<code>.</code>&quot;外的其它值，比如 <code>tsconfig.json</code> 所在的目录，那么映射必须要做相应的改变。如果你在上例中设置了 <code>&quot;baseUrl&quot;: &quot;./src&quot;</code>，那么 <code>jquery</code> 应该映射到 <code>&quot;../node\_modules/jquery/dist/jquery&quot;</code>。</p></blockquote><blockquote><p>通过&quot;<code>paths</code>&quot;我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：</p></blockquote><pre><code class="typescript">projectRoot├── folder1│   ├── file1.ts (imports &#39;folder1/file2&#39; and &#39;folder2/file3&#39;)│   └── file2.ts├── generated│   ├── folder1│   └── folder2│       └── file3.ts└── tsconfig.json</code></pre><ul><li>相应的 <code>tsconfig.json</code> 文件如下：</li></ul><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;*&quot;: [&quot;*&quot;, &quot;generated/*&quot;]    &#125;  &#125;&#125;</code></pre><blockquote><p>它告诉编译器所有匹配 <code>&quot;\*&quot;</code>（所有的值）模式的模块导入会在以下两个位置查找：</p><ol><li><code>&quot;\*&quot;</code>： 表示名字不发生改变，所以映射为  <code>=&gt;</code> <code>/</code></li><li>&quot;<code>generated/</code>&quot;表示模块名添加了“<code>generated</code>”前缀，所以映射为 <code>&lt;moduleName&gt; =&gt; &lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code></li></ol></blockquote><ul><li><code>按照这个逻辑，编译器将会如下尝试解析这两个导入：</code></li></ul><blockquote><p>(i). 导入<code>&#39;folder1/file2&#39;</code></p><ol><li>匹配 <code>&#39;\*&#39;</code> 模式且通配符捕获到整个名字。</li><li>尝试列表里的第一个替换：<code>&#39;\*&#39; -&gt; folder1/file2</code>。</li><li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&gt; projectRoot/folder1/file2.ts</code>。</li><li>文件存在。完成。</li></ol><p>(ii). 导入<code>&#39;folder2/file3&#39;</code></p><ol><li>匹配 <code>&#39;\*&#39;</code> 模式且通配符捕获到整个名字。</li><li>尝试列表里的第一个替换：<code>&#39;\*&#39; -&gt; folder2/file3</code>。</li><li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&gt; projectRoot/folder2/file3.ts</code>。</li><li>文件不存在，跳到第二个替换。</li><li>第二个替换：<code>&#39;generated/&#39; -&gt; generated/folder2/file3</code>。</li><li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&amp;gt; projectRoot/generated/folder2/file3.ts</code>。</li><li>文件存在。完成。</li></ol></blockquote><ul><li>利用 <code>rootDirs</code> 指定虚拟目录</li></ul><blockquote><p>有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。 利用 <code>rootDirs</code>，可以告诉编译器生成这个虚拟目录的 <code>roots</code>； 因此编译器可以在“虚拟”目录下解析相对模块导入，就好像它们被合并在了一起一样。</p></blockquote><blockquote><p>比如，有下面的工程结构：</p></blockquote><pre><code class="typescript">src └── views     └── view1.ts (imports &#39;./template1&#39;)     └── view2.ts generated └── templates         └── views             └── template1.ts (imports &#39;./view2&#39;)</code></pre><blockquote><p><code>src/views</code> 里的文件是用于控制 UI 的用户代码。 <code>generated/templates</code> 是 <code>UI</code> 模版，在构建时通过模版生成器自动生成。构建中的一步会将 <code>/src/views</code> 和 <code>/generated/templates/views</code> 的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入 <code>&quot;./template&quot;</code>。</p></blockquote><blockquote><p>可以使用&quot;<code>rootDirs</code>&quot;来告诉编译器。&quot;<code>rootDirs</code>&quot;指定了一个 <code>roots</code> 列表，列表里的内容会在运行时被合并。</p></blockquote><blockquote><p>因此，针对这个例子， <code>tsconfig.json</code> 如下：</p></blockquote><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;rootDirs&quot;: [&quot;src/views&quot;, &quot;generated/templates/views&quot;]  &#125;&#125;</code></pre><blockquote><p>每当编译器在某一 <code>rootDirs</code> 的子目录下发现了相对模块导入，它就会尝试从每一个 <code>rootDirs</code> 中导入。</p></blockquote><blockquote><p><code>rootDirs</code> 的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑( <code>bundles</code> )和运行时的特性，比如条件引入和工程特定的加载器插件。</p></blockquote><blockquote><p>设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将 <code>\#&#123;locale&#125;</code> 做为相对模块路径 <code>./\#&#123;locale&#125;/messages</code> 的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成 <code>./zh/messages</code>，<code>./de/messages</code> 等。</p></blockquote><blockquote><p>假设每个模块都会导出一个字符串的数组。比如 <code>./zh/messages</code> 可能包含：</p></blockquote><pre><code class="typescript">export default [&quot;您好吗&quot;, &quot;很高兴认识你&quot;];</code></pre><blockquote><p>利用 <code>rootDirs</code> 我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析 <code>./\#&#123;locale&#125;/messages</code>，就算这个目录永远都不存在。比如，使用下面的 <code>tsconfig.json</code>：</p></blockquote><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;rootDirs&quot;: [&quot;src/zh&quot;, &quot;src/de&quot;, &quot;src/#&#123;locale&#125;&quot;]  &#125;&#125;</code></pre><blockquote><p>编译器现在可以将 <code>import messages from &#39;./#&#123;locale&#125;/messages&#39;</code> 解析为 <code>import messages from &#39;./zh/messages&#39;</code> 用做工具支持的目的，并允许在开发时不必了解区域信息。</p></blockquote><h3 id="18-6-跟踪模块解析"><a href="#18-6-跟踪模块解析" class="headerlink" title="18.6 跟踪模块解析"></a>18.6 跟踪模块解析</h3><blockquote><p>如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过 <code>--traceResolution</code> 启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。</p></blockquote><blockquote><p>假设我们有一个使用了 <code>typescript</code> 模块的简单应用。<code>app.ts</code> 里有一个这样的导入 <code>import * as ts from &quot;typescript&quot;</code>。</p></blockquote><pre><code class="typescript">│   tsconfig.json├───node_modules│   └───typescript│       └───lib│               typescript.d.ts└───src        app.ts</code></pre><blockquote><p>使用 <code>--traceResolution</code> 调用编译器。</p></blockquote><pre><code class="typescript">tsc --traceResolution</code></pre><blockquote><p>输出结果如下：</p></blockquote><pre><code class="typescript">======== Resolving module &#39;typescript&#39; from &#39;src/app.ts&#39;. ========Module resolution kind is not specified, using &#39;NodeJs&#39;.Loading module &#39;typescript&#39; from &#39;node_modules&#39; folder.File &#39;src/node_modules/typescript.ts&#39; does not exist.File &#39;src/node_modules/typescript.tsx&#39; does not exist.File &#39;src/node_modules/typescript.d.ts&#39; does not exist.File &#39;src/node_modules/typescript/package.json&#39; does not exist.File &#39;node_modules/typescript.ts&#39; does not exist.File &#39;node_modules/typescript.tsx&#39; does not exist.File &#39;node_modules/typescript.d.ts&#39; does not exist.Found &#39;package.json&#39; at &#39;node_modules/typescript/package.json&#39;.&#39;package.json&#39; has &#39;types&#39; field &#39;./lib/typescript.d.ts&#39; that references &#39;node_modules/typescript/lib/typescript.d.ts&#39;.File &#39;node_modules/typescript/lib/typescript.d.ts&#39; exist - use it as a module resolution result.======== Module name &#39;typescript&#39; was successfully resolved to &#39;node_modules/typescript/lib/typescript.d.ts&#39;. ========</code></pre><blockquote><p>需要留意的地方：</p></blockquote><blockquote><ol><li>导入的名字及位置 <code>======== Resolving module &#39;typescript&#39; from &#39;src/app.ts&#39;. ========</code></li><li>编译器使用的策略 <code>Module resolution kind is not specified, using &#39;NodeJs&#39;.</code></li><li>从 <code>npm</code> 加载 <code>types</code> <code>&#39;package.json&#39; has &#39;types&#39; field &#39;./lib/typescript.d.ts&#39; that references &#39;node\_modules/typescript/lib/typescript.d.ts&#39;.</code></li><li>最终结果 <code>======== Module name &#39;typescript&#39; was successfully resolved to &#39;node\_modules/typescript/lib/typescript.d.ts&#39;. ========</code></li></ol></blockquote><ul><li>使用 <code>--noResolve</code></li></ul><blockquote><p>正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件 <code>import</code>，这个文件被会加到一个文件列表里，以供编译器稍后处理。<code>--noResolve</code> 编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。</p></blockquote><blockquote><p><code>比如</code>:</p></blockquote><ul><li><code>app.ts</code></li></ul><pre><code class="typescript">import * as A from &quot;moduleA&quot;; // OK, moduleA passed on the command-lineimport * as B from &quot;moduleB&quot;; // Error TS2307: Cannot find module &#39;moduleB&#39;.</code></pre><pre><code class="typescript">tsc app.ts moduleA.ts --noResolve</code></pre><blockquote><p>使用 <code>--noResolve</code> 编译 <code>app.ts</code>：</p></blockquote><blockquote><ol><li>可能正确找到 <code>moduleA</code>，因为它在命令行上指定了。</li><li>找不到 <code>moduleB</code>，因为没有在命令行上传递。</li></ol></blockquote><h3 id="18-7-常见问题"><a href="#18-7-常见问题" class="headerlink" title="18.7 常见问题"></a>18.7 常见问题</h3><ul><li>为什么在 <code>exclude</code> 列表里的模块还会被编译器使用</li></ul><blockquote><p><code>tsconfig.json</code> 将文件夹转变一个“工程” 如果不指定任何 “<code>exclude</code>” 或 “<code>files</code>”，文件夹里的所有文件包括 <code>tsconfig.json</code> 和 所有的子目录 都会在编译列表里。 如果你想利用 “<code>exclude</code>”排除某些文件，甚至你想指定所有要编译的文件列表，请使用“<code>files</code>”。</p></blockquote><blockquote><p>有些是被 <code>tsconfig.json</code> 自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。</p></blockquote><blockquote><p>因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行 <code>import</code> 或使用了 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令的文件。</p></blockquote><h2 id="十九、声明合并"><a href="#十九、声明合并" class="headerlink" title="十九、声明合并"></a>十九、声明合并</h2><h3 id="19-1-介绍"><a href="#19-1-介绍" class="headerlink" title="19.1 介绍"></a>19.1 介绍</h3><blockquote><p><code>TypeScript</code> 中有些独特的概念可以在类型层面上描述 <code>JavaScript</code> 对象的模型。这其中尤其独特的一个例子 &quot;声明合并&quot; 的概念。</p></blockquote><blockquote><p>理解了这个概念，将有助于操作现有的 <code>JavaScript</code> 代码。同时，也会有助于理解更多高级抽象的概念。</p></blockquote><blockquote><p>对本文件来讲，&quot;<code>声明合并</code>&quot; 是指编译器将针对同一个名字的两个独立声明合并为单一声明。合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可被合并；不局限于两个声明。</p></blockquote><h3 id="19-2-基础概念"><a href="#19-2-基础概念" class="headerlink" title="19.2 基础概念"></a>19.2 基础概念</h3><blockquote><p><code>TypeScript</code> 中的声明会创建以下三种实体之一：<code>命名空间</code>，<code>类型</code> 或 <code>值</code>。创建命名空间的声明会新建一个命名空间，它包含了用(.)符号来访问时使用的名字。创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。<br>最后，创建值的声明会创建在 <code>JavaScript</code> 输出中看到的值。</p></blockquote><table><thead><tr><th align="left">Declaration Type</th><th align="left">Namespace</th><th align="left">Type</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left"><code>Namespace</code></td><td align="left">X</td><td align="left"></td><td align="left">X</td></tr><tr><td align="left"><code>Class</code></td><td align="left"></td><td align="left">X</td><td align="left">X</td></tr><tr><td align="left"><code>Enum</code></td><td align="left"></td><td align="left">X</td><td align="left">X</td></tr><tr><td align="left"><code>Interface</code></td><td align="left"></td><td align="left">X</td><td align="left"></td></tr><tr><td align="left"><code>Type Alias</code></td><td align="left"></td><td align="left">X</td><td align="left"></td></tr><tr><td align="left"><code>Function</code></td><td align="left"></td><td align="left"></td><td align="left">X</td></tr><tr><td align="left"><code>Variable</code></td><td align="left"></td><td align="left"></td><td align="left">X</td></tr></tbody></table><blockquote><p>理解每个声明创建了什么，有助于理解当声明合并时，有哪些东西被合并了。</p></blockquote><h3 id="19-3-合并接口"><a href="#19-3-合并接口" class="headerlink" title="19.3 合并接口"></a>19.3 合并接口</h3><blockquote><p>最简单最常见的声明合并类型是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。</p></blockquote><pre><code class="typescript">interface Box &#123;  height: number;  width: number;&#125;interface Box &#123;  scale: number;&#125;let box: Box = &#123; height: 5, width: 6, scale: 10 &#125;;</code></pre><blockquote><p>接口的非函数成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。</p></blockquote><blockquote><p>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口 <code>A</code> 与后来的接口 <code>A</code> 合并时，后面的接口具有更高的优先级。</p></blockquote><pre><code class="typescript">// 如下例所示：interface Cloner &#123;  clone(animal: Animal): Animal;&#125;interface Cloner &#123;  clone(animal: Sheep): Sheep;&#125;interface Cloner &#123;  clone(animal: Dog): Dog;  clone(animal: Cat): Cat;&#125;// 这三个接口合并成一个声明：interface Cloner &#123;  clone(animal: Dog): Dog;  clone(animal: Cat): Cat;  clone(animal: Sheep): Sheep;  clone(animal: Animal): Animal;&#125;</code></pre><blockquote><p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前的位置。</p></blockquote><blockquote><p>这个规则有一个例外是当出现特殊的函数签名时。如果签名里有一个参数的类型是单一的字符串字面量(比如，不是字符串字面量的联合类型)，那么它将会被提升到重载列表的最顶端。</p></blockquote><pre><code class="typescript">// 比如，下面的接口会合并到一起interface Document &#123;  createElement(tagName: any): ELement;&#125;interface Document &#123;  createElement(tagName: &quot;div&quot;): HTMLDivElement;  createElement(tagName: &quot;span&quot;): HTMLSpanElement;&#125;interface Document &#123;  createElement(tagName: string): HTMLElement;  createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;&#125;// 合并后的 Document 将会像下面这样:interface Document &#123;  createElement(tagName: &quot;canvas&quot;): HTMLCanvasElement;  createElement(tagName: &quot;div&quot;): HTMLDivElement;  createElement(tagName: &quot;span&quot;): HTMLSpanElement;  createElement(tagName: string): HTMLElement;  createElement(tagName: any): Element;&#125;</code></pre><h3 id="19-4-合并命名空间"><a href="#19-4-合并命名空间" class="headerlink" title="19.4 合并命名空间"></a>19.4 合并命名空间</h3><ol><li>与接口相似，同名的命名空间也会合并其成员。命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。</li><li>对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</li><li>对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</li></ol><pre><code class="typescript">// Animals 声明合并示例：namespace Animals &#123;  export class Zebra &#123;&#125;&#125;namespace Animals &#123;  export interface Legged &#123;    numberOfLegs: number;  &#125;  export class Dog &#123;&#125;&#125;// 等同于：namespace Animals &#123;  export interface Legged &#123;    numberOfLegs: number;  &#125;  export class Zebra &#123;&#125;  export class Dog &#123;&#125;&#125;</code></pre><blockquote><p>除了这些合并外，你还需要了解非导出成员是如何处理的。非导出成员仅在其原有的(合并前的)命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。</p></blockquote><ul><li>下面提供了清晰的说明：</li></ul><pre><code class="typescript">namespace Animal &#123;  let haveMuscles = true;  export function animalsHaveMuscles() &#123;    return haveMuscles;  &#125;&#125;namespace Animal &#123;  export function doAnimalsHaveMuscles() &#123;    return haveMuscles; // // Error, because haveMuscles is not accessible here  &#125;&#125;</code></pre><blockquote><p>因为 <code>haveMuscles</code> 并没有导出，只有 <code>animalsHaveMuscles</code> 函数共享了原始未合并的命名空间可以访问这个变量。<br><code>doAnimalsHaveMuscles</code> 函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p></blockquote><h3 id="19-5-命名空间与类和函数和枚举类型合并"><a href="#19-5-命名空间与类和函数和枚举类型合并" class="headerlink" title="19.5 命名空间与类和函数和枚举类型合并"></a>19.5 命名空间与类和函数和枚举类型合并</h3><blockquote><p>命名空间可以与其它类型的声明合并。只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。<br><code>TypeScript</code> 使用这个功能去实现一些 <code>JavaScript</code> 里的设计模式。</p></blockquote><h4 id="19-5-1-合并命名空间和类"><a href="#19-5-1-合并命名空间和类" class="headerlink" title="19.5.1 合并命名空间和类"></a>19.5.1 合并命名空间和类</h4><blockquote><p>这让我们可以表示内部类</p></blockquote><pre><code class="typescript">class Album &#123;  label: Album.AlbumLabel;&#125;namespace Album &#123;  export class AlbumLabel &#123;&#125;&#125;</code></pre><blockquote><p><code>合并规则</code> 与上面 <code>合并命名空间</code> 小节里讲的规则一致，我们必须导出 <code>AlbumLabel</code> 类，好让合并的类能访问。</p></blockquote><blockquote><p><code>合并结果</code>是一个类并带有一个内部类。你也可以使用命名空间为类增加一些静态属性。</p></blockquote><blockquote><p>除了内部类的模式，你在 <code>JavaScript</code> 里，创建一个函数稍后扩展它增加一些属性也是很常见的。<code>TypeScript</code> 使用声明合并来达到这个目的并保证类型安全。</p></blockquote><pre><code class="typescript">function buildLabel(name: string): string &#123;  return buildLabel.prefix + name + buildLabel.suffix;&#125;namespace buildLabel &#123;  export let suffix = &quot;&quot;;  export let prefix = &quot;Hello, &quot;;&#125;console.log(buildLabel(&quot;Sam Smith&quot;));// 相似的，命名空间可以用来扩展枚举类型enum Color &#123;  red = 1,  green = 2,  blue = 4&#125;namespace Color &#123;  export function mixColor(colorName: string) &#123;    if (colorName === &quot;yellow&quot;) &#123;      return Color.red + Color.green;    &#125; else if (colorName === &quot;white&quot;) &#123;      return Color.red + Color.green + Color.blue;    &#125; else if (colorName === &quot;magenta&quot;) &#123;      return Color.red + Color.blue;    &#125; else if (colorName === &quot;cyan&quot;) &#123;      return Color.green + Color.blue;    &#125;  &#125;&#125;</code></pre><h4 id="19-5-2-非法的合并"><a href="#19-5-2-非法的合并" class="headerlink" title="19.5.2 非法的合并"></a>19.5.2 非法的合并</h4><blockquote><p><code>TypeScript</code> 并非允许所有的合并。目前，类不能与其它类或变量合并。想要了解如何模仿类的合并，请参照 <a href="https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/Mixins%E6%B7%B7%E5%85%A5/README.md" target="_blank" rel="noopener external nofollow noreferrer">TypeScript 混入</a>。</p></blockquote><h3 id="19-6-模块扩展"><a href="#19-6-模块扩展" class="headerlink" title="19.6 模块扩展"></a>19.6 模块扩展</h3><blockquote><p>虽然 <code>JavaScript</code> 不支持合并，但你可以为导入的对象打补丁以更新它们。</p></blockquote><ul><li>让我们考察一下这个玩具性的示例：</li></ul><pre><code class="typescript">// observable.jsexport class Observable&lt;T&gt; &#123;  // ... implementation left as an exercise for the reader...&#125;// map.jsimport &#123; Observable &#125; from &quot;./observable&quot;;Observable.prototype.map = function () &#123;  // ... another exercise for the reader&#125;;</code></pre><blockquote><p>它也可以很好地工作在 <code>TypeScript</code> 中，但编译器对 <code>Observable.prototype.map</code> 一无所知。你可以使用扩展模块来将它告诉编译器。</p></blockquote><pre><code class="typescript">// observable.ts stays the same// map.tsimport &#123; Observable &#125; from &quot;./observable&quot;;declare module &quot;./observable&quot; &#123;  interface Observable&lt;T&gt; &#123;    map&lt;U&gt;(f: (x: T) =&gt; U): Observable&lt;U&gt;;  &#125;&#125;Observable.prototype.map = function (f) &#123;  // ... another exercise for the reader&#125;;// consumer.tsimport &#123; Observable &#125; from &quot;./observable&quot;;import &quot;./map&quot;;let o: Observable&lt;number&gt;;o.map(x =&gt; x.toFixed());</code></pre><blockquote><p>模块名的解析和用 <code>import / export</code> 解析模块标识符的方式是一致的。 更多信息请参考 <a href="https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/%E6%A8%A1%E5%9D%97/README.md" target="_blank" rel="noopener external nofollow noreferrer">Modules</a>。当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明(仅可以扩展模块中已经存在的声明)。</p></blockquote><h3 id="19-7-全局扩展"><a href="#19-7-全局扩展" class="headerlink" title="19.7 全局扩展"></a>19.7 全局扩展</h3><blockquote><p>你也可以在模块内部添加声明到全局作用域中</p></blockquote><blockquote><p><code>observable.ts</code></p></blockquote><pre><code class="typescript">export class Observable&lt;T&gt; &#123;  // ... still no implementation ...&#125;declare global &#123;  interface Array&lt;T&gt; &#123;    toObservable(): Observable&lt;T&gt;;  &#125;&#125;Array.prototype.toObservable = function () &#123;  // ...&#125;;</code></pre><blockquote><p>全局扩展和与模块扩展的行为和限制是相同的。</p></blockquote><h2 id="二十、JSX"><a href="#二十、JSX" class="headerlink" title="二十、JSX"></a>二十、JSX</h2><h3 id="20-1-介绍"><a href="#20-1-介绍" class="headerlink" title="20.1 介绍"></a>20.1 介绍</h3><blockquote><p><code>JSX</code> 是一种嵌入式的类似 <code>XML</code> 的语法。它可以被转换成合法的 <code>JavaScript</code>，尽管转换的语义是根据不同的实现而定的。<br><code>JSX</code> 因 <code>React</code> 框架而流行，但也存在其它的实现。<code>TypeScript</code> 支持内嵌，类型检查以及将 <code>JSX</code> 直接编译为 JavaScript。</p></blockquote><h3 id="20-2-基本用法"><a href="#20-2-基本用法" class="headerlink" title="20.2 基本用法"></a>20.2 基本用法</h3><ul><li>想要使用 <code>JSX</code> 必须做两件事：</li></ul><blockquote><ol><li>给文件一个 <code>.tsx</code> 扩展名</li><li>启用 <code>jsx</code> 选项</li></ol></blockquote><ul><li><code>TypeScript</code> 具有三种 <code>JSX</code> 模式：<code>preserve</code>, <code>react</code> 和 <code>react-native</code>。这些模式只在代码生成阶段起作用 - 类型检查并不受影响。</li></ul><blockquote><ol><li>在 <code>preserve</code> 模式下生成代码中会保留 <code>JSX</code> 以供后续的转换操作使用( <code>比如：Babel</code> )。另外，输出文件会带有 <code>.jsx</code> 扩展名。</li><li><code>react</code> 模式会生成 <code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为 <code>.js</code>。</li><li><code>react-native</code> 相当于 <code>preserve</code>，它也保留了所有的 <code>JSX</code>，但是输出文件的扩展名是 <code>.js</code>。</li></ol></blockquote><table><thead><tr><th align="left">模式</th><th align="left">输入</th><th align="left">输出</th><th align="left">输出文件扩展名</th></tr></thead><tbody><tr><td align="left">preserve</td><td align="left"><code>&lt;div /&gt;</code></td><td align="left"><code>&lt;div /&gt;</code></td><td align="left"><code>.js</code></td></tr><tr><td align="left">react</td><td align="left"><code>&lt;div /&gt;</code></td><td align="left"><code>React.createElement(&quot;div&quot;)</code></td><td align="left"><code>.js</code></td></tr><tr><td align="left">react-native</td><td align="left"><code>&lt;div /&gt;</code></td><td align="left"><code>&lt;div /&gt;</code></td><td align="left"><code>.js</code></td></tr></tbody></table><blockquote><p>你可以通过在命令行里使用 <code>--jsx</code> 标记或 <code>tsconfig.json</code> 里的选项来指定模式。<br>注意：<code>React</code> 标识符是写死的硬编码，所以你必须保证 <code>React</code>（大写的<code>R</code>）是可用的。</p></blockquote><h3 id="20-3-as-操作符"><a href="#20-3-as-操作符" class="headerlink" title="20.3 as 操作符"></a>20.3 as 操作符</h3><blockquote><p>回想一下怎么写类型断言</p></blockquote><pre><code class="typescript">var foo = &lt;foo&gt;bar;</code></pre><blockquote><p>这里断言 <code>bar</code> 变量是 <code>foo</code> 类型的。 因为 <code>TypeScript</code> 也使用尖括号来表示类型断言，在结合 <code>JSX</code> 的语法后将带来解析上的困难。因此，<code>TypeScript</code> 在 <code>.tsx</code> 文件里禁用了使用尖括号的类型断言。</p></blockquote><blockquote><p>由于不能够在 <code>.tsx</code> 文件里使用上述语法，因此我们应该使用另一个类型断言操作符：<code>as</code>。</p></blockquote><ul><li>上面的例子可以很容易地使用 <code>as</code> 操作符改写：</li></ul><pre><code class="typescript">var foo = bar as foo;</code></pre><blockquote><p><code>as</code> 操作符在 <code>.ts</code> 和 <code>.tsx</code> 里都可用，并且与尖括号类型断言行为是等价的。</p></blockquote><h3 id="20-4-类型检查"><a href="#20-4-类型检查" class="headerlink" title="20.4 类型检查"></a>20.4 类型检查</h3><blockquote><p>为了理解 <code>JSX</code> 的类型检查，你必须首先理解 <code>固有元素</code> 与 <code>基于值的元素</code> 之间的区别。假设有这样一个 <code>JSX</code> 表达式 <code>&lt;expr /&gt;</code>，<code>expr</code> 可能引用环境自带的某些东西(比如，在 <code>DOM</code> 环境里的 <code>div</code> 或 <code>span</code>)或者是你自定义的组件。这是非常重要的。原因有如下两点：</p></blockquote><ol><li>对于 <code>React</code>，固有元素会生成字符串 (<code>React.createElement(&quot;div&quot;)</code> )，然后由你自定义的组件却不会生成( <code>React.createElement(MyComponent)</code>)。</li><li>传入 <code>JSX</code> 元素里的属性类型的查找方式不同。固有元素总以一个小写字母开头，基于值的元素总是以一个大写字母开头。</li></ol><h4 id="20-4-1-固有元素"><a href="#20-4-1-固有元素" class="headerlink" title="20.4.1 固有元素"></a>20.4.1 固有元素</h4><blockquote><p>固有元素使用特殊的接口 <code>JSX.IntrinsicElements</code> 来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在 <code>JSX.IntrinsicElements</code> 接口的属性里查找。</p></blockquote><ul><li>例如：</li></ul><pre><code class="jsx">declare namespace JSX &#123;    interface IntrinsicElements &#123;        foo: any;    &#125;&#125;&lt;foo /&gt;; // 正确&lt;bar /&gt;; // 错误</code></pre><blockquote><p>在上例中，``没有问题，但是<code>会报错，因为它没在 JSX.IntrinsicElements</code> 里指定。</p></blockquote><blockquote><p>注意：你也可以在 <code>JSX.IntrinsicElements</code> 上指定一个用来捕获所有字符串索引：</p></blockquote><pre><code class="jsx">declare namespace JSX &#123;    interface IntrinsicElements &#123;        [elemName: string]: any;    &#125;&#125;</code></pre><h4 id="20-4-2-基于值的元素"><a href="#20-4-2-基于值的元素" class="headerlink" title="20.4.2 基于值的元素"></a>20.4.2 基于值的元素</h4><blockquote><p>基于值的元素会简单的在它所在的作用域里按标识符查找。</p></blockquote><pre><code class="jsx">import MyComponent from &quot;./myComponent&quot;;&lt;MyComponent /&gt; // 正确&lt;SomeOtherComponent /&gt; // 错误</code></pre><blockquote><p>有两种方式可以定义基于值的元素：</p><ol><li>无状态函数组件 (<code>SFC</code>)</li><li>类组件</li></ol></blockquote><blockquote><p>由于这两种基于值的元素在 <code>JSX</code> 表达式里无法区分，因此 <code>TypeScript</code> 首先会尝试将表达式作为无状态函数组件进行解析。如果解析成功，那么 <code>TypeScript</code> 就完成了表达式到其声明的解析操作。如果按照无状态函数组件解析失败，那么 <code>TypeScript</code> 会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。</p></blockquote><h5 id="1-无状态函数组件"><a href="#1-无状态函数组件" class="headerlink" title="(1) 无状态函数组件"></a>(1) 无状态函数组件</h5><blockquote><p>正如其名，组件被定义成 <code>JavaScript</code> 函数，它的第一个参数是 <code>props</code> 对象。<code>TypeScript</code> 会强制它的返回值可以赋值给 <code>JSX.Element</code>。</p></blockquote><pre><code class="jsx">interface FooProp &#123;    name: string;    X: number;    Y: number;&#125;declare function AnotherComponent(prop: &#123; name: string &#125;);function ComponentFoo(prop: FooProp) &#123;    return &lt;AnotherComponent name=&#123;prop.name&#125; /&gt;&#125;const Button = (prop: &#123; value: string &#125;, context: &#123; color: string &#125;) =&gt; &lt;button&gt;;</code></pre><blockquote><p>由于无状态函数组件是简单的 <code>JavaScript</code> 函数，所以我们还可以利用函数重载。</p></blockquote><pre><code class="jsx">interface ClickableProps &#123;    children: JSX.Element[] | JSX.Element;&#125;interface HomeProps extends ClickableProps &#123;    home: JSX.Element;&#125;interface SlideProps extends ClickableProps &#123;    side: JSX.Element | string;&#125;function MainButton(prop: HomeProps): JSX.Element;function MainButton(prop: SlideProps): JSX.Element &#123;    // ...&#125;</code></pre><h5 id="2-类组件"><a href="#2-类组件" class="headerlink" title="(2) 类组件"></a>(2) 类组件</h5><blockquote><ol><li>我们可以定义类组件的类型。然而，我们首先最好弄懂两个新的术语：<code>元素类的类型</code> 和 <code>元素实例的类型</code>。</li><li>现在有 <code>&lt;Expr /&gt;</code>，元素类的类型为 <code>Expr</code> 的类型。所以在上面的例子里，如果 <code>MyComponent</code> 是 <code>ES6</code> 的类，那么类类型就是类的构造函数和静态部分。如果 <code>MyComponent</code> 是个工厂函数，类类型为这个函数。</li><li>一旦建立起了类类型，实例类型由构造器或调用签名(如果存在的话)的返回值的联合构成。再次说明，在 <code>ES6</code> 类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。</li></ol></blockquote><pre><code class="jsx">class MyComponent &#123;  render() &#123;&#125;&#125;// 使用构造签名var myComponent = new MyComponent();// 元素类的类型 =&gt; MyComponent;// 元素实例的类型 =&gt; &#123; render: () =&gt; void &#125;</code></pre><pre><code class="jsx">function MyFactoryFunction() &#123;  return &#123;    render: () =&gt; &#123;&#125;  &#125;;&#125;// 使用调用签名var myComponent = MyFactoryFunction();// 元素类的类型 =&gt; FactoryFunction// 元素实例的类型 =&gt; &#123; render: () =&gt; void &#125;</code></pre><blockquote><p>元素的实例类型很有趣，因为它必须赋值给 <code>JSX.ElementClass</code> 或 <code>抛出一个错误</code>。默认的 <code>JSX.ElementClass</code> 为 <code>&#123;&#125;</code>，但是它可以被扩展用来限制 <code>JSX</code> 的类型以符合相应的接口。</p></blockquote><pre><code class="jsx">declare namespace JSX &#123;    interface ElementClass &#123;        render: any    &#125;&#125;class MyComponent &#123;    render() &#123;&#125;&#125;function MyFactoryFunction() &#123;    return &#123;        render: () =&gt; &#123;&#125;    &#125;&#125;&lt;MyComponent /&gt;; // 正确&lt;MyFactoryFunction /&gt;; // 正确class NotAValidComponent &#123;&#125;function NotAValidFactoryFunction() &#123;    return &#123;&#125;&#125;&lt;NotAValidComponent /&gt;; // 错误&lt;NotAValidFactoryFunction /&gt;; // 错误</code></pre><h3 id="20-5-属性类型检查"><a href="#20-5-属性类型检查" class="headerlink" title="20.5 属性类型检查"></a>20.5 属性类型检查</h3><ol><li>属性类型检查的第一步是 确定元素类型。这在 <code>固有元素</code> 和 <code>基于值的元素</code> 之间稍有不同。</li><li>对于固有元素，这是 <code>JSX.IntrinsicElements</code> 属性的类型。</li></ol><pre><code class="jsx">declare namespace JSX &#123;    interface IntrinsicElements &#123;        foo: &#123;            bar?: boolean;        &#125;    &#125;&#125;// `foo` 的元素属性类型为 `&#123;bar?: boolean&#125;`&lt;foo bar /&gt;;</code></pre><ol start="3"><li>对于基于值的元素，就稍微复杂些。它取决于先前确定的在元素实例类型上的某个属性的类型。至于该使用哪个属性来确定类型取决于 <code>JSX.ElementAttributesProperty</code>。它应该使用单一的属性来定义。这个属性名之后会被使用。<code>TypeScript 2.8</code>，如果未指定 <code>JSX.ElementAttributesProperty</code>，那么将使用 <code>类元素构造函数</code> 或 <code>SFC</code> 调用的第一个参数类型。</li></ol><pre><code class="jsx">declare namespace JSX &#123;  interface ElementAttributesProperty &#123;      props; // 指定用来使用的属性名  &#125;&#125;class MyComponent &#123;  // 在元素实例上指定类型  props: &#123;      foo?: string;  &#125;&#125;// `MyComponent` 的元素属性类型为 `&#123;foo?: string&#125;`&lt;MyComponent foo=&quot;bar&quot; /&gt;;</code></pre><ol start="4"><li>元素属性类型用于 <code>JSX</code> 里进行属性的类型检查。支持可选属性和必须属性</li></ol><pre><code class="jsx">declare namespace JSX &#123;    interface IntrinsicElements &#123;        foo: &#123;            requiredProp: string;            optionalProp?: number;        &#125;    &#125;&#125;&lt;foo requiredProp=&quot;bar&quot; /&gt;; // 正确&lt;foo requiredProp=&quot;bar&quot; optionalProp=&#123;0&#125; /&gt;; // 正确&lt;foo /&gt;; // 错误，缺少requiredProp&lt;foo requiredProp=&#123;0&#125; /&gt;; // 错误，requiredProp 应该是字符串&lt;foo requiredProp=&quot;bar&quot; unknownProp /&gt;; // 错误，unknownProp 属性不存在&lt;foo requiredProp=&quot;bar&quot; some-unknown-prop /&gt;; // 正确，`some-unknown-prop` 不是合法的标识符</code></pre><blockquote><p>注意：如果一个属性名不是个合法的 <code>JS</code> 标识符(像 <code>data-\*</code> 属性)，并且它没出现在元素属性类型里时不会当作一个错误。</p></blockquote><blockquote><p>另外，<code>JSX</code> 还会使用 <code>JSX.IntrinsicAttributes</code> 接口来指定额外的属性，这些额外的属性通常不会被组件的 <code>props</code> 或 <code>arguments</code> 使用 - 比如 <code>React</code> 里的 <code>key</code>。还有，<code>JSX.IntrinsicClassAttributes&lt;T&gt;</code> 泛型类型也可以用来做同样的事情。这里的泛型参数表示类实例类型。在 <code>React</code> 里，它用来允许 <code>Ref&lt;T&gt;</code> 类型上的 <code>ref</code> 属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个 <code>JSX</code> 标签上都提供一些属性。</p></blockquote><blockquote><p>延展操作符也可以使用</p></blockquote><pre><code class="jsx">var props = &#123; requiredProp: &quot;bar&quot; &#125;; // 正确var badProps = &#123;&#125;;&lt;foo &#123;...badProps&#125; /&gt;; // 错误</code></pre><h3 id="20-6-子孙类型检查"><a href="#20-6-子孙类型检查" class="headerlink" title="20.6 子孙类型检查"></a>20.6 子孙类型检查</h3><blockquote><p>从 <code>TypeScript 2.3</code> 开始，我们引入了 <code>children</code> 类型检查。<code>children</code> 是元素属性(<code>attribute</code>)类型的一个特殊属性(<code>property</code>)，子 <code>JSXExpression</code> 将会被插入到属性里。与使用 <code>JSX.ElementAttributesProperty</code> 来决定 <code>props</code> 名类似，我们可以利用 <code>JSX.ElementChildrenAttribute</code> 来决定 <code>children</code> 名。<code>JSX.ElementChildrenAttribute</code> 应该被声明在单一的属性(<code>property</code>)里。</p></blockquote><pre><code class="typescript">declare namespace JSX &#123;  interface ElementChildrenAttribute &#123;    children: &#123;&#125;; // specify children name to use  &#125;&#125;</code></pre><blockquote><p>如不特殊指定子孙的类型，我们将使用 <code>React typings</code> 里的默认类型</p></blockquote><pre><code class="jsx">&lt;div&gt;  &lt;h1&gt;Hello&lt;/h1&gt;&lt;/div&gt;;&lt;div&gt;  &lt;h1&gt;Hello&lt;/h1&gt;  World&lt;/div&gt;;const CustomComp = (props) =&gt; &lt;div&gt;props.children&lt;/div&gt;&lt;CustomComp&gt;  &lt;div&gt;Hello World&lt;/div&gt;  &#123;&quot;This is just a JS expression...&quot; + 1000&#125;&lt;/CustomComp&gt;</code></pre><pre><code class="jsx">interface PropsType &#123;  children: JSX.Element;  name: string;&#125;class Component extends React.Component&lt;PropsType, &#123;&#125;&gt; &#123;  render() &#123;      return (          &lt;h2&gt;              &#123;this.props.children&#125;          &lt;/h2&gt;      )  &#125;&#125;// Ok&lt;Component&gt;  &lt;h1&gt;Hello World&lt;/h1&gt;&lt;/Component&gt;// Error: children is of type JSX.Element not array of JSX.Element&lt;Component&gt;  &lt;h1&gt;Hello World&lt;/h1&gt;  &lt;h2&gt;Hello World&lt;/h2&gt;&lt;/Component&gt;// Error: children is of type JSX.Element not array of JSX.Element or string.&lt;Component&gt;  &lt;h1&gt;Hello&lt;/h1&gt;  World&lt;/Component&gt;</code></pre><h3 id="20-7-JSX-结果类型"><a href="#20-7-JSX-结果类型" class="headerlink" title="20.7 JSX 结果类型"></a>20.7 JSX 结果类型</h3><blockquote><p>默认地 <code>JSX</code> 表达式结果的类型为 <code>any</code>。你可以自定义这个类型，通过指定 <code>JSX.Element</code> 接口。然而，不能够从接口里检索元素，属性或 <code>JSX</code> 的子元素的类型信息。它是一个黑盒。</p></blockquote><h3 id="20-8-嵌入的表达式"><a href="#20-8-嵌入的表达式" class="headerlink" title="20.8 嵌入的表达式"></a>20.8 嵌入的表达式</h3><blockquote><p><code>JSX</code> 允许你使用 <code>&#123;&#125;</code> 标签来内嵌表达式</p></blockquote><pre><code class="tsx">var a = (  &lt;div&gt;    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(i =&gt; (      &lt;span&gt;&#123;i / 2&#125;&lt;/span&gt;    ))&#125;  &lt;/div&gt;);// 上面的代码产生一个错误，因为你不能用数字来除以一个字符串。输出如下，若你使用了 preserve 选项var a = (  &lt;div&gt;    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(function (i) &#123;      return &lt;span&gt;&#123;i / 2&#125;&lt;/span&gt;;    &#125;)&#125;  &lt;/div&gt;);</code></pre><h3 id="20-9-react-整合"><a href="#20-9-react-整合" class="headerlink" title="20.9 react 整合"></a>20.9 react 整合</h3><blockquote><p>要想一起使用 <code>JSX</code> 和 <code>React</code>，你应该使用 <code>React</code> 类型定义。这些类型声明定义了 <code>JSX</code> 合适命名空间来使用 <code>React</code>。</p></blockquote><pre><code class="jsx">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;interface Props &#123;  foo: string;&#125;class MyComponent extends React.Component&lt;Props, &#123;&#125;&gt; &#123;  render() &#123;    return &lt;span&gt;&#123;this.props.foo&#125;&lt;/span&gt;;  &#125;&#125;&lt;MyComponent foo=&quot;bar&quot; /&gt;; // 正确&lt;MyComponent foo=&#123;0&#125; /&gt;; // 错误</code></pre><h3 id="20-10-工厂函数"><a href="#20-10-工厂函数" class="headerlink" title="20.10 工厂函数"></a>20.10 工厂函数</h3><blockquote><p><code>jsx</code>：<code>react</code> 编译选项使用的工厂函数是可以配置的。可以使用 <code>jsxFactory</code> 命令行选项，或内联的 <code>@jsx</code> 注释指令在每个文件上设置。比如，给 <code>createElement</code> 设置 <code>jsxFactory</code>，<code>&lt;div /&gt;</code> 会使用 <code>createElement(&quot;div&quot;)</code> 来生成，而不是 <code>React.createElement(&quot;div&quot;)</code>。</p></blockquote><pre><code class="jsx">// 注释指令可以像下面这样使用：(在 TypeScript 2.8 里)import preact = require(&quot;preact&quot;);/* @jsx preact.h */const x = &lt;div/&gt;;// 生成const preact = require(&quot;preact&quot;);const x = preact.h(&quot;div&quot;, null);</code></pre><blockquote><p>工厂函数的选择同样会影响 <code>JSX</code> 命名空间的查找(类型检查)。如果工厂函数使用 <code>React.createElement</code> 定义(默认)，编译器会先检查 <code>React.JSX</code>，之后才检查全局的 <code>JSX</code>。如果工厂函数定义为 <code>h</code>，那么在检查全局的 <code>JSX</code> 之前先检查 <code>h.JSX</code>。</p></blockquote><h2 id="二十一、装饰器"><a href="#二十一、装饰器" class="headerlink" title="二十一、装饰器"></a>二十一、装饰器</h2><h3 id="21-1-介绍"><a href="#21-1-介绍" class="headerlink" title="21.1 介绍"></a>21.1 介绍</h3><blockquote><p>随着 <code>TypeScript</code> 和 <code>ES6</code> 里引入了类，在一些场景下我们需要额外的特定来支持标注或修改类及其成员。装饰器(<code>Decorators</code>)为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。<code>JavaScript</code> 里的装饰器目前处在 建议征集的第二阶段，但在 <code>TypeScript</code> 里已作为一项实验性特性予以支持。<br>注意：装饰器是一项实验性特性，在未来的版本中可能会发生改变<br>若要启用实验性的装饰器特性，你必须在命令行或 <code>tsconfig.json</code> 里启用 <code>experimentalDecorators</code> 编译器选项。<br>命令行： <code>tsc --target ES5 --experimentalDecorators</code></p></blockquote><ul><li>tsconfig.json</li></ul><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ES5&quot;,    &quot;experimentalDecorators&quot;: true  &#125;&#125;</code></pre><h3 id="21-2-装饰器"><a href="#21-2-装饰器" class="headerlink" title="21.2 装饰器"></a>21.2 装饰器</h3><blockquote><p>装饰器是一种特殊的声明，它能够被附加到 <code>类声明</code>、<code>方法</code>、<code>访问符</code>、<code>属性或参数上</code>。装饰器使用 <code>@expression</code> 这种形式，<code>expression</code> 求值后必须为一个函数，它会在运行时被调用，被装饰器的声明信息作为参数传入。<br>例如，有一个 <code>@sealed</code> 装饰器，我们会这样定义 <code>sealed</code> 函数</p></blockquote><pre><code class="typescript">function sealed(target) &#123;  // do something with target&#125;</code></pre><blockquote><p>注意：后面类装饰器小节里有一个更加详细的例子。</p></blockquote><h3 id="21-3-装饰器工厂"><a href="#21-3-装饰器工厂" class="headerlink" title="21.3 装饰器工厂"></a>21.3 装饰器工厂</h3><blockquote><p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p></blockquote><ul><li>我们可以通过下面的方式来写一个装饰器工厂函数：</li></ul><pre><code class="typescript">function color(value: string) &#123;  // 这是一个装饰器工厂  return function (target) &#123;    // 这是装饰器    // do something with &quot;target&quot; and &quot;value&quot; ...  &#125;;&#125;</code></pre><blockquote><p>注意：下面方法装饰器小节里有一个更加详细的例子。</p></blockquote><h3 id="21-4-装饰器组合"><a href="#21-4-装饰器组合" class="headerlink" title="21.4 装饰器组合"></a>21.4 装饰器组合</h3><blockquote><p>多个装饰器可以同时应用到一个声明上，就像下面的实例：</p></blockquote><ol><li>书写在同一行：</li></ol><pre><code class="typescript">@f @g x</code></pre><ol start="2"><li>书写在多行上：</li></ol><pre><code class="typescript">@f@gx</code></pre><blockquote><p>当多个装饰器应用于一个声明上，它们求值方式与 复合函数 相似。在这个模型下，当复合 f 和 g 时，复合的结果 <code>\(f∘g\)\(x\)</code> 等同于 <code>f\(g\(x\)\)</code>。</p></blockquote><blockquote><p>同样的，在 <code>TypeScript</code> 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作： <code>1</code>. 由上至下依次对装饰器表达式求值 <code>2</code>. 求值的结果会被当作函数，由下至上依次被调用。</p></blockquote><pre><code class="typescript">// 如果我们使用 装饰器工厂 的话，可以通过下面的例子来观察它们求值的顺序：function f() &#123;  console.log(&quot;f(): evaluated&quot;);  return function (target, prototypeKey: string, descriptor: PropertyDescriptor) &#123;    console.log(&quot;f(): called&quot;);  &#125;;&#125;function g() &#123;  console.log(&quot;g(): evaluated&quot;);  return function (target, prototypeKey: string, descriptor: PropertyDescriptor) &#123;    console.log(&quot;g(): called&quot;);  &#125;;&#125;class C &#123;  @f()  @g()  method() &#123;&#125;&#125;</code></pre><pre><code class="typescript">// 在控制台里会打印出如下结果：f(): evaluatedg(): evaluatedg(): calledf(): called</code></pre><h3 id="21-5-装饰器求值"><a href="#21-5-装饰器求值" class="headerlink" title="21.5 装饰器求值"></a>21.5 装饰器求值</h3><blockquote><p>类中不同声明上的装饰器将按以下规定的顺序应用：</p></blockquote><ul><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li><li>参数装饰器应用到构造函数。</li><li>类装饰器应用到类。</li></ul><h3 id="21-6-类装饰器"><a href="#21-6-类装饰器" class="headerlink" title="21.6 类装饰器"></a>21.6 类装饰器</h3><p>1.类装饰器在类声明之前被声明(紧靠着类声明)。类装饰器应用于类构造函数，可以用来监视修改或替换类定义。类装饰器不能用在声明文件中( <code>.d.ts</code> )，也不能用在任何外部上下文中(比如 <code>declare</code> 的类)。</p><ol start="2"><li>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</li><li>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</li></ol><blockquote><p>注意：如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中 不会为你做这些。<br>下面是使用类装饰器( <code>@sealed</code> )的例子，应用在 <code>Greeter</code> 类：</p></blockquote><pre><code class="typescript">@sealedclass Greeter1 &#123;  greeting: string;  constructor(message: string) &#123;    this.greeting = message;  &#125;  greet() &#123;    return &quot;Hello, &quot; + this.greeting;  &#125;&#125;// 我们可以这样定义 @sealed 装饰器function sealed(constructor: Function) &#123;  Object.seal(constructor);  Object.seal(constructor.prototype);&#125;</code></pre><blockquote><p>当 <code>@sealed</code> 被执行的时候，它将密闭此类的构造函数和原型。(注：参见 <code>Object.seal</code> )</p></blockquote><ul><li>下面是一个重载构造函数的例子：</li></ul><pre><code class="typescript">function classDecorator&lt;T extends &#123; new (...args: any[]): &#123;&#125; &#125;&gt;(constructor: T) &#123;  return class extends constructor &#123;    newProperty = &quot;new property&quot;;    hello = &quot;override&quot;;  &#125;;&#125;@classDecoratorclass Greeter2 &#123;  property = &quot;property&quot;;  hello: string;  constructor(m: string) &#123;    this.hello = m;  &#125;&#125;console.log(new Greeter2(&quot;world&quot;));</code></pre><h3 id="21-7-方法装饰器"><a href="#21-7-方法装饰器" class="headerlink" title="21.7 方法装饰器"></a>21.7 方法装饰器</h3><blockquote><p>方法装饰器声明在一个方法的声明之前(紧靠着方法声明)。它会被应用到方法的 <code>属性描述符</code> 上，可以用来监视，修改或者替换方法定义。方法装饰器不能用在声明文件 <code>.d.ts</code> 上，重载或者任何外部上下文(比如 <code>declare</code> 的类)中。</p></blockquote><blockquote><p>方法装饰器表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字</li><li>成员的属性修饰符</li></ol></blockquote><blockquote><p>注意：如果代码输出目标代码小于 <code>ES5</code>，属性描述符 将会是 <code>undefined</code>。</p></blockquote><blockquote><p>如果方法装饰器返回一个值，它会被用作方法的 属性描述符。</p></blockquote><blockquote><p>注意：如果代码输出目标版本小于 <code>ES5</code>，返回值会被忽略。</p></blockquote><ul><li>下面是一个方法装饰器 (<code>@enumerable</code>) 的例子，应用于 <code>Greeter</code> 类的方法上。</li></ul><pre><code class="typescript">class Greeter &#123;  greeting: string;  constructor(message: string) &#123;    this.greeting = message;  &#125;  @enumerable(false)  greet() &#123;    return &quot;Hello, &quot; + this.greeting;  &#125;&#125;</code></pre><ul><li>我们可以用下面的函数声明来定义 <code>@enumerable</code> 装饰器：</li></ul><pre><code class="typescript">function enumerable(value: boolean) &#123;  return function (target: any, property: string, descriptor: PropertyDescriptor) &#123;    descriptor.enumerable = value;  &#125;;&#125;</code></pre><blockquote><p>这里的 <code>@enumerable(false)</code> 是一个装饰器工厂，当装饰器 <code>@enumerable(false)</code> 被调用时，它会修改属性描述符的 <code>enumerable</code> 属性。</p></blockquote><h3 id="21-8-访问器装饰器"><a href="#21-8-访问器装饰器" class="headerlink" title="21.8 访问器装饰器"></a>21.8 访问器装饰器</h3><blockquote><p>访问器装饰器声明在一个访问器的声明之前(紧靠着访问器声明)。访问器装饰器 应用于访问器的 <code>属性描述符</code> 并且可以用来监视，修改或替换一个访问器的定义。访问器装饰器不能用在声明文件中( <code>.d.ts</code> )，或者任何外部上下文(比如 <code>declare</code> 的类)里。</p></blockquote><blockquote><p>注意：<code>TypeScript</code> 不允许同时装饰一个成员的 <code>get</code> 和 <code>set</code> 访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了 <code>get</code> 和 <code>set</code> 访问器，而不是分开声明的。</p></blockquote><blockquote><p>访问器装饰器表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。</li><li>成员的名字</li><li>成员的属性描述符</li></ol></blockquote><blockquote><p>注意：如果代码输出目标版本小于 <code>ES5</code>，<code>Property Descriptor</code> 将会是 <code>undefined</code>。</p></blockquote><blockquote><p>如果访问器装饰器返回一个值，它会被用作方法的 <code>属性描述符</code> 注意：如果代码输出目标版本小于 <code>ES5</code> 返回值会被忽略。</p></blockquote><ul><li>下面是使用了访问器装饰器 (<code>@configurable</code>) 的例子，应用于 <code>Point</code> 类的成员上。</li></ul><pre><code class="typescript">class Point &#123;  private _x: number;  private _y: number;  constructor(x: number, y: number) &#123;    this._x = x;    this._y = y;  &#125;  @configurable(false)  get x() &#123;    return this._x;  &#125;  @configurable(false)  get y() &#123;    return this._y;  &#125;&#125;let p: Point = new Point(1, 2);console.log(p);</code></pre><ul><li>我们可以通过如下函数声明来定义 <code>@configurable</code> 装饰器：</li></ul><pre><code class="typescript">function configurable(value: boolean) &#123;  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;    descriptor.configurable = value;  &#125;;&#125;</code></pre><h3 id="21-9-属性装饰器"><a href="#21-9-属性装饰器" class="headerlink" title="21.9 属性装饰器"></a>21.9 属性装饰器</h3><blockquote><p>属性装饰器声明在一个属性声明之前(紧靠着属性声明)。属性装饰器不能用在声明文件中（<code>.d.ts</code>），或者任何外部上下文（比如 <code>declare</code> 的类）里。</p></blockquote><blockquote><p>属性装饰器表达式会在运行时当作函数被调用，传入下列 <code>2</code> 个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字。</li></ol></blockquote><blockquote><p>注意：<code>属性描述符</code> 不会作为参数传入属性装饰器，这与 <code>TypeScript</code> 是如何初始化属性装饰器有关。因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p></blockquote><ul><li>我们可以用它来记录这个属性的元数据，如下例所示：</li></ul><pre><code class="typescript">class Greeter &#123;    @format(&quot;Hello, %s&quot;)    greeting: string;&gt;    constructor(message: string) &#123;        this.greeting = message;    &#125;&gt;    greet() &#123;        let formatString = getFormat(this, &quot;greeting&quot;);        return formatString.replace(&quot;%s&quot;, this.greeting);    &#125;&#125;&gt;let g: Greeter = new Greeter(&quot;鼓励&quot;);console.log(g);&gt;// 然后定义 @format 装饰器 和 getFormat 函数import &quot;reflect-metadata&quot;;&gt;const formatMetadataKey = Symbol(&quot;format&quot;);&gt;function format(formatString: string) &#123;    return Reflect.metadata(formatMetadataKey, formatString);&#125;&gt;function getFormat(target: any, propertyKey: string) &#123;    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);&#125;</code></pre><blockquote><p>这个 <code>@format(&quot;Hello, %s&quot;)</code> 装饰器是个 <code>装饰器工厂</code>。当 <code>@format(&quot;Hello, %s&quot;)</code> 被调用时，它添加一条这个属性的元数据，通过 <code>reflect-metadata</code> 库里的 <code>Reflect.metadata</code> 函数。当 <code>getFormat</code> 被调用时，它读取格式的元数据。</p></blockquote><blockquote><p>注意：这个例子需要使用 <code>reflect-metadata</code> 库。查看 元数据 了解 <code>reflect-metadata</code> 库更详细的信息。</p></blockquote><h3 id="21-10-参数装饰器"><a href="#21-10-参数装饰器" class="headerlink" title="21.10 参数装饰器"></a>21.10 参数装饰器</h3><blockquote><p><code>参数装饰器</code> 声明在一个参数声明之前(紧靠着参数声明)。参数装饰器应用于 <code>类构造函数</code> 或 <code>方法声明</code>。参数装饰器 不能用在声明文件（<code>.d.ts</code>），重载或其它外部上下文（比如 <code>declare</code> 的类）里。<br><code>参数装饰器</code> 表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p><ol><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li><li>成员的名字</li><li>参数在函数参数列表的索引</li></ol></blockquote><blockquote><p>注意：参数装饰器只能用来监视一个方法的参数是否被传入。</p></blockquote><blockquote><p>参数装饰器的返回值会被忽略</p></blockquote><ul><li>下面定义了参数装饰器( <code>@required</code> )并应用于 <code>Greeter</code> 类方法的一个参数：</li></ul><pre><code class="typescript">class Greeter &#123;  greeting: string;  constructor(message: string) &#123;    this.greeting = message;  &#125;  @validate  greet(@required name: string) &#123;    return &quot;Hello &quot; + name + &quot;, &quot; + this.greeting;  &#125;&#125;</code></pre><ul><li>然后我们使用下面的函数定义 <code>@required</code> 和 <code>@validate</code> 装饰器</li></ul><pre><code class="typescript">import &quot;reflect-metadata&quot;;const requiredMetadataKey = Symbol(&quot;required&quot;);function required(target: Object, propertyKey: string | symbol, parameterIndex: number) &#123;  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];  existingRequiredParameters.push(parameterIndex);  Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);&#125;function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&lt;Function&gt;) &#123;  let method = descriptor.value;  descriptor.value = function () &#123;    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);    if (requiredParameters) &#123;      for (let parameterIndex of requiredParameters) &#123;        if (parameterIndex &gt;= arguments.length || arguments[parameterIndex] === undefined) &#123;          throw new Error(&quot;Missing required argument.&quot;);        &#125;      &#125;    &#125;    return method.apply(this, arguments);  &#125;;&#125;</code></pre><blockquote><p><code>@required</code> 装饰器添加了元数据实体把参数标记为必须的。<br><code>@validate</code> 装饰器把 <code>greet</code> 方法包裹在一个函数里，在调用原先的函数前验证函数参数。<br><code>注意：</code>这个例子使用了 <code>reflect-metadata</code> 库。 查看 元数据 了解 <code>reflect-metadata</code> 库的更多信息。</p></blockquote><h3 id="21-11-元数据"><a href="#21-11-元数据" class="headerlink" title="21.11 元数据"></a>21.11 元数据</h3><blockquote><p>一部分例子使用了 <code>reflect-metadata</code> 库来支持实现性的 <code>metadata API</code>。这个库还不是 <code>ECMAScript\( JavaScript \)</code> 标准的一部分。然而，当装饰器被 <code>ECMAScript</code> 官方标准采纳后，这些扩展也将被推荐给 <code>ECMAScript</code> 以采纳。</p></blockquote><ul><li>你可以通过 <code>npm</code> 安装这个库</li></ul><pre><code class="bash">npm i reflect-metadata --save</code></pre><blockquote><p><code>TypeScript</code> 支持为带有装饰器的声明生成元数据。你需要在 <code>命令行</code> 或 <code>tsconfig.json</code> 里启用 <code>emitDecoratorMetadata</code> 编译器选项。</p></blockquote><ul><li>命令行：</li></ul><pre><code class="bash">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</code></pre><ul><li><code>tsconfig.json</code></li></ul><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ES5&quot;,    &quot;experimentalDecorators&quot;: true,    &quot;emitDecoratorMetadata&quot;: true  &#125;&#125;</code></pre><blockquote><p>当启用了，只要 <code>reflect-metadata</code> 库被引入了，设计阶段添加的类型信息可以在运行时使用。</p></blockquote><ul><li>如下例所示：</li></ul><pre><code class="typescript">import &quot;reflect-metadata&quot;;class Point &#123;  x: number;  y: number;&#125;class Line &#123;  private _p0: Point;  private _p1: Point;  @validate  set p0(value: Point) &#123;    this._p0 = value;  &#125;  get p0() &#123;    return this._p0;  &#125;  @validate  set p1(value: Point) &#123;    this._p1 = value;  &#125;  get p1() &#123;    return this._p1;  &#125;&#125;function validate&lt;T&gt;(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;T&gt;) &#123;  let set = descriptor.set;  descriptor.set = function (value: T) &#123;    let type = Reflect.getMetadata(&quot;design:type&quot;, target, propertyKey);    if (!(value instanceof type)) &#123;      throw new TypeError(&quot;Invalid type.&quot;);    &#125;    set(value);  &#125;;&#125;</code></pre><ul><li><code>TypeScript</code> 编译器可以通过 <code>@Reflect.metadata</code> 装饰器注入设计阶段的类型信息。你可以认为它相当于下面的 <code>TypeScript：</code></li></ul><pre><code class="typescript">class Line1 &#123;  private _p0: Point;  private _p1: Point;  @validate  @Reflect.metadata(&quot;design:type&quot;, Point)  set p0(value: Point) &#123;    this._p0 = value;  &#125;  get p0() &#123;    return this._p0;  &#125;  @validate  @Reflect.metadata(&quot;design:type&quot;, Point)  set p1(value: Point) &#123;    this._p1 = value;  &#125;  get p1() &#123;    return this._p1;  &#125;&#125;</code></pre><blockquote><p>注意： 装饰器元数据是个实验性的特性并且可能在以后的版本中发声破坏性的改变。</p></blockquote><h3 id="21-12-Reflect-metadata-库"><a href="#21-12-Reflect-metadata-库" class="headerlink" title="21.12 Reflect-metadata 库"></a>21.12 Reflect-metadata 库</h3><pre><code class="typescript">namespace Reflect &#123;    // 用于装饰器    metadata(k, v): (target, property?) =&gt; void    // 在对象上面定义元数据    defineMetadata(k, v, o, p?): void    // 是否存在元数据    hasMetadata(k, o, p?): boolean    hasOwnMetadata(k, o, p?): boolean    // 获取元数据    getMetadata(k, o, p?): any    getOwnMetadata(k, o, p?): any    // 获取所有元数据的 Key    getMetadataKeys(o, p?): any[]    getOwnMetadataKeys(o, p?): any[]    // 删除元数据    deleteMetadata(k, o, p?): boolean&#125;</code></pre><h4 id="21-12-1-安装"><a href="#21-12-1-安装" class="headerlink" title="21.12.1 安装"></a>21.12.1 安装</h4><h5 id="Metadata-Reflection-API"><a href="#Metadata-Reflection-API" class="headerlink" title="Metadata Reflection API"></a>Metadata Reflection API</h5><ul><li><a href="%5Bhttps://rbuckton.github.io/reflect-metadata%5D(https://rbuckton.github.io/reflect-metadata)">Detailed proposal</a></li></ul><ol><li>Installation</li></ol><pre><code class="bash">npm install reflect-metadata</code></pre><ol start="2"><li>Background</li></ol><ul><li>Decorators add the ability to augment a class and its members as the class is defined, through a declarative syntax.</li><li>Traceur attaches annotations to a static property on the class.</li><li>Languages like C# (.NET), and Java support attributes or annotations that add metadata to types, along with a reflective API for reading metadata.</li></ul><ol start="3"><li>Goals</li></ol><ul><li>A number of use cases (Composition/Dependency Injection, Runtime Type Assertions, Reflection/Mirroring, Testing) want the ability to add additional metadata to a class in a consistent manner.</li><li>A consistent approach is needed for various tools and libraries to be able to reason over metadata.</li><li>Metadata-producing decorators (nee. &quot;Annotations&quot;) need to be generally composable with mutating decorators.</li><li>Metadata should be available not only on an object but also through a Proxy, with related traps.</li><li>Defining new metadata-producing decorators should not be arduous or over-complex for a developer.</li><li>Metadata should be consistent with other language and runtime features of ECMAScript.</li></ul><ol start="4"><li>Syntax</li></ol><ul><li>Declarative definition of metadata:</li></ul><pre><code class="javascript">class C &#123;  @Reflect.metadata(metadataKey, metadataValue)  method() &#123;&#125;&#125;</code></pre><ul><li>Imperative definition of metadata:</li></ul><pre><code class="javascript">Reflect.defineMetadata(metadataKey, metadataValue, C.prototype, &quot;method&quot;);</code></pre><ul><li>Imperative introspection of metadata:</li></ul><pre><code class="javascript">let obj = new C();let metadataValue = Reflect.getMetadata(metadataKey, obj, &quot;method&quot;);</code></pre><ol start="5"><li>Semantics</li></ol><ul><li>Object has a new [[Metadata]] internal property that will contain a Map whose keys are property keys (or <code>undefined</code> ) and whose values are Maps of metadata keys to metadata values.</li><li>Object will have a number of new internal methods for [[DefineOwnMetadata]], [[GetOwnMetadata]], [[HasOwnMetadata]], etc.<ul><li>These internal methods can be overridden by a Proxy to support additional traps.</li><li>These internal methods will by default call a set of abstract operations to define and read metadata.</li></ul></li><li>The Reflect object will expose the MOP operations to allow imperative access to metadata.</li><li>Metadata defined on class declaration <em>C</em> is stored in <em>C</em>.[[Metadata]], with <code>undefined</code> as the key.</li><li>Metadata defined on static members of class declaration <em>C</em> are stored in <em>C</em>.[[Metadata]], with the property key as the key.</li><li>Metadata defined on instance members of class declaration <em>C</em> are stored in <em>C</em>.prototype.[[Metadata]], with the property key as the key.</li></ul><ol><li>API</li></ol><pre><code class="javascript">// define metadata on an object or propertyReflect.defineMetadata(metadataKey, metadataValue, target);Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);// check for presence of a metadata key on the prototype chain of an object or propertylet result = Reflect.hasMetadata(metadataKey, target);let result = Reflect.hasMetadata(metadataKey, target, propertyKey);// check for presence of an own metadata key of an object or propertylet result = Reflect.hasOwnMetadata(metadataKey, target);let result = Reflect.hasOwnMetadata(metadataKey, target, propertyKey);// get metadata value of a metadata key on the prototype chain of an object or propertylet result = Reflect.getMetadata(metadataKey, target);let result = Reflect.getMetadata(metadataKey, target, propertyKey);// get metadata value of an own metadata key of an object or propertylet result = Reflect.getOwnMetadata(metadataKey, target);let result = Reflect.getOwnMetadata(metadataKey, target, propertyKey);// get all metadata keys on the prototype chain of an object or propertylet result = Reflect.getMetadataKeys(target);let result = Reflect.getMetadataKeys(target, propertyKey);// get all own metadata keys of an object or propertylet result = Reflect.getOwnMetadataKeys(target);let result = Reflect.getOwnMetadataKeys(target, propertyKey);// delete metadata from an object or propertylet result = Reflect.deleteMetadata(metadataKey, target);let result = Reflect.deleteMetadata(metadataKey, target, propertyKey);// apply metadata via a decorator to a constructor@Reflect.metadata(metadataKey, metadataValue)class C &#123;  // apply metadata via a decorator to a method (property)  @Reflect.metadata(metadataKey, metadataValue)  method() &#123;&#125;&#125;</code></pre><ol start="7"><li>Alternatives</li></ol><ul><li>Use properties rather than a separate API.<ul><li>Obvious downside is that this can be a lot of code:</li></ul></li></ul><pre><code class="javascript">function ParamTypes(...types) &#123;  return (target, propertyKey) =&gt; &#123;    const symParamTypes = Symbol.for(&quot;design:paramtypes&quot;);    if (propertyKey === undefined) &#123;      target[symParamTypes] = types;    &#125; else &#123;      const symProperties = Symbol.for(&quot;design:properties&quot;);      let properties, property;      if (Object.prototype.hasOwnProperty.call(target, symProperties)) &#123;        properties = target[symProperties];      &#125; else &#123;        properties = target[symProperties] = &#123;&#125;;      &#125;      if (Object.prototype.hasOwnProperty.call(properties, propertyKey)) &#123;        property = properties[propertyKey];      &#125; else &#123;        property = properties[propertyKey] = &#123;&#125;;      &#125;      property[symParamTypes] = types;    &#125;  &#125;;&#125;</code></pre><ol start="8"><li>Notes</li></ol><ul><li>Though it may seem counterintuitive, the methods on Reflect place the parameters for the metadata key and metadata value before the target or property key. This is due to the fact that the property key is the only optional parameter in the argument list. This also makes the methods easier to curry with Function#bind. This also helps reduce the overall footprint and complexity of a metadata-producing decorator that could target both a class or a property:</li></ul><pre><code class="javascript">function ParamTypes(...types) &#123;  // as propertyKey is effectively optional, its easier to use here  return (target, propertyKey) =&gt; &#123;    Reflect.defineMetadata(&quot;design:paramtypes&quot;, types, target, propertyKey);  &#125;;  // vs. having multiple overloads with the target and key in the front:  //  // return (target, propertyKey) =&gt; &#123;  //    if (propertyKey === undefined) &#123;  //      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);  //    &#125;  //    else &#123;  //      Reflect.defineMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);  //    &#125;  // &#125;  //  // vs. having a different methods for the class or a property:  //  // return (target, propertyKey) =&gt; &#123;  //    if (propertyKey === undefined) &#123;  //      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);  //    &#125;  //    else &#123;  //      Reflect.definePropertyMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);  //    &#125;  // &#125;&#125;</code></pre><ul><li>To enable experimental support for metadata decorators in your TypeScript project, you must add <code>&quot;experimentalDecorators&quot;: true</code> to your tsconfig.json file.</li><li>To enable experimental support for auto-generated type metadata in your TypeScript project, you must add <code>&quot;emitDecoratorMetadata&quot;: true</code> to your tsconfig.json file.<ul><li>Please note that auto-generated type metadata may have issues with circular or forward references for types.</li></ul></li></ul><ol start="9"><li>Issues</li></ol><ul><li>A poorly written mutating decorator for a class constructor could cause metadata to become lost if the prototype chain is not maintained. Though, not maintaining the prototype chain in a mutating decorator for a class constructor would have other negative side effects as well. <a href="/rbuckton">@rbuckton </a><ul><li>This is mitigated if the mutating decorator returns a class expression that extends from the target, or returns a proxy for the decorator. <a href="/rbuckton">@rbuckton </a></li></ul></li><li>Metadata for a method is attached to the class (or prototype) via the property key. It would not then be available if trying to read metadata on the function of the method (e.g. &quot;tearing-off&quot; the method from the class). <a href="/rbuckton">@rbuckton </a></li></ul><h2 id="二十二、Mixins-混入"><a href="#二十二、Mixins-混入" class="headerlink" title="二十二、Mixins 混入"></a>二十二、Mixins 混入</h2><h3 id="22-1-介绍"><a href="#22-1-介绍" class="headerlink" title="22.1 介绍"></a>22.1 介绍</h3><blockquote><p>除了传统的面向对象继承方式，还流行一种通用可重用组件创建类的方式，就是联合另一个简单类的代码。<br>你可能在 <code>Scala</code> 等语言里对 <code>mixins</code> 及其特性已经很熟悉了，但它在 <code>JavaScript</code> 中也是很流行的。</p></blockquote><h3 id="22-2-混入示例"><a href="#22-2-混入示例" class="headerlink" title="22.2 混入示例"></a>22.2 混入示例</h3><blockquote><p>下面的代码演示了如何在 <code>TypeScript</code> 里使用混入。后面我们还会解释这段代码是如何工作的。</p></blockquote><pre><code class="typescript">// Disposable Mixinclass Disposable &#123;  isDisposed: boolean;  dispose() &#123;    this.isDisposed = true;  &#125;&#125;// Activatable Mixinclass Activatable &#123;  isActive: boolean;  activate() &#123;    this.isActive = true;  &#125;  deactivate() &#123;    this.isActive = false;  &#125;&#125;class SmartObject implements Disposable, Activatable &#123;  constructor() &#123;    setInterval(() =&gt; console.log(this.isActive + &quot;:&quot; + this.isDisposed), 500);  &#125;  interact() &#123;    this.activate();  &#125;  // Disposable  isDisposed: boolean = false;  dispose: () =&gt; void;  // Activatable  isActive: boolean = false;  activate: () =&gt; void;  deactivate: () =&gt; void;&#125;applyMixins(SmartObject, [Disposable, Activatable]);let smartObj = new SmartObject();setTimeout(() =&gt; smartObj.interact(), 1000);////////////////////////////////////////// In your runtime library somewhere////////////////////////////////////////function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;  baseCtors.forEach(baseCtor =&gt; &#123;    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123;      derivedCtor.prototype[name] = baseCtor.prototype[name];    &#125;);  &#125;);&#125;</code></pre><h3 id="22-3-理解这个例子"><a href="#22-3-理解这个例子" class="headerlink" title="22.3 理解这个例子"></a>22.3 理解这个例子</h3><ol><li>代码里首先定义了两个类，它们将做为 <code>mixins</code>。可以看到每个类都只定义了一个特定的行为或功能。稍后我们使用它们来创建一个新类，同时具有这两种功能。</li></ol><pre><code class="typescript">// Disposable Mixinclass Disponsable &#123;  isDisponsed: boolean;  dispose() &#123;    this.isDisponsed = true;  &#125;&#125;// Activatable Mixinclass Activatable &#123;  isActive: boolean;  activate() &#123;    this.isActive = true;  &#125;  deactivate() &#123;    this.isActive = false;  &#125;&#125;</code></pre><ol start="2"><li>下面创建一个类，结合了这两个 <code>mixins</code>。 下面来看一下具体是怎么操作的：</li></ol><pre><code class="typescript">class SmartObject implements Disposable, Activatable &#123;&#125;</code></pre><ol start="3"><li>首先应该注意到的是，没使用 <code>extends</code> 而是使用 <code>implements</code>。 把类当成了接口，仅使用 <code>Disposable</code> 和 <code>Activatable</code> 的类型而非其实现。 这意味着我们需要在类里面实现接口。但是这是我们在用 <code>mixin</code> 时想避免的。</li><li>我们可以这么做来达到目的，为将要 <code>mixin</code> 进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。 这样就能使用 <code>mixin</code> 带来的便利，虽说需要提前定义一些占位属性。</li></ol><pre><code class="typescript">// Disposable  isDisposed: boolean = false;  dispose: () =&gt; void;// Activatable  isActive: boolean = false;  activate: () =&gt; void;  deactivate: () =&gt; void;</code></pre><ol start="5"><li>最后，把 <code>mixins</code> 混入定义的类，完成全部实现部分。</li></ol><pre><code class="typescript">applyMixins(SmartObject, [Disposable, Activatable]);</code></pre><ol start="6"><li>最后，创建这个帮助函数，帮我们做混入操作。 它会遍历 <code>mixins</code> 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</li></ol><pre><code class="typescript">function applyMixins(derivedCtor: any, baseCtors: any[]) &#123;  baseCtors.forEach(baseCtor =&gt; &#123;    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; &#123;      derivedCtor.prototype[name] = baseCtor.prototype[name];    &#125;);  &#125;);&#125;</code></pre><h2 id="二十三、三斜线指令"><a href="#二十三、三斜线指令" class="headerlink" title="二十三、三斜线指令"></a>二十三、三斜线指令</h2><ul><li>三斜线指令是包含单个 <code>XML</code> 标签的单行注释。注释内容会做为编译器指令使用。</li><li>三斜线指令仅可放在包含它的文件最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当作普通的单行注释，并且不具有特殊的含义。</li></ul><pre><code class="typescript">/// &lt;reference path=&quot;...&quot; /&gt;/// &lt;reference path=&quot;...&quot; /&gt; 指令是三斜线指令中最常见的一种。 它用于声明文件间的 依赖。</code></pre><ul><li>三斜线引用告诉编译器在编译过程中要引入的额外文件。</li><li>当使用 <code>--out</code> 或 <code>--outFile</code> 时，它也可以做为调整输出内容顺序的一种方法。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。</li></ul><h3 id="23-1-预处理输入文件"><a href="#23-1-预处理输入文件" class="headerlink" title="23.1 预处理输入文件"></a>23.1 预处理输入文件</h3><blockquote><p>编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中。<br>这个过程会以一些根文件开始；它们是在命令行中指定的文件或是在 <code>tsconfig.json</code> 中的 <code>&quot;files&quot;</code> 列表里的文件。这些根文件按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。<br>  一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。</p></blockquote><h3 id="23-2-错误"><a href="#23-2-错误" class="headerlink" title="23.2 错误"></a>23.2 错误</h3><blockquote><p>引用不存在的文件会报错。一个文件用三斜线指令引用自己会报错。</p></blockquote><h3 id="23-3-使用-noResolve"><a href="#23-3-使用-noResolve" class="headerlink" title="23.3 使用 --noResolve"></a>23.3 使用 <code>--noResolve</code></h3><blockquote><p>如果指定了 <code>--noResolve</code> 编译选项，三斜线指令会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p></blockquote><pre><code class="typescript">/// &lt;reference types=&quot;...&quot; /&gt;</code></pre><ul><li>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的；一个 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 指令则声明了对某个包的依赖。</li><li>对这些包的名字的解析与在 <code>import</code> 语句里对模块名的解析类似。可以简单地把三斜线类型引用指令当做 <code>import</code> 声明的包。</li><li>例如，把 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>引入到声明文件，表明这个文件使用了<code>@types/node/index.d.ts</code> 里面声明的名字；并且，这个包需要在编译阶段与声明文件一起被包含进来。</li><li>仅当在你需要写一个 <code>.d.ts</code> 文件时才使用这个指令。</li><li>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>；当且仅当结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</li><li>若要在 <code>.ts</code> 文件里声明一个对 <code>@types</code> 包的依赖，使用 <code>--types</code> 命令行选项 或在 <code>tsconfig.json</code> 里指定。查看 在 <code>tsconfig.json</code> 里使用 <code>@types</code>，<code>typeRoots</code> 和 <code>types</code> 了解详情。</li><li><code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 这个指令把一个文件标记成默认库。你会在 <code>lib.d.ts</code> 文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，<code>lib.d.ts</code>）。 这与在命令行上使用 -<code>-noLib</code> 相似。</li><li>还要注意，当传递了 <code>--skipDefaultLibCheck</code> 时，编译器只会忽略检查带有 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 的文件。</li></ul><h3 id="23-4-lt-amd-module-gt"><a href="#23-4-lt-amd-module-gt" class="headerlink" title="23.4 &lt;amd-module /&gt;"></a>23.4 <code>&lt;amd-module /&gt;</code></h3><blockquote><p>默认情况下生成的 <code>AMD</code> 模块 都是匿名的。但是，当一些工具需要处理生成的模块时会产生问题，比如 <code>r.js。amd-module</code> 指令允许给编译器传入一个可选的模块名：</p></blockquote><ul><li><code>amdModule.ts</code></li></ul><pre><code class="typescript">/// &lt;amd-module name=&quot;NamedModule&quot; /&gt;export class C &#123;&#125;</code></pre><blockquote><p>这会将 <code>NamedModule</code> 传入到 <code>AMD define</code> 函数里：</p></blockquote><ul><li><code>amdModule.js</code></li></ul><pre><code class="typescript">define(&quot;NamedModule&quot;, [&quot;require&quot;, &quot;exports&quot;], function (require, exports) &#123;  var C = (function () &#123;    function C() &#123;&#125;    return C;  &#125;)();  exports.C = C;&#125;);</code></pre><h3 id="23-5-lt-amd-dependency-gt"><a href="#23-5-lt-amd-dependency-gt" class="headerlink" title="23.5 &lt;amd-dependency /&gt;"></a>23.5 <code>&lt;amd-dependency /&gt;</code></h3><ul><li>注意：这个指令被废弃了。使用 <code>import &quot;moduleName&quot;;</code> 语句代替。</li></ul><pre><code class="typescript">/// &lt;amd-dependency path=&quot;x&quot; /&gt;// 告诉编译器有一个非 TypeScript 模块依赖需要被注入，做为目标模块 require 调用的一部分。</code></pre><ul><li><code>amd-dependency</code> 指令也可以带一个可选的 <code>name</code> 属性；它允许我们为 <code>amd-dependency</code> 传入一个可选名字：</li></ul><pre><code class="typescript">/// &lt;amd-dependency path=&quot;legacy/moduleA&quot; name=&quot;moduleA&quot;/&gt;declare var moduleA: MyType;moduleA.callStuff();</code></pre><ul><li>生成的 <code>JavaScript</code> 代码：</li></ul><pre><code class="typescript">define([&quot;require&quot;, &quot;exports&quot;, &quot;legacy/moduleA&quot;], function (require, exports, moduleA) &#123;  moduleA.callStuff();&#125;);</code></pre><h2 id="二十四、JavaScript-文件类型检查"><a href="#二十四、JavaScript-文件类型检查" class="headerlink" title="二十四、JavaScript 文件类型检查"></a>二十四、JavaScript 文件类型检查</h2><h3 id="24-1-JavaScript-文件类型检查"><a href="#24-1-JavaScript-文件类型检查" class="headerlink" title="24.1 JavaScript 文件类型检查"></a>24.1 JavaScript 文件类型检查</h3><blockquote><p><code>TypeScript 2.3</code> 以后的版本支持使用 <code>--checkJs</code> 对 <code>.js</code> 文件进行类型检查和错误提示。</p></blockquote><blockquote><p>你可以通过添加 <code>// @ts-nocheck</code> 注释来忽略类型检查；相反，你可以通过去掉 <code>--checkJs</code> 设置并添加一个 <code>// @ts-nocheck</code> 注释来选择检查某些 <code>.js</code> 文件。你还可以用 <code>// @ts-ignore</code> 来忽略本行的错误。如果你使用了 <code>tsconfig.json</code>，<code>JS</code> 检查将遵照一些严格检查标记，如 <code>noImplicitAny</code>，<code>strictNullChecks</code> 等。但因为 <code>JS</code> 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。</p></blockquote><ul><li>对比 <code>.js</code>文件和 <code>.ts</code> 文件在类型检查上的差异，有如下几点需要注意</li></ul><h4 id="1-用-JSDoc-类型表示类型信息"><a href="#1-用-JSDoc-类型表示类型信息" class="headerlink" title="(1) 用 JSDoc 类型表示类型信息"></a>(1) 用 <code>JSDoc</code> 类型表示类型信息</h4><blockquote><p><code>.js</code> 文件里，类型可以和在 <code>.ts</code> 文件里一样被推断出来。同样地，当类型不能被推断时，它们可以通过 <code>JSDoc</code> 来指定，就好比在 <code>.ts</code> 文件里那样。如同 <code>TypeScript</code>，<code>--noImplicitAny</code> 会在编译器无法推断类型的位置报错。（除了对象字面量的情况；后面会详细介绍）<code>JSDoc</code> 注解修饰的声明会被设置为这个声明的类型。比如：</p></blockquote><pre><code class="typescript">/** @type &#123;number&#125; */var x;x = 0; // OKx = false; // Error: boolean is not assignable to number</code></pre><blockquote><p>你可以在这里找到所有 <code>JSDoc</code> 支持的模式，<a href="https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript" target="_blank" rel="noopener external nofollow noreferrer">JSDoc 文档</a>。</p></blockquote><h4 id="2-属性的推断来自于类内的赋值语句"><a href="#2-属性的推断来自于类内的赋值语句" class="headerlink" title="(2) 属性的推断来自于类内的赋值语句"></a>(2) 属性的推断来自于类内的赋值语句</h4><blockquote><p><code>ES2015</code> 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在 <code>.js</code> 文件里，编译器从类内部的属性赋值语句来推断属性类型。属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是 <code>undefined</code> 或 <code>null</code>。若是这种情况，类型将会是所有赋值的类型的联合类型。在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。</p></blockquote><pre><code class="typescript">class C &#123;  constructor() &#123;    this.constructorOnly = 0;    this.constructorUnknown = undefined;  &#125;  method() &#123;    this.constructorOnly = false; // error, constructorOnly is a number    this.constructorUnknown = &quot;plunkbat&quot;; // ok, constructorUnknown is string | undefined    this.methodOnly = &quot;ok&quot;; // ok, but y could also be undefined  &#125;  method2() &#123;    this.methodOnly = true; // also, ok, y&#39;s type is string | boolean | undefined  &#125;&#125;</code></pre><blockquote><p>如果一个属性从没在类内设置过，它们会被当成未知的。</p></blockquote><blockquote><p>如果类的属性只是读取用的，那么就在构造函数里用 <code>JSDoc</code> 声明它的类型。如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：</p></blockquote><pre><code class="typescript">class C &#123;  constructor() &#123;    /** @type &#123;name | undefined&#125; */    this.prop = undefined;    /** @type &#123;number | undefined&#125; */    this.count;  &#125;&#125;let c = new C();c.prop = 0; // Okc.count = &quot;string&quot;; // Error: string is not assignable to number | undefined</code></pre><h4 id="3-构造函数等同于类"><a href="#3-构造函数等同于类" class="headerlink" title="(3) 构造函数等同于类"></a>(3) 构造函数等同于类</h4><blockquote><p><code>ES2015</code> 以前，<code>Javascript</code> 使用构造函数代替类。编译器支持这种模式并能够将构造函数识别为 <code>ES2015</code> 的类。属性类型推断机制和上面介绍的一致。</p></blockquote><pre><code class="typescript">function C() &#123;  this.constructorOnly = 0;  this.constructorUnknown = undefined;&#125;C.prototype.method = function () &#123;  this.constructorOnly = false; // error  this.constructorUnknown = &quot;plunkbat&quot;; // OK, the type is string | undefined&#125;;</code></pre><h4 id="4-支持-CommonJS-模块"><a href="#4-支持-CommonJS-模块" class="headerlink" title="(4) 支持 CommonJS 模块"></a>(4) 支持 <code>CommonJS</code> 模块</h4><blockquote><p>在 <code>.js</code> 文件里，<code>TypeScript</code> 能识别出 <code>CommonJS</code> 模块。对 <code>exports</code> 和 <code>module.exports</code> 的赋值被识别为导出声明。相似地，<code>require</code> 函数调用被识别为模块导入。例如：</p></blockquote><pre><code class="typescript">// same as `import module &#39;fs&#39;`const fs = require(&quot;fs&quot;);// same as `export function readFile`module.exports.readFile = function (f) &#123;  return fs.readFileSync(f);&#125;;</code></pre><blockquote><p>对 <code>JavaScript</code> 文件里模块语法的支持比在 <code>TypeScript</code> 里宽泛多了。 大部分的赋值和声明方式都是允许的。</p></blockquote><h4 id="5-类，函数和对象字面量是命名空间"><a href="#5-类，函数和对象字面量是命名空间" class="headerlink" title="(5) 类，函数和对象字面量是命名空间"></a>(5) 类，函数和对象字面量是命名空间</h4><pre><code class="typescript">// .js 文件里的类是命名空间。它可以用于嵌套类，比如：class C &#123;&#125;C.D = class &#123;&#125;;// ES2015 之前的代码，它可以用来模拟静态方法。function Outer() &#123;  this.y = 2;&#125;Outer.Inner = function () &#123;  this.yy = 2;&#125;;// 它还可以用于创建简单的命名空间：var ns = &#123;&#125;;ns.C = class &#123;&#125;;ns.func = function () &#123;&#125;;// 同时还支持其它的变化// 立即调用的函数表达式var ns = (function (n) &#123;  return n | &#123;&#125;;&#125;)();ns.COUNT = 1;// defaulting to globalvar assign =  assign ||  function () &#123;    // code goes here  &#125;;assign.extra = 1;</code></pre><h4 id="6-对象字面量是开放的"><a href="#6-对象字面量是开放的" class="headerlink" title="(6) 对象字面量是开放的"></a>(6) 对象字面量是开放的</h4><ul><li><code>.ts</code> 文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。这个规则在 <code>.js</code> 文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：</li></ul><pre><code class="typescript">var obj = &#123; a: 1 &#125;;obj.b = 2; // Allowed</code></pre><ul><li>对象字面量的表现就好比具有一个默认的索引签名 <code>\[x:string\]: any</code>，它们可以被当成开放的映射而不是封闭的对象。</li><li>与其它 <code>JS</code> 检查行为相似，这种行为可以通过指定 <code>JSDoc</code> 类型来改变，例如：</li></ul><pre><code class="typescript">/** @type &#123;&#123; a: number &#125;&#125; */var obj = &#123; a: 1 &#125;;obj.b = 2; // Error, type &#123;a: number&#125; does not have property b</code></pre><h4 id="7-null-undefined-和-空数组的类型是-any-或-any"><a href="#7-null-undefined-和-空数组的类型是-any-或-any" class="headerlink" title="(7) null undefined 和 空数组的类型是 any 或 any[]"></a>(7) null undefined 和 空数组的类型是 any 或 any[]</h4><blockquote><p>任何用 <code>null</code>，<code>undefined</code> 初始化的变量，参数或属性，它们的类型是 <code>any</code>，就算是在严格 <code>null</code> 检查模式下。任何用 <code>[]</code> 初始化的变量，参数或属性，它们的类型是 <code>any[]</code>，就算是在严格 <code>null</code> 检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。</p></blockquote><pre><code class="typescript">function Foo(i = null) &#123;  if (!i) i = 1;  var j = undefined;  j = 2;  this.l = [];&#125;var foo = new Foo();foo.l.push(foo.i);foo.l.push(&quot;end&quot;);</code></pre><h4 id="8-函数参数是默认可选的"><a href="#8-函数参数是默认可选的" class="headerlink" title="(8) 函数参数是默认可选的"></a>(8) 函数参数是默认可选的</h4><blockquote><p>由于在 <code>ES2015</code> 之前无法指定可选参数，因此 <code>.js</code> 文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。</p></blockquote><blockquote><p>需要注意的一点是，使用过多的参数调用函数会得到一个错误。</p></blockquote><ul><li>例如：</li></ul><pre><code class="typescript">function bar(a, b) &#123;  console.log(a + &quot; &quot; + b);&#125;bar(1); // OK, second argument considered optionalbar(1, 2);bar(1, 2, 3); // Error, too many arguments</code></pre><ul><li>使用 <code>JSDoc</code> 注解的函数会被从这条规则里移除。使用 <code>JSDoc</code> 可选参数语法来表示可选性。</li></ul><pre><code class="typescript">// 比如：/** * @param &#123;string&#125; [somebody] - Somebody&#39;s name. */function sayHello(somebody) &#123;  if (!somebody) &#123;    somebody = &quot;John Doe&quot;;  &#125;  console.log(&quot;Hello &quot; + somebody);&#125;sayHello();</code></pre><h4 id="9-由-arguments-推断出的-var-args-参数声明"><a href="#9-由-arguments-推断出的-var-args-参数声明" class="headerlink" title="(9) 由 arguments 推断出的 var-args 参数声明"></a>(9) 由 <code>arguments</code> 推断出的 <code>var-args</code> 参数声明</h4><blockquote><p>如果一个函数的函数体内有对 <code>arguments</code> 的引用，那么这个函数会隐式地被认为具有一个 <code>var-arg</code> 参数（比如: <code>(...arg: any[]) =&gt;; any)</code>）。使用 <code>JSDoc</code> 的 <code>var-arg</code> 语法来指定 <code>arguments</code> 的类型。</p></blockquote><pre><code class="typescript">/** @param &#123;...number&#125; args */function sum(/* numbers */) &#123;  var total = 0;  for (var i = 0; i &lt; arguments.length; i++) &#123;    total += arguments[i];  &#125;  return total;&#125;</code></pre><h4 id="10-未指定的类型参数默认为-any"><a href="#10-未指定的类型参数默认为-any" class="headerlink" title="(10) 未指定的类型参数默认为 any"></a>(10) 未指定的类型参数默认为 <code>any</code></h4><blockquote><p>由于 <code>JavaScript</code> 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为 <code>any</code>。</p></blockquote><h4 id="11-在-extends-语句中："><a href="#11-在-extends-语句中：" class="headerlink" title="(11) 在 extends 语句中："></a>(11) 在 <code>extends</code> 语句中：</h4><blockquote><p>例如，<code>React.Component</code> 被定义成具有两个类型参数，<code>Props</code> 和 <code>State</code>。 在一个 <code>.js</code> 文件里，没有一个合法的方式在 <code>extends</code> 语句里指定它们。默认地参数类型为 <code>any</code>：</p></blockquote><pre><code class="typescript">import &#123; Component &#125; from &quot;react&quot;;class MyComponent extends Component &#123;  render() &#123;    this.props.b; // Allowed, since this.props is of type any  &#125;&#125;</code></pre><blockquote><p>使用 <code>JSDoc</code> 的 <code>@augments</code> 来明确地指定类型。</p></blockquote><ul><li>例如：</li></ul><pre><code class="typescript">import &#123; Component &#125; from &quot;react&quot;;/** * @augments &#123;Component&lt;&#123;a: number&#125;, State&gt;&#125; */class MyComponent extends Component &#123;  render() &#123;    this.props.b; // Error: b does not exist on &#123;a:number&#125;  &#125;&#125;</code></pre><h4 id="12-在-JSDoc-引用中"><a href="#12-在-JSDoc-引用中" class="headerlink" title="(12) 在 JSDoc 引用中"></a>(12) 在 JSDoc 引用中</h4><pre><code class="typescript">/** @type&#123;Array&#125; */var x = [];x.push(1); // OKx.push(&quot;string&quot;); // OK, x is of type Array&lt;any&gt;/** @type&#123;Array.&lt;number&gt;&#125; */var y = [];y.push(1); // OKy.push(&quot;string&quot;); // Error, string is not assignable to number</code></pre><h4 id="13-在函数调用中"><a href="#13-在函数调用中" class="headerlink" title="(13) 在函数调用中"></a>(13) 在函数调用中</h4><blockquote><p>泛型函数的调用使用 <code>arguments</code> 来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为 <code>any</code>。</p></blockquote><pre><code class="typescript">// 例如：var p = new Promise((resolve, reject) =&gt; &#123;  reject();&#125;);p; // Promise&lt;any&gt;;</code></pre><h3 id="24-2-支持的-JSDoc"><a href="#24-2-支持的-JSDoc" class="headerlink" title="24.2 支持的 JSDoc"></a>24.2 支持的 JSDoc</h3><blockquote><p>面的列表列出了当前所支持的 <code>JSDoc</code> 注解，你可以用它们在 <code>JavaScript</code> 文件里添加类型信息。 注意，没有在下面列出的标记（例如 <code>@async</code>）都是还不支持的。</p></blockquote><pre><code class="typescript">1.  @type2.  @param (or @arg or @argument)3.  @returns (or @return)4.  @typedef5.  @callback6.  @template7.  @class (or @constructor)8.  @this9.  @extends (or @augments)10. @enum</code></pre><blockquote><p>它们代表的意义与 <code>usejsdoc.org</code> 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。</p></blockquote><h4 id="1-type"><a href="#1-type" class="headerlink" title="(1) @type "></a>(1) <a href="/type">@type </a></h4><blockquote><p>可以使用 <code>@type</code> 标记并引用一个类型名称（原始类型，<code>TypeScript</code> 里声明的类型，或在 <code>JSDoc</code> 里 <code>@typedef</code> 标记指定的）可以使用任何 <code>TypeScript</code> 类型和大多数 <code>JSDoc</code> 类型。</p></blockquote><pre><code class="typescript">/** @type &#123;string&#125; */var s;/** @type &#123;Window&#125; */var win;/** @type &#123;PromiseLike&lt;string&gt;&#125; */var promisedString;// You can specify an HTML Element with DOM properties/** @type &#123;HTMLElement&#125; */var myElement = document.querySelector(selector);element.dataset.myData = &quot;&quot;;</code></pre><ul><li><code>@type</code> 可以指定联合类型—例如，<code>string</code> 和 <code>boolean</code> 类型的联合。</li></ul><pre><code class="typescript">/** @type &#123;&#123;string | boolean&#125;&#125; */var sb;</code></pre><ul><li>注意：括号是可选的</li></ul><pre><code class="typescript">/** @type &#123;string | boolean&#125; */var sb;</code></pre><ul><li>有多种方式来指定数组类型</li></ul><pre><code class="typescript">/** @type &#123;number[]&#125; */var ns;/** @type &#123;Array.&lt;number&gt;&#125; */var nds;/** @type &#123;Array&lt;number&gt;&#125; */var nas;</code></pre><ul><li>还可以指定对象字面量类型。例如，一个带有 <code>a(字符串)</code> 和 <code>b(数字)</code> 属性的对象，使用下面的语法：</li></ul><pre><code class="typescript">/** @type &#123;&#123;a: string, b: number&#125;&#125; */var var9;</code></pre><ul><li>可以使用字符串和数字索引签名来指定 <code>map-like</code> 和 <code>array-like</code> 的对象，使用标准的 <code>JSDoc</code> 语法或者 <code>TypeScript</code> 语法。</li></ul><pre><code class="typescript">/** * A map-like object that maps arbitrary `string` properties to `number`s. * * @type &#123;Object.&lt;string, number&gt;&#125; * */var stringToNumber;/** @type &#123;Object.&lt;number, object&gt;&#125; */var arrayLike;</code></pre><ul><li>这两个类型与 <code>TypeScript</code> 里的 <code>&#123; [x: string]: number &#125;</code> 和 <code>&#123; [x: number]: any &#125;</code> 是等同的。 编译器能识别出这两种语法。</li><li>可以使用 <code>TypeScript</code> 或 <code>Closure</code> 语法指定函数类型。</li></ul><pre><code class="typescript">/** @type &#123;function(string, boolean): number&#125; Closure syntax */var sbn;/** @type &#123;(s: string, b: boolean) =&gt; number&#125; Typescript syntax */var sbn2;</code></pre><ul><li>或者直接使用未指定的 <code>Function</code> 类型：</li></ul><pre><code class="typescript">/** @type &#123;Function&#125; */var fn7;/** @type &#123;function&#125; */var fn6;</code></pre><ul><li><code>Closure</code> 的其它类型也可以使用：</li></ul><pre><code class="typescript">/** @type &#123;*&#125; - can be &#39;any&#39; type */var star;/** @type &#123;?&#125; - unknown type (same as &#39;any&#39;) */var question;</code></pre><h4 id="2-转换"><a href="#2-转换" class="headerlink" title="(2) 转换"></a>(2) 转换</h4><blockquote><p><code>TypeScript</code> 借鉴了 <code>Closure</code> 里的转换语法。在括号表达式前面使用 <code>@type</code> 标记，可以将一种类型转换成另一种类型</p></blockquote><pre><code class="typescript">/** * @type &#123;number | string&#125; */var numberOrString = Math.random() &lt; 0.5 ? &quot;hello&quot; : 100;var typeAssertedNumber = /** @type &#123;number&#125; */ numberOrString;</code></pre><h4 id="3-导入类型"><a href="#3-导入类型" class="headerlink" title="(3) 导入类型"></a>(3) 导入类型</h4><blockquote><p>可以使用导入类型从其它文件中导入声明。 这个语法是 <code>TypeScript</code> 特有的，与 <code>JSDoc</code> 标准不同：</p></blockquote><pre><code class="typescript">/** * @param p &#123; import(&quot;./a&quot;).Pet &#125; */function walk(p) &#123;  console.log(`Walking $&#123;p.name&#125;...`);&#125;</code></pre><blockquote><p>导入类型也可以使用在类型别名声明中：</p></blockquote><pre><code class="typescript">/** * @typedef Pet &#123; import(&quot;./a&quot;).Pet &#125; *//** * @type &#123;Pet&#125; */var myPet;myPet.name;</code></pre><blockquote><p>导入类型可以用在从模块中得到一个值的类型。</p></blockquote><pre><code class="typescript">/** * @type &#123;typeof import(&quot;./a&quot;).x &#125; */var x = require(&quot;./a&quot;).x;</code></pre><h4 id="4-param-和-returns"><a href="#4-param-和-returns" class="headerlink" title="(4) @param  和 @returns "></a>(4) <a href="/param">@param </a> 和 <a href="/returns">@returns </a></h4><blockquote><p><code>@param</code> 语法 和 <code>@type</code> 相同，但增加了一个参数名。 使用 <code>[]</code> 可以把参数声明为可选的：</p></blockquote><pre><code class="typescript">// Parameters may be declared in a variety of syntactic forms/** * @param &#123;string&#125;  p1 - A string param. * @param &#123;string=&#125; p2 - An optional param (Closure syntax) * @param &#123;string&#125; [p3] - Another optional param (JSDoc syntax). * @param &#123;string&#125; [p4=&quot;test&quot;] - An optional param with a default value * @return &#123;string&#125; This is the result */function stringsStringStrings(p1, p2, p3, p4) &#123;  // TODO&#125;</code></pre><blockquote><p>函数的返回值类型也是类似的：</p></blockquote><pre><code class="typescript">/** * @return &#123;PromiseLike&lt;string&gt;&#125; */function ps() &#123;&#125;/** * @returns &#123;&#123; a: string, b: number &#125;&#125; - May use &#39;@returns&#39; as well as &#39;@return&#39; */function ab() &#123;&#125;</code></pre><h4 id="5-typedef-callback-和-param"><a href="#5-typedef-callback-和-param" class="headerlink" title="(5) @typedef, @callback, 和 @param "></a>(5) @typedef, @callback, 和 <a href="/param">@param </a></h4><blockquote><p><code>@typedef</code> 可以用来声明复杂类型。和 <code>@param</code> 类似的语法。</p></blockquote><pre><code class="typescript">/** * @typedef &#123;Object&#125; SpecialType - creates a new type named &#39;SpecialType&#39; * @property &#123;string&#125; prop1 - a string property of SpecialType * @property &#123;number&#125; prop2 - a number property of SpecialType * @property &#123;number=&#125; prop3 - an optional number property of SpecialType * @prop &#123;number&#125; [prop4] - an optional number property of SpecialType * @prop &#123;number&#125; [prop5=42] - an optional number property of SpecialType with default *//** @type &#123;SpecialType&#125; */var specialTypeObject;</code></pre><blockquote><p>可以在第一行上使用 <code>object</code> 或 <code>Object</code>。</p></blockquote><pre><code class="typescript">/** * @typedef &#123;object&#125; SpecialType1 - creates a new type named &#39;SpecialType&#39; * @property &#123;string&#125; prop1 - a string property of SpecialType * @property &#123;number&#125; prop2 - a number property of SpecialType * @property &#123;number=&#125; prop3 - an optional number property of SpecialType *//** @type &#123;SpecialType1&#125; */var specialTypeObject1;</code></pre><blockquote><p><code>@param</code> 允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：</p></blockquote><pre><code class="typescript">/** * @param &#123;Object&#125; options - The shape is the same as SpecialType above * @param &#123;string&#125; options.prop1 * @param &#123;number&#125; options.prop2 * @param &#123;number=&#125; options.prop3 * @param &#123;number&#125; [options.prop4] * @param &#123;number&#125; [options.prop5=42] */function special(options) &#123;  return (options.prop4 || 1001) + options.prop5;&#125;</code></pre><blockquote><p><code>@callback</code> 与 <code>@typedef</code> 相似，但它指定函数类型而不是对象类型：</p></blockquote><pre><code class="typescript">/** * @callback Predicate * @param &#123;string&#125; data * @param &#123;number&#125; [index] * @returns &#123;boolean&#125; *//** @type &#123;Predicate&#125; */const ok = s =&gt; !(s.length % 2);</code></pre><blockquote><p>当然，所有这些类型都可以使用 <code>TypeScript</code> 的语法 <code>@typedef</code> 在一行上声明：</p></blockquote><pre><code class="typescript">/** @typedef &#123;&#123; prop1: string, prop2: string, prop3?: number &#125;&#125; SpecialType *//** @typedef &#123;(data: string, index?: number) =&gt; boolean&#125; Predicate */</code></pre><h4 id="6-template"><a href="#6-template" class="headerlink" title="(6) @template "></a>(6) <a href="/template">@template </a></h4><blockquote><p>使用 <code>@template</code> 声明泛型：</p></blockquote><pre><code class="typescript">/** * @template T * @param &#123;T&#125; p1 - A generic parameter that flows through to the return type * @return &#123;T&#125; */function id(x) &#123;  return x;&#125;</code></pre><blockquote><p>用逗号或多个标记来声明多个类型参数：</p></blockquote><pre><code class="typescript">/** * @template T,U,V * @template W,X */</code></pre><blockquote><p>还可以在参数名前指定类型约束。只有列表的第一项类型参数会被约束:</p></blockquote><pre><code class="typescript">/** * @template &#123;string&#125; K - K must be a string or string literal * @template &#123;&#123; serious(): string &#125;&#125; Seriousalizable - must have a serious method * @param &#123;K&#125; key * @param &#123;Seriousalizable&#125; object */function seriousalize(key, object) &#123;  // ????&#125;</code></pre><h4 id="7-constructor"><a href="#7-constructor" class="headerlink" title="(7) @constructor "></a>(7) <a href="/constructor">@constructor </a></h4><blockquote><p>编译器通过 <code>this</code> 属性的赋值来推断构造函数, 但你可以让检查更严格提示更友好, 你可以添加一个 <code>@constructor</code> 标记:</p></blockquote><pre><code class="typescript">/** * @constructor * @param &#123;number&#125; data */function C(data) &#123;  this.size = 0;  this.initialize(data); // Should error, initializer expects a string&#125;/** * @param &#123;string&#125; s */C.prototype.initialize = function (s) &#123;  this.size = s.length;&#125;;var c = new C(0);var result = C(1); // C should only be called with new</code></pre><blockquote><p>通过 <code>@constructor</code>, <code>this</code> 将在构造函数<code>C</code>里被检查，因此你在 <code>initialize</code> 方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用<code>C</code>而不是构造它，也会得到一个错误。</p></blockquote><blockquote><p>不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用 <code>@constructor</code>。</p></blockquote><h4 id="8-this"><a href="#8-this" class="headerlink" title="(8) @this "></a>(8) <a href="/this">@this </a></h4><blockquote><p>编译器通常可以通过上下文来推断出 <code>this</code> 的类型。但你可以使用 <code>@this</code> 来明确指定它的类型：</p></blockquote><pre><code class="typescript">/** * @this &#123;HTMLElement&#125; * @param &#123;*&#125; e */function callbackForLater(e) &#123;  this.clientHeight = parseInt(e); // should be fine!&#125;</code></pre><h4 id="9-extends"><a href="#9-extends" class="headerlink" title="(9) @extends "></a>(9) <a href="/extends">@extends </a></h4><blockquote><p>当 <code>JavaScript</code> 类继承了一个基类, 无处指定类型参数的类型, 而 <code>@extends</code> 标记提供了这样一种方式:</p></blockquote><pre><code class="typescript">/** * @template T * @extends &#123;Set&lt;T&gt;&#125; */class SortableSet extends Set &#123;  // ...&#125;</code></pre><blockquote><p>注意 <code>@extends</code> 只作用于类。当前，无法实现构造函数继承类的情况。</p></blockquote><h4 id="10-enum"><a href="#10-enum" class="headerlink" title="(10) @enum "></a>(10) <a href="/enum">@enum </a></h4><blockquote><p><code>@enum</code> 标记允许你创建一个对象字面量, 它的成员都有确定的类型。不同于 <code>JavaScript</code> 里大多数的对象字面量，它不允许添加额外成员。</p></blockquote><pre><code class="typescript">/** @enum &#123;number&#125; */const JSDocState = &#123;  BeginningOfLine: 0,  SawAsterisk: 1,  SavingComments: 2&#125;;</code></pre><blockquote><p>注意 <code>@enum</code> 与 <code>TypeScript</code> 的 <code>@enum</code> 大不相同, 它更加简单。然而，不同于 <code>TypeScript</code> 的枚举, <code>@enum</code> 可以是任何类型:</p></blockquote><pre><code class="typescript">/** @enum &#123;function(number): number&#125; */const Math = &#123;  add1: n =&gt; n + 1,  id: n =&gt; -n,  sub1: n =&gt; n - 1&#125;;</code></pre><h4 id="11-更多示例"><a href="#11-更多示例" class="headerlink" title="(11) 更多示例"></a>(11) 更多示例</h4><pre><code class="tsx">var someObj = &#123;  /**   * @param &#123;string&#125; param1 - Docs on property assignments work   */  x: function (param1) &#123;&#125;&#125;;/** * As do docs on variable assignments * @return &#123;Window&#125; */let someFunc = function () &#123;&#125;;/** * And class methods * @param &#123;string&#125; greeting The greeting to use */Foo.prototype.sayHi = greeting =&gt; console.log(&quot;Hi!&quot;);/** * And arrow functions expressions * @param &#123;number&#125; x - A multiplier */let myArrow = x =&gt; x * x;/** * Which means it works for stateless function components in JSX too * @param &#123;&#123;a: string, b: number&#125;&#125; test - Some param */var sfc = test =&gt; &lt;div&gt;&#123;test.a.charAt(0)&#125;&lt;/div&gt;;/** * A parameter can be a class constructor, using Closure syntax. * * @param &#123;&#123;new(...args: any[]): object&#125;&#125; C - The class to register */function registerClass(C) &#123;&#125;/** * @param &#123;...string&#125; p1 - A &#39;rest&#39; arg (array) of strings. (treated as &#39;any&#39;) */function fn10(p1) &#123;&#125;/** * @param &#123;...string&#125; p1 - A &#39;rest&#39; arg (array) of strings. (treated as &#39;any&#39;) */function fn9(p1) &#123;  return p1.join();&#125;</code></pre><h4 id="12-已知不支持的模式"><a href="#12-已知不支持的模式" class="headerlink" title="(12) 已知不支持的模式"></a>(12) 已知不支持的模式</h4><blockquote><p>在值空间中将对象视为类型是不可以的, 除非对象创建了类型, 如构造函数。</p></blockquote><pre><code class="typescript">function aNormalFunction() &#123;&#125;/** * @type &#123;aNormalFunction&#125; */var wrong;/** * Use &#39;typeof&#39; instead: * @type &#123;typeof aNormalFunction&#125; */var right;</code></pre><blockquote><p>对象字面量属性上的 <code>=</code> 后缀不能指定这个属性是可选的:</p></blockquote><pre><code class="typescript">/** * @type &#123;&#123; a: string, b: number= &#125;&#125; */var wrong;/** * Use postfix question on the property name instead: * @type &#123;&#123; a: string, b?: number &#125;&#125; */var right;</code></pre><blockquote><p><code>Nullable</code> 类型只在启用了 <code>strictNullChecks</code> 检查时才启作用:</p></blockquote><pre><code class="typescript">/** * @type &#123;?number&#125; * With strictNullChecks: true -- number | null * With strictNullChecks: off  -- number */var nullable;</code></pre><blockquote><p><code>Non-nullable</code> 类型没有意义, 以其原类型对待:</p></blockquote><pre><code class="typescript">/** * @type &#123;!number&#125; * Just has type number */var normal;</code></pre><blockquote><p>不同于 <code>JSDoc</code> 类型系统, <code>TypeScript</code> 只允许将类型标记为包不包含 <code>null</code>。<code>Non-nullable</code> -- 如果启用了 <code>strictNullChecks</code>，那么 <code>number</code> 是 <code>非null</code> 的。 如果没有启用，那么 <code>number</code> 是可以为 <code>null</code> 的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks 的一些特性</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/React/React%20Hooks%20%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/React/React%20Hooks%20%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-逆潮而动"><a href="#1-逆潮而动" class="headerlink" title="1. 逆潮而动"></a>1. 逆潮而动</h2><p>每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state</p><pre><code class="jsx">function Example(props) &#123;  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(props.counter);    &#125;, 1000);  &#125;);&#125;// 等效于function Example(props) &#123;  const counter = props.counter;  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(counter);    &#125;);  &#125;);&#125;</code></pre><h2 id="2-effects-中的清理"><a href="#2-effects-中的清理" class="headerlink" title="2. effects 中的清理"></a>2. effects 中的清理</h2><p>目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。</p><p>effect 的清除并不会读取 &quot;最新&quot; 的 props。它只能读取到定义它的那次渲染中的 props 的值</p><pre><code class="jsx">// First render, props are &#123;id: 10&#125;function Example() &#123;  // ...  useEffect(() =&gt; &#123;    ChatAPI.subscribeToFriendStatus(10, handleStatusChange);    // cleanup for effect from first render    return () =&gt; &#123;      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);    &#125;;  &#125;);  // ...&#125;// Next render, props are &#123;id: 20&#125;function Example() &#123;  // ...  useEffect(() =&gt; &#123;    ChatAPI.subscribeToFriendStatus(20, handleStatusChange);    return () =&gt; &#123;      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);    &#125;;  &#125;);  // ...&#125;</code></pre><h2 id="3-避免重复调用"><a href="#3-避免重复调用" class="headerlink" title="3. 避免重复调用"></a>3. 避免重复调用</h2><p>为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)</p><pre><code class="jsx">useEffect(() =&gt; &#123;  document.title = &quot;Hello, &quot; + title;&#125;, [name]);</code></pre><p>如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。</p><h2 id="4-两种诚实告知依赖的方法"><a href="#4-两种诚实告知依赖的方法" class="headerlink" title="4. 两种诚实告知依赖的方法"></a>4. 两种诚实告知依赖的方法</h2><ul><li>在依赖中包含所有 effect 中用到的组件内的值</li></ul><pre><code class="jsx">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;export default function App() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      setCount(count + 1);    &#125;);    return () =&gt; clearInterval(id);  &#125;, [count]);  return (    &lt;div&gt;      &lt;p&gt;you clicked it &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;click me&lt;/button&gt;    &lt;/div&gt;  );&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</code></pre><ul><li>修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。</li></ul><h2 id="5-让-Effect-自给自足"><a href="#5-让-Effect-自给自足" class="headerlink" title="5. 让 Effect 自给自足"></a>5. 让 Effect 自给自足</h2><p>我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式</p><pre><code class="jsx">useEffect(() =&gt; &#123;  const id = setInterval(() =&gt; &#123;    setCount(c =&gt; c + 1);  &#125;, 1000);  return () =&gt; clearInterval(id);&#125;, []);</code></pre><p>这正是 setCount(c =&gt; c + 1) 做的事情。你可以认为它是在给 React &quot;发送指令&quot; 告知如何更新状态。这种 &quot;更新形式&quot; 在其他情况下也有帮助，比如你需要 &quot;批量更新&quot;。</p><h2 id="6-解耦来自-Actions-的更新"><a href="#6-解耦来自-Actions-的更新" class="headerlink" title="6. 解耦来自 Actions 的更新"></a>6. 解耦来自 Actions 的更新</h2><p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。</p><p>当你写类似 setSomething(something =&gt; ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 <strong>把组件内发生了什么(actions)</strong> 和 <strong>状态如何响应并更新</strong> 分开表述。</p><pre><code class="jsx">const [state, dispatch] = useReducer(reducer, initialState);const &#123; count, step &#125; = state;useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;        dispatch(&#123; type: &quot;tick&quot; &#125;); // Instead of setCount(c =&gt; c + step) &#125;, 1000);        return () =&gt; clearInterval(id);&#125;, [dispatch]);</code></pre><p>相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。</p><pre><code class="jsx">const initialState = &#123;  count: 0,  step: 1&#125;;function reducer(state, action) &#123;  const &#123; count, step &#125; = state;  if (action.type === &quot;tick&quot;) &#123;    return &#123; count: count + step, step &#125;;  &#125; else if (action.type === &quot;step&quot;) &#123;    return &#123; count, step: action.step &#125;;  &#125; else &#123;    throw new Error();  &#125;&#125;</code></pre><h2 id="7-为什么-useReducer-是-Hooks-的作弊模式"><a href="#7-为什么-useReducer-是-Hooks-的作弊模式" class="headerlink" title="7. 为什么 useReducer 是 Hooks 的作弊模式"></a>7. 为什么 useReducer 是 Hooks 的作弊模式</h2><p>假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 <code>&lt;Counter step=&#123;1&#125; /&gt;</code>。确定的是，在这种情况下，我们没法避免依赖 props.step 。</p><p>实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。</p><pre><code class="jsx">function Counter(&#123; step &#125;) &#123;  const [count, dispatch] = useReducer(reducer, 0);  function reducer(state, action) &#123;    if (action.type === &quot;tick&quot;) &#123;      return state + step;    &#125; else &#123;      throw new Error();    &#125;  &#125;  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      dispatch(&#123; type: &quot;tick&quot; &#125;);    &#125;, 1000);  &#125;, [dispatch]);  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;</code></pre><p>注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。</p><p>它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</p><h2 id="8-如何不把函数放到-Effect-里"><a href="#8-如何不把函数放到-Effect-里" class="headerlink" title="8. 如何不把函数放到 Effect 里"></a>8. 如何不把函数放到 Effect 里</h2><p>有时候我们可能不想把函数移入 effect 里。</p><p>比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</p><p>函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:</p><pre><code class="jsx">function SearchResults() &#123;  function getFetchUrl(query) &#123;    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;  &#125;  useEffect(() =&gt; &#123;    const url = getFetchUrl(&quot;react&quot;);    // ... Fetch data and do something ...  &#125;, []); // 🔴 Missing dep: getFetchUrl  useEffect(() =&gt; &#123;    const url = getFetchUrl(&quot;redux&quot;);    // ... Fetch data and do something ...  &#125;, []); // 🔴 Missing dep: getFetchUrl  // ...&#125;</code></pre><p>我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。</p><h3 id="8-1-方法一"><a href="#8-1-方法一" class="headerlink" title="8.1 方法一"></a>8.1 方法一</h3><ul><li>如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用</li></ul><pre><code class="jsx">// ✅ Not affected by the data flowfunction getFetchUrl(query) &#123;  return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;&#125;function SearchResults() &#123;  useEffect(() =&gt; &#123;    const url = getFetchUrl(&quot;react&quot;);    // ... Fetch data and do something ...  &#125;, []); // ✅ Deps are OK  useEffect(() =&gt; &#123;    const url = getFetchUrl(&quot;redux&quot;);    // ... Fetch data and do something ...  &#125;, []); // ✅ Deps are OK  // ...&#125;</code></pre><p>你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。</p><h3 id="8-2-方法二"><a href="#8-2-方法二" class="headerlink" title="8.2 方法二"></a>8.2 方法二</h3><ul><li>你也可以把它包装成 useCallback Hook</li></ul><pre><code class="jsx">function SearchResults() &#123;  // ✅ Preserves identity when its own deps are the same  const getFetchUrl = useCallback(query =&gt; &#123;    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;  &#125;, []); // ✅ Callback deps are OK  useEffect(() =&gt; &#123;    const url = getFetchUrl(&quot;react&quot;);    // ... Fetch data and do something ...  &#125;, [getFetchUrl]); // ✅ Effect deps are OK  useEffect(() =&gt; &#123;    const url = getFetchUrl(&quot;redux&quot;);    // ... Fetch data and do something ...  &#125;, [getFetchUrl]); // ✅ Effect deps are OK  // ...&#125;</code></pre><p>useCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</p><p>如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。</p><p>如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：</p><pre><code class="jsx">function SearchResults() &#123;  const [query, setQuery] = useState(&quot;react&quot;);  // ✅ Preserves identity until query changes  const getFetchUrl = useCallback(() =&gt; &#123;    return &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;  &#125;, [query]); // ✅ Callback deps are OK  useEffect(() =&gt; &#123;    const url = getFetchUrl();    // ... Fetch data and do something ...  &#125;, [getFetchUrl]); // ✅ Effect deps are OK  // ...&#125;</code></pre><p>这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用</p><pre><code class="jsx">function Parent() &#123;  const [query, setQuery] = useState(&quot;react&quot;);  // ✅ Preserves identity until query changes  const fetchData = useCallback(() =&gt; &#123;    const url = &quot;https://hn.algolia.com/api/v1/search?query=&quot; + query;    // ... Fetch data and return it ...  &#125;, [query]); // ✅ Callback deps are OK  return &lt;Child fetchData=&#123;fetchData&#125; /&gt;;&#125;function Child(&#123; fetchData &#125;) &#123;  let [data, setData] = useState(null);  useEffect(() =&gt; &#123;    fetchData().then(setData);  &#125;, [fetchData]); // ✅ Effect deps are OK  // ...&#125;</code></pre><p>因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。</p><h2 id="9-函数是数据流的一部分么"><a href="#9-函数是数据流的一部分么" class="headerlink" title="9. 函数是数据流的一部分么"></a>9. 函数是数据流的一部分么</h2><p>在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 &quot;diff&quot;。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。</p><p>使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。</p><p>类似地，useMemo 可以让我们对复杂对象做类似的事情。</p><pre><code class="jsx">function ColorPicker() &#123;  // Doesn&#39;t break Child&#39;s shallow equality prop check  // unless the color actually changes.  const [color, setColor] = useState(&quot;pink&quot;);  const style = useMemo(() =&gt; (&#123; color &#125;), [color]);  return &lt;Child style=&#123;style&#125; /&gt;;&#125;</code></pre><h2 id="10-竞态"><a href="#10-竞态" class="headerlink" title="10. 竞态"></a>10. 竞态</h2><p>下面是一个典型的在 class 组件里发请求的例子：</p><pre><code class="jsx">class Article extends React.Component &#123;  state = &#123;    article: null  &#125;;  componentDidMount() &#123;    this.fetchData(this.props.id);  &#125;  componentDidUpdate(prevProps) &#123;    if (prevProps.id !== this.props.id) &#123;      this.fetchData(this.props.id);    &#125;  &#125;  async fetchData(id) &#123;    const article = await API.fetchArticle(id);    this.setState(&#123; article &#125;);  &#125;  // ...&#125;</code></pre><p>这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。</p><p>Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。</p><ul><li>解决方式</li></ul><ol><li><p>如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。</p></li><li><p>或者，最简单的权宜之计是用一个布尔值来跟踪它。</p></li></ol><pre><code class="jsx">function Article(&#123; id &#125;) &#123;  const [article, setArticle] = useState(null);  useEffect(() =&gt; &#123;    let didCancel = false;    const fetchData = async () =&gt; &#123;      const article = await API.fetchArticle(id);      if (!didCancel) &#123;        setArticle(article);      &#125;    &#125;;    fetchData();    return () =&gt; &#123;      didCancel = true;    &#125;;  &#125;, [id]);  // ...&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React-Hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React16 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/React/React16%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/React/React16%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-React-中的核心概念"><a href="#1-React-中的核心概念" class="headerlink" title="1. React 中的核心概念"></a>1. React 中的核心概念</h2><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><ol><li>DOM 的本质是什么？</li></ol><blockquote><p>浏览器中的概念，用<code>js</code>对象来表示页面上的元素，并提供了操作 <code>DOM</code> 对象的 API；</p></blockquote><ol start="2"><li>什么是 React 中的 虚拟 DOM？（ 虚拟 DOM 的本质）：</li></ol><blockquote><p>用<code>js</code>对象来模拟 页面上的<code>DOM和DOM嵌套</code></p></blockquote><ol start="3"><li>为什么要实现 虚拟 DOM ？（ 虚拟 DOM 的目的）：</li></ol><blockquote><p>为了实现页面中，<code>DOM</code>元素的高效更新</p></blockquote><ol start="4"><li>DOM 和 虚拟 DOM 的区别：</li></ol><ul><li><code>DOM</code>：浏览器中，提供的概念；用<code>js</code>对象，表示页面上的元素，并提供了操作元素的 <code>API</code>；</li><li><code>虚拟DOM</code>：是框架中的概念；是开发框架的人员，手动用<code>js</code>对象来模拟<code>DOM</code>元素和嵌套关系；</li></ul><ol start="5"><li>DOM 树的概念：</li></ol><blockquote><p>一个网页的呈现过程：</p><ol><li>浏览器请求服务器获取页面的 <code>html</code> 代码；</li><li>浏览器要先在内存中，解析 <code>DOM</code> 结构，并在浏览器内存中，渲染出一棵 <code>DOM</code> 树；</li><li>浏览器把 <code>DOM</code> 树，呈现到页面上；</li></ol></blockquote><h3 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h3><ol><li>tree diff：</li></ol><blockquote><p>新旧两棵 <code>DOM</code> 树，逐层对比的过程，就是<code>tree diff</code>；<br>当整棵<code>DOM</code>逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到；</p></blockquote><ol start="2"><li>component diff：</li></ol><blockquote><p>在进行 <code>tree diff</code> 的时候，每一层中，组件级别的对比，叫做 <code>component diff</code>；<br>如果对比前后，组件的类型相同，则<strong>暂时</strong>认为此组件不许要被更新；<br>如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并追加到页面上；</p></blockquote><ol start="3"><li>element diff：</li></ol><blockquote><p>在进行组件对比的时候，如果两个组件的类型相同，则需要进行元素级别的对比，这叫做<code>element diff</code>；</p></blockquote><h2 id="2-React-中创建组件"><a href="#2-React-中创建组件" class="headerlink" title="2. React 中创建组件"></a>2. React 中创建组件</h2><h3 id="使用构造函数来创建组件"><a href="#使用构造函数来创建组件" class="headerlink" title="使用构造函数来创建组件"></a>使用构造函数来创建组件</h3><blockquote><p>1、在组件中，必须要向外<code>return</code>一个合法的<code>jsx</code>创建的<code>虚拟DOM</code>元素；<br>2、如果要接收外界传递的数据，需要在<code>构造函数</code>的参数列表中使用<code>props</code>来接收；<br>3、无论是<code>vue</code>还是<code>react</code>，组件中的<code>props</code>永远都是只读<code>read-only</code>的，不能被重新赋值；<br>4、组件的名称<code>首字母</code>必须是<code>大写</code>的<br>5、省略 <code>.jsx</code> 文件名</p></blockquote><blockquote><p>打开 <code>webpack.config.js</code>，并在导出的配置对象中，新增以下几个节点：</p></blockquote><pre><code class="javascript">resolve: &#123;  extensions: [&quot;.js&quot;, &quot;.jsx&quot;, &quot;.json&quot;];&#125;</code></pre><blockquote><p>如果在一个组件中 <code>return</code> 一个 <code>null</code>，则表示此组件是空的，什么都不会渲染</p></blockquote><pre><code class="jsx">function Hello(props) &#123;  return (    &lt;div&gt;      这是Hello组件 -- &#123;props.name&#125; -- &#123;props.age&#125; -- &#123;props.gender&#125;    &lt;/div&gt;  );&#125;const user = &#123;  name: &quot;大黄&quot;,  age: 3,  gender: &quot;雄性&quot;&#125;;ReactDOM.render(  &lt;div&gt;    &lt;Hello &#123;...user&#125; /&gt;  &lt;/div&gt;,  document.getElementById(&quot;#app&quot;));</code></pre><h3 id="使用-class-关键字来创建组件"><a href="#使用-class-关键字来创建组件" class="headerlink" title="使用 class 关键字来创建组件"></a>使用 class 关键字来创建组件</h3><blockquote><p><code>public</code>: 所有成员都可访问<br><code>private</code>: 只有当前类可访问<br><code>protected</code>: 只有当前类和其子类可访问，外部成员无法访问</p></blockquote><blockquote><p><code>es6</code>中的<code>class关键字</code>，是实现<code>面向对象编程</code>的新形式，也叫做<code>语法糖</code></p></blockquote><ul><li>constructor 构造器中的 super 函数</li></ul><blockquote><p>在子类中， <code>this</code> 只能放到 <code>super</code> 之后使用<br>子类中的 <code>super</code>，其实就是父类中，<code>contructor</code>构造器的一个引用</p></blockquote><ul><li>最基本的组件结构</li></ul><blockquote><p><code>render</code>函数的作用：渲染当前组件所对应的<code>虚拟DOM</code> 元素</p></blockquote><pre><code class="jsx">import React from &quot;react&quot;;class 组件名称 extends React.Component &#123;  render() &#123;    return &lt;div&gt;这是 class 创建的组件&lt;/div&gt;;  &#125;&#125;</code></pre><ul><li>this.props 和 this.state</li></ul><blockquote><ol><li><code>this.props</code> 接收外界传递的参数，<code>this.state</code> 设置私有数据</li><li>在 <code>class</code> 关键字创建的组件中，直接使用 <code>this.props</code> 访问传递过来的数据</li><li><code>props</code> 是只读的</li></ol></blockquote><pre><code class="jsx">class Movie extends React.Component &#123;  constructor() &#123;    super();    // 这里的 this.state = &#123;&#125;，就相当于 Vue中的data() &#123; return &#123;&#125; &#125;    this.state = &#123;      msg: &quot;这是Movie组件的私有数据&quot;    &#125;;  &#125;  render() &#123;    &#123;      /* 注意：在 class 组件内容，this 表示当前组件的实例对象 */    &#125;    return &lt;div&gt;这是Movie组件 -- &#123;this.props.name&#125;&lt;/div&gt;;  &#125;&#125;const user = &#123;  name: &quot;大黄&quot;,  age: 3,  gender: &quot;雄性&quot;&#125;;ReactDOM.render(  &lt;div&gt;    &lt;Movie &#123;...user&#125; /&gt;    &lt;h3&gt;&#123;this.state.msg&#125;&lt;/h3&gt;  &lt;/div&gt;,  document.getElementById(&quot;#app&quot;));</code></pre><h3 id="两种创建组件的方式的对比"><a href="#两种创建组件的方式的对比" class="headerlink" title="两种创建组件的方式的对比"></a>两种创建组件的方式的对比</h3><blockquote><p>使用 <code>class</code> 关键字创建的组件，有自己的 <code>私有数据(this.state)</code> 和 <code>生命周期</code><br>使用 <code>function</code> 创建的组件，只有 <code>props</code>，没有自己的 <code>私有数据</code> 和 <code>生命周期</code><br>有状态组件和无状态组件之间的 <code>本质区别</code>：有无 <code>state</code> 属性和 <code>生命周期函数</code></p></blockquote><h2 id="3-React-中-style-处理方式"><a href="#3-React-中-style-处理方式" class="headerlink" title="3. React 中 style 处理方式"></a>3. React 中 style 处理方式</h2><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><pre><code class="jsx">style = &#123;&#123; color: red &#125;&#125;</code></pre><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><blockquote><p>1、如果直接导入 <code>css</code> 样式表，默认则是在全局上，整个项目都会生效<br>2、css 模块化，只针对 <code>class</code> 选择器 和 <code>id</code> 选择器生效<br>引用：<code>import style from &#39;./style.css&#39;</code></p></blockquote><h2 id="4-React-中事件绑定"><a href="#4-React-中事件绑定" class="headerlink" title="4. React 中事件绑定"></a>4. React 中事件绑定</h2><ol><li>事件的名称都是 <code>React</code> 所提供的，因此名称的首字母必须大写<code>onClick</code>，<code>onMouseOver</code></li><li>为事件提供的处理函数，必须是以下格式：</li></ol><pre><code class="javascript">onClick = &#123; function &#125;;</code></pre><ol start="3"><li>用的最多的事件绑定形式为：</li></ol><pre><code class="jsx">&lt;button onClick=&#123;() =&gt; this.show(&quot;传参&quot;)&#125;&gt;按钮&lt;/button&gt;;// 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称show = arg1 =&gt; &#123;  console.log(&quot;show方法&quot; + arg1);&#125;;</code></pre><ol start="4"><li>在 <code>React</code> 中，如果想要修改 <code>state</code> 中的数据，推荐使用 <code>this.setState(&#123; &#125;)</code></li></ol><blockquote><p>1、在<code>setState</code>中，只会把对应的 <code>state</code>状态更新，而不会覆盖其它的 <code>state</code>状态。<br>2、<code>this.setState</code> 方法的执行时 <code>异步的</code>。<br>3、如果在调用完 <code>this.setState</code>之后，又想立即拿到最新的<code>state</code>的值，需要使用 <code>this.setState(&#123;&#125;, callback)</code>，第二个参数【回调函数】中获取。</p></blockquote><h2 id="5-单向数据流-状态变化-gt-自动更新页面"><a href="#5-单向数据流-状态变化-gt-自动更新页面" class="headerlink" title="5. 单向数据流(状态变化 =&gt; 自动更新页面)"></a>5. 单向数据流(状态变化 =&gt; 自动更新页面)</h2><blockquote><p>1、<code>React</code> 中，默认是 <code>单向数据流</code>，只能把 <code>state</code> 上的数据绑定到页面，无法把页面中数据的变化，自动同步回 <code>state</code>；如果需要把页面上数据的变化，保存到 <code>state</code>，需要手动监听<code>onChange</code> 事件，拿到最新的数据，手动调用 <code>this.setState(&#123; &#125;)</code> 更改。<br>2、当为文本框绑定 <code>value</code> 值以后，要么同时给标签提供一个 <code>readOnly</code> 属性，要么提供一个 <code>onChange</code> 事件处理函数。</p></blockquote><pre><code class="jsx">// 方案一：通过事件参数 e 来获取DOM元素的引用&lt;input type=&quot;text&quot; value=&#123;this.state.msg&#125; onChange=&#123;e =&gt; this.textChanged(e)&#125; /&gt;;textChanged = e =&gt; &#123;  console.log(e.target.value);&#125;;// 方案二：通过ref 来获取DOM元素的引用  this.refs.引用名称&lt;input type=&quot;text&quot; value=&#123;this.state.msg&#125; onChange=&#123;() =&gt; this.textChanged()&#125; ref=&quot;txt&quot; /&gt;;textChanged = () =&gt; &#123;  console.log(this.refs.txt.value);&#125;;</code></pre><h2 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6. 生命周期"></a>6. 生命周期</h2><ul><li>生命周期介绍</li></ul><blockquote><p>每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会触发一系列事件，这些事件就叫做组件的生命周期</p></blockquote><ul><li>React 的生命周期分为三个部分</li></ul><ol><li>组件创建阶段</li></ol><blockquote><p>只执行一次</p></blockquote><blockquote><ol><li><code>componentWillMount</code> =&gt; <code>挂载之前</code></li><li><code>render</code> =&gt; <code>正在渲染，虚拟DOM创建到了内存中，还未挂载到页面上</code></li><li><code>componentDidMount</code> =&gt; <code>挂载结束，需要操作DOM节点的初始化操作放在这里</code></li></ol></blockquote><ol start="2"><li>组件运行阶段：</li></ol><blockquote><p>根据 <code>props</code> 属性或者 <code>state</code> 状态的改变，有选择性的执行 <code>0</code> 到 <code>多次</code></p></blockquote><blockquote><ol><li><code>props</code> 改变之后</li><li><code>componentWillReceiveProps</code> =&gt; 当一个挂载的组件接收到新的 <code>props</code> 的时候被调用</li><li><code>state</code> 改变之后</li><li><code>shouldComponentUpdate（nextprops, nextState）</code> =&gt; 当组件做出是否要更新 <code>DOM</code> 的决定的时候被调用，在改变状态的时候可以选择通过( <code>return true</code> )或者不通过( <code>return false</code>)</li><li><code>componentWillUpdate</code> =&gt; 在更新发生之前被调用</li><li><code>render</code> =&gt; 数据是新的，页面是旧的</li></ol><p>7.<code>componentDidUpdate</code> =&gt; 数据是新的，页面已经变成了最新的</p></blockquote><ol start="3"><li>组件销毁阶段</li></ol><blockquote><p>只执行一次</p></blockquote><blockquote><p><code>componentWillUnmount</code> =&gt; 组件移除或者销毁的时候被调用</p></blockquote><h2 id="7-验证数据类型"><a href="#7-验证数据类型" class="headerlink" title="7. 验证数据类型"></a>7. 验证数据类型</h2><pre><code class="javascript">import &#123; ProtoTypes &#125; from &quot;prop-types&quot;;// 定义组件需要传入的参数MyCompo.protoTypes = &#123;  a: ProtoTypes.string.isRequired,  b: ProtoTypes.string.isRequired,  c: ProtoTypes.number.isRequired&#125;;</code></pre><h2 id="8-flux"><a href="#8-flux" class="headerlink" title="8. flux"></a>8. flux</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>传统的 <code>MVC</code> 和 <code>MVVM</code> 架构设计模式有一个致命的缺点：当项目越来越大、逻辑越来越复杂的时候，数据流动就越显得混乱。</p></blockquote><blockquote><p><code>Flux</code> 是致力于解决数据有序传输问题的架构设计模式，来自 <code>Facebook</code>。<code>Flux</code> 中最大的哲学：数据是 <code>单向流动</code> 的。</p></blockquote><blockquote><p><a href="https://github.com/facebook/flux/tree/master/examples/flux-concepts" target="_blank" rel="noopener external nofollow noreferrer">官方手册</a></p></blockquote><blockquote><p><code>Flux</code> 中最重要的四个概念：<code>Dispatcher</code>、<code>Store</code>、<code>View</code>、<code>Action</code>。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703835856-e1263bac-124a-40da-ae3c-b45a4c8081ae.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=flux.png&originHeight=393&originWidth=1300&size=26132&status=done&style=none&width=1300" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703835856-e1263bac-124a-40da-ae3c-b45a4c8081ae.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=flux.png&originHeight=393&originWidth=1300&size=26132&status=done&style=none&width=1300" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="flux.png"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>概述<ul><li><code>flux</code> 是一个管理 <code>App</code> 中数据流动的模式。</li><li>最关键的概念：<code>数据的流动是单向的</code>。</li></ul></li><li>Dispatcher 调度者<ul><li><code>Dispatcher</code> 接受 <code>action</code>，并且要把这些 <code>action</code> 分派给已经注册到 <code>Dispatcher</code> 的 <code>store</code> 上</li><li>所有的 <code>store</code> 都将接收所有的 <code>action</code></li><li>在每个 <code>App</code> 中，应该确保只有一个 <code>Dispatcher</code> 的实例</li></ul></li><li>store 仓库<ul><li><code>store</code> 是在 <code>App</code> 中持有数据的仓库</li><li>所有的 <code>store</code> 要在 <code>App</code> 的 <code>Dispatcher</code> 上注册，确保它们可以接收 <code>action</code></li><li><code>store</code> 中的数据只能被 <code>action</code> 改变。</li><li><code>store</code> 中不能够有公共的 <code>setter</code>，只能有 <code>getter</code></li><li><code>store</code> 决定了它们愿意响应哪些 <code>actions</code></li><li>无论何时，<code>store</code> 中的数据发生改变，就会触发一个 <code>change</code> 事件</li><li>同一个 <code>App</code> 中可能有很多 <code>store</code></li></ul></li><li>Action 行为<ul><li><code>Action</code> 定义了 <code>App</code> 内部的 <code>API</code></li><li>它们捕获所有可能改变 <code>App</code> 的途径和方法</li><li>它们是简单的<code>对象</code>，并且要有 <code>type属性</code> 和 <code>其他的一些数据属性</code></li><li><code>Action</code> 应该有一个具有语义的、直观的表示它是做什么的名字</li><li>所有的<code>store</code>都将接收同一个<code>action</code>，并且通过这个 <code>action</code>，<code>store</code> 会知道它们要清除、更新哪些数据</li></ul></li><li>Views 视图<ul><li><code>store</code> 中的数据被展示在了<code>view</code>上</li><li><code>View</code> 层可以使用任何框架</li><li>当一个视图想要获取 <code>store</code> 中的数据，它必须 <code>subscribe 订阅</code> 一下该 <code>store</code> 的<code>change</code> 事件</li><li>当 <code>store</code> 触发了 <code>change</code> 事件，此时 <code>view</code> 就能得到新的数据并且重新渲染</li><li>如果一个组件要使用 <code>store</code>，但是没有订阅这个 <code>store</code>，此时就会出错</li><li><code>Action</code> 最常见的产生原因是：在 <code>App</code> 中的某一个部分，因为用户的交互行为，而被此<code>view</code> <code>dispatch</code>出来了</li></ul></li></ol><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><ul><li>简介<ul><li><a href="https://redux.js.org/" target="_blank" rel="noopener external nofollow noreferrer">官网</a></li><li>Redux 就是 Flux 思想在 React 中的实现</li><li>Redux 是一个可预测状态的 Js app 容器</li><li><a href="https://github.com/reactjs/redux/tree/master/examples" target="_blank" rel="noopener external nofollow noreferrer"><code>通过例子来学习redux</code></a></li></ul></li><li>Redux 创建的步骤<ul><li>设置一个 <code>reducer</code>；</li><li>创建一个<code>store</code>，<code>Redux.createStore(reducer)</code></li><li>创建 <code>render</code> 函数</li><li>注册 <code>render</code>，<code>store.subscribe(render)</code></li><li>监听，此时要记得 <code>store.dispatch(action)</code>，不是直接修改<code>store</code></li></ul></li></ul><h3 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h3><ul><li>简介<ul><li>将 <code>react</code> 和 <code>redux</code> 合并起来，可以让任何组件在任何地方看见 <code>store</code></li><li><a href="https://github.com/reactjs/react-redux/tree/master/docs" target="_blank" rel="noopener external nofollow noreferrer">官方文档</a></li><li><code>React-Redux</code> 给我们提供了：<code>Provider组件</code>，<code>connect函数</code></li></ul></li><li>Provider 组件</li></ul><blockquote><p>1、使用 <code>react-redux</code> 提供的 <code>Provider</code> 组件传递 <code>store</code> 上下文之后，<code>包裹在其中的所有组件</code> 全都可以识别这个上下文</p></blockquote><blockquote><p>2、在 <code>Provider</code> 组件内部的自定义组件可以使用 <code>connect()</code> 函数，但是在其外部的不可使用</p></blockquote><ul><li>connect 函数</li></ul><blockquote><p>1、将 <code>React组件</code> 和 <code>Redux</code> 的 <code>store</code> 进行连接<br>2、<code>connect</code> 提供了一个很方便的 <code>API</code> 能够适应绝大多数工作<br>3、它没有更改你传进来的类，反而会返回一个已经连接好的新类<br>4、提供了两个参数：<code>mapStateToProps</code>, <code>mapDispatchToProps</code></p></blockquote><ul><li>mapStateToProps</li></ul><blockquote><p>1、如果传入<code>mapStateToProps</code>，此时这个组件将订阅 <code>Redux</code> 中 <code>store</code> 的更新信息；<br>2、这意味着无论任何时候 <code>store</code> 被更改了，<code>mapStateToProps</code> 函数都将会被调用，<code>mapStateToProps</code> 的返回值必须是一个 <code>Object</code>；<br>3、这个 <code>Object</code> 将与组件的 <code>props</code> 融合，也就是说，这个返回的 <code>Object</code> 中的 <code>key</code> 将自动成为组件的 <code>props</code> 中的成员<br>4、如果不想订阅 <code>store</code> 的更新，此时可以不传递这个参数，采用 <code>null</code> 占位</p></blockquote><ul><li>mapDispatchToProps</li></ul><blockquote><p>如果向 <code>connect</code> 函数中传入了第二个参数，并且是一个 <code>函数</code>，那么这个函数将获得<code>dispatch</code> 方法，该方法可以通过 <code>emit action</code>，间接的导致 <code>state</code> 的改变<br>可以使用 <code>bindActionCreators()</code> 方法轻松的将 <code>Action creator</code>(返回 <code>action</code> 的函数)接口和 <code>dispatch</code> 进行绑定</p></blockquote><ul><li>书写规则</li></ul><blockquote><p>index.js</p></blockquote><pre><code class="jsx">import React from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;import &#123; createStore &#125; from &quot;redux&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import App from &quot;./containers/App&quot;;import reducer from &quot;./reducers&quot;;const store = createStore(reducer);render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;,  document.getElementById(&quot;root&quot;));</code></pre><blockquote><p>App.js</p></blockquote><pre><code class="jsx">import React from &quot;react&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import * as actions from &quot;./actions&quot;;class App extends React.Component &#123;  constructor(props) &#123;    super();    console.log(props);    // props: &#123; r: 0, g: 0, b: 0, actions: 许多方法 &#125;  &#125;  render() &#123;    return &lt;div&gt;这是App组件&lt;/div&gt;;  &#125;&#125;const mapStateToProps = state =&gt; &#123;  return &#123;    r: state.r,    g: state.g,    b: state.b  &#125;;&#125;;const mapDispatchToProps = dispatch =&gt; &#123;  return &#123;    actions: bindActionCreators(actions, dispatch)  &#125;;&#125;;export default connect(mapStateToProps, mapDispatchToProps)(App);</code></pre><blockquote><p>reducer.js</p></blockquote><pre><code class="jsx">export default (state, action) =&gt; &#123;  if (state == undefined) &#123;    state = &#123; r: 0, g: 0, b: 0 &#125;;  &#125;  if (action.type == &quot;ADD&quot;) &#123;    return &#123;      ...state,      r: state.r + 1    &#125;;  &#125;  return state;&#125;;</code></pre><blockquote><p>actions.js</p></blockquote><pre><code class="jsx">export const ADD = () =&gt; &#123; &quot;type&quot;: &quot;ADD&quot; &#125;</code></pre><h3 id="组件内部的-state-和全局的-state"><a href="#组件内部的-state-和全局的-state" class="headerlink" title="组件内部的 state 和全局的 state"></a>组件内部的 state 和全局的 state</h3><blockquote><p>组件的数据三兄弟：<code>state</code>, <code>props</code>, <code>context</code> 不管是谁发生改变，都会引发 <code>render()</code> 执行，视图会被重绘。但是，构造函数不会被重新执行。所以不管基于什么理由，都不需要将全局的状态，用自己组件的 <code>state</code> 接收，而仅需要用<code>connect</code>连接一下全局<code>store</code>，然后使用<code>this.props.**</code>即可。</p></blockquote><h3 id="reducer-模块化"><a href="#reducer-模块化" class="headerlink" title="reducer 模块化"></a>reducer 模块化</h3><pre><code class="javascript">import &#123; combineReducers &#125; from &quot;redux&quot;;import todoReducers from &quot;./todoReducer.js&quot;; // 标准reducerexport default combineReducers(&#123;  todoReducers&#125;);</code></pre><h3 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h3><blockquote><p>打印 redux log</p></blockquote><pre><code class="javascript">import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;import &#123; createLogger &#125; from &quot;redux-logger&quot;;import reducer from &quot;./reducers/index.js&quot;;let store = createStore(reducer, applyMiddleware(createLogger()));</code></pre><h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><blockquote><p>解决异步问题</p></blockquote><blockquote><p><code>redux-thunk</code>帮助我们在所有的组件的 <code>props</code> 中添加了一个 <code>dispatch</code> 方法。</p></blockquote><blockquote><p>当然，这个组件一定要被 <code>connect</code> 函数进行处理</p></blockquote><blockquote><p>注意，如果使用 <code>thunk</code>，则 <code>connect</code> 函数不能传入第二个参数，否则会导致无法获取 <code>this.props.dispatch()</code></p></blockquote><pre><code class="javascript">// 入口文件import &#123; createStore, applyMiddleware &#125; from &#39;redux&#39;;import thunk from &#39;redux-thunk&#39;;let store = createStore(reducer, applyMiddleware(thunk))/** 组件中 *//** 第一种写法，并没有将actions进行抽离 */$.get(&#39;/shu.txt&#39;, data =&gt; &#123;    var number = Number(data);    this.props.dispatch(&#123;        &quot;type&quot;: &quot;ADD&quot;,        number    &#125;)&#125;)/** 第二种写法:常用 */// 可枚举import * as actions from &#39;./actions/actions.js&#39;class ** extends React.Component &#123;    ...    add() &#123;        this.props.dispatch(actions.add())        this.props.dispatch(actions.minus())    &#125;    ...&#125;/** 现在，一般不会再写第二个参数了，就是说省略掉mapDispatchToProps */export default connect( (state) =&gt; &#123;    return &#123;        state: state    &#125; &#125;)(**)// actions.js/* 现在，异步的Action Creator不要直接返回 Action，而是返回一个携带 dispatch 的函数；这个函数相当于“延长”了dispatch的持续时间。*/export const add = () =&gt; (dispatch, getState) =&gt; &#123;    console.log(getState()) // getState可以获取全局数据    $.get(&#39;/shu.txt&#39;, data =&gt; &#123;        var number = Number(data);        dispatch(&#123;&quot;type&quot;: &quot;MINUS&quot;, number&#125;)    &#125;)&#125;export const minus = () =&gt; &#123; &quot;type&quot;: &quot;MINUS&quot; &#125;// reducer.jsexport default (state = 0, action) =&gt; &#123;    switch(action.type) &#123;        case &quot;ADD&quot;:            return state + action.number        case &quot;MINUS&quot;:            return state - 1    &#125;    return state;&#125;</code></pre><h2 id="9-react-router4-x"><a href="#9-react-router4-x" class="headerlink" title="9. react-router4.x"></a>9. react-router4.x</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><a href="https://reacttraining.com/react-router" target="_blank" rel="noopener external nofollow noreferrer">官网</a></li><li>安装：<code>npm install react-router-dom</code></li></ul><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><blockquote><p><code>exact</code>表示严格匹配，如果路径为 <code>path=&quot;/&quot;</code> 的 <code>Route</code> 不设置该属性，则会自动向下匹配路由，即都会显示出来</p></blockquote><pre><code class="jsx">import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;;function Index() &#123;  return &lt;h2&gt;Home&lt;/h2&gt;;&#125;function About() &#123;  return &lt;h2&gt;About&lt;/h2&gt;;&#125;function Users() &#123;  return &lt;h2&gt;Users&lt;/h2&gt;;&#125;function AppRouter() &#123;  return (    &lt;Router&gt;      &lt;div&gt;        &lt;nav&gt;          &lt;ul&gt;            &lt;li&gt;              &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;            &lt;/li&gt;            &lt;li&gt;              &lt;Link to=&quot;/about/&quot;&gt;About&lt;/Link&gt;            &lt;/li&gt;            &lt;li&gt;              &lt;Link to=&quot;/users/&quot;&gt;Users&lt;/Link&gt;            &lt;/li&gt;          &lt;/ul&gt;        &lt;/nav&gt;        &lt;Route path=&quot;/&quot; exact component=&#123;Index&#125; /&gt;        &lt;Route path=&quot;/about/&quot; component=&#123;About&#125; /&gt;        &lt;Route path=&quot;/users/&quot; component=&#123;Users&#125; /&gt;      &lt;/div&gt;    &lt;/Router&gt;  );&#125;export default AppRouter;</code></pre><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><pre><code class="jsx">// App.js 定义动态路由&lt;Route path=&quot;/content/:aid&quot;&gt;&lt;/Route&gt;// news.js 跳转&lt;Link to=&#123;`/content/$&#123;value.aid&#125;`&#125;&gt;&lt;/Link&gt;// Content.js 跳在生命周期函数中获取动态路由参数class Content extends Component &#123;    /* ... */      componentDidMount() &#123;          const &#123; match &#125; = this.props          // 获取到传递的动态路由参数          console.log(match.params.aid)      &#125;    /* ... */&#125;</code></pre><h3 id="get-传值"><a href="#get-传值" class="headerlink" title="get 传值"></a>get 传值</h3><pre><code class="jsx">// App.js 定义动态路由&lt;Route path=&quot;/content&quot;&gt;&lt;/Route&gt;// news.js 跳转&lt;Link to=&#123;`/content?aid=$&#123;value.aid&#125;`&#125;&gt;&lt;/Link&gt;// Content.js 跳在生命周期函数中获取动态路由参数class Content extends Component &#123;    ...      componentDidMount() &#123;          const &#123; location &#125; = this.props          // 获取到传递的动态路由参数          console.log(location.search)      &#125;    ...&#125;</code></pre><h3 id="js-控制跳转"><a href="#js-控制跳转" class="headerlink" title="js 控制跳转"></a>js 控制跳转</h3><ol><li>引入 <code>Redirect</code> 组件</li><li>定义一个 <code>flag</code></li></ol><pre><code class="javascript">this.state = &#123;  loginFlag: false&#125;;</code></pre><ol start="3"><li>在 <code>Render</code> 中判断 <code>flag</code>，从而来决定是否进行跳转</li></ol><pre><code class="jsx">if (this.state.loginFlag) &#123;  return &lt;Redirect to=&#123;&#123; pathname: "/" &#125;&#125; /&gt;;&#125;</code></pre><ol start="4"><li>执行 <code>js</code> 跳转，通过 <code>js</code> 改变 <code>loginFlag</code> 的状态，改变以后，就可以从新的 <code>render</code> 中通过 <code>Redirect</code> 自己进行跳转</li></ol><h3 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h3><blockquote><p>router.js</p></blockquote><pre><code class="jsx">import Home from &quot;./components/Home/&quot;;import About from &quot;./components/About/&quot;;import User from &quot;./components/User/&quot;;import UserList from &quot;./User/UserList&quot;;import UserInfo from &quot;./User/UserInfo&quot;;let router = [  &#123;    path: &quot;/&quot;,    component: Home,    exact: true  &#125;,  &#123;    path: &quot;/about&quot;,    component: About  &#125;,  &#123;    path: &quot;/User&quot;,    component: User,    routes: [      // 嵌套路由设置      &#123;        path: &quot;/user/&quot;,        component: UserList      &#125;,      &#123;        path: &quot;/user/info&quot;,        component: UserInfo      &#125;    ]  &#125;];export default router;</code></pre><blockquote><p>App.js 入口文件</p></blockquote><pre><code class="jsx">import React, &#123; Component &#125; from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;;import router from &quot;./router.js&quot;;class App extends Component &#123;  render() &#123;    return (      &lt;Router&gt;        &lt;div&gt;          &#123;router.map((route, key) =&gt; &#123;            if (route.exact) &#123;              return (                &lt;Route                  exact                  key=&#123;key&#125;                  path=&#123;route.path&#125;                  render=&#123;props =&gt; (                    // 向子组件传递子路由                    &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;                  )&#125;                /&gt;              );            &#125; else &#123;              return (                &lt;Route                  key=&#123;key&#125;                  path=&#123;route.path&#125;                  render=&#123;props =&gt; (                    // 向子组件传递子路由                    &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;                  )&#125;                /&gt;              );            &#125;          &#125;)&#125;        &lt;/div&gt;      &lt;/Router&gt;    );  &#125;&#125;</code></pre><blockquote><p>User.js</p></blockquote><pre><code class="jsx">import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Route, Link &#125; from &quot;react-router-dom&quot;;class User extends Component &#123;  componentWillMount() &#123;    console.log(this.props.routes);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;div className=&quot;contenr&quot;&gt;          &lt;div className=&quot;left&quot;&gt;            &lt;Link /&gt;          &lt;/div&gt;          &lt;div className=&quot;right&quot;&gt;            &#123;this.props.routes.map((route, key) =&gt; &#123;              return &lt;Route exact key=&#123;key&#125; path=&#123;route.path&#125; component=&#123;route.component&#125; /&gt;;            &#125;)&#125;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;export default User;</code></pre><h3 id="常用路由组件"><a href="#常用路由组件" class="headerlink" title="常用路由组件"></a>常用路由组件</h3><ul><li>_BrowserRouter_：使用 <code>HTML5</code> 历史记录 <code>API</code> (<code>pushState</code>，<code>replaceState</code> 和<code>popstate</code> 事件)的 <code>&lt;Router&gt;</code> 来保持 <code>UI</code> 与 <code>URL</code> 的同步</li><li>_HashRouter_：使用 <code>URL</code> 的哈希部分(即 <code>window.location.hash</code> )的&lt;路由器&gt;可以保持您的 <code>UI</code> 与 <code>URL</code> 同步。注意：哈希历史记录不支持 <code>location.key</code> 或 <code>location.state</code>。 在以前的版本中，我们试图缓和行为，但是有一些边缘案例我们无法解决。 任何需要此行为的代码或插件将无法正常工作。 由于此技术仅用于支持旧版浏览器，因此我们建议您将服务器配置为使用<code>&lt;BrowserHistory&gt;</code></li><li>_Link_：渲染成 <code>a</code> 标签</li><li>_NavLink_：一种特殊版本的 <code>&lt;Link&gt;</code>，当与当前 <code>URL</code> 匹配时，将向渲染元素添加样式属性。</li><li>_Redirect_：重定向</li><li>_Route_：在位置与路线的路径匹配时呈现一些 <code>UI</code>。</li><li>_Switch_：只渲染命中的第一个 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code> 。</li></ul><pre><code class="jsx">// Switch的用法import &#123; Switch, Route &#125; from &quot;react-router&quot;;&lt;Switch&gt;  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;  &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt;  &lt;Route path=&quot;/:user&quot; component=&#123;User&#125; /&gt;  &lt;Route component=&#123;NoMatch&#125; /&gt;&lt;/Switch&gt;;</code></pre><h2 id="10-context"><a href="#10-context" class="headerlink" title="10. context"></a>10. context</h2><ul><li>介绍</li></ul><blockquote><p>在一个典型的 <code>React</code> 应用中，数据是通过 <code>props</code> 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，<code>UI</code> 主题），这些属性是应用程序中许多组件都需要的。<code>Context</code> 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 <code>props</code>。</p></blockquote><ul><li>繁琐的 <code>props</code> 方式</li></ul><pre><code class="jsx">class App extends React.Component &#123;  render() &#123;    return &lt;Toolbar theme=&quot;dark&quot; /&gt;;  &#125;&#125;function Toolbar(props) &#123;  return (    &lt;div&gt;      &lt;ThemeButton theme=&#123;props.theme&#125; /&gt;    &lt;/div&gt;  );&#125;class ThemeButton extends React.Component &#123;  render() &#123;    &lt;Button theme=&#123;this.props.theme&#125;&gt;按钮&lt;/Button&gt;;  &#125;&#125;</code></pre><ul><li>使用 <code>context</code></li></ul><pre><code class="jsx">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。// 为当前的 theme 创建一个 context（“light”为默认值）。const ThemeContext = React.createContext(&quot;light&quot;);class App extends React.Component &#123;  render() &#123;    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。    // 无论多深，任何组件都能读取这个值。    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。    return (      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;        &lt;Toolbar /&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function ToolBar() &#123;  return (    &lt;div&gt;      &lt;ThemeButton /&gt;    &lt;/div&gt;  );&#125;class ThemeButton extends React.Component &#123;  // 指定 contextType 读取当前的 theme context。  // React 会往上找到最近的 theme Provider，然后使用它的值。  // 在这个例子中，当前的 theme 值为 “dark”。  static contextType = ThemeContext;  render() &#123;    return &lt;Button theme=&#123;this.context&#125;&gt;按钮&lt;/Button&gt;;  &#125;&#125;</code></pre><h2 id="11-react-hooks"><a href="#11-react-hooks" class="headerlink" title="11. react-hooks"></a>11. react-hooks</h2><blockquote><p><code>Hook</code> 是 <code>React 16.8</code> 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。</p></blockquote><h3 id="11-1-State-Hook"><a href="#11-1-State-Hook" class="headerlink" title="11.1 State Hook"></a>11.1 State Hook</h3><blockquote><p><code>useState</code> 就是一个 <code>Hook</code>，类似 <code>class</code> 组件的 <code>this.setState</code>，但是它不会把新的 <code>state</code> 和旧的 <code>state</code> 进行合并。<code>useState</code> 会返回一对值：<em>当前状态</em> 和一个让你 _更新它的函数_，你可以在事件处理函数中或其他一些地方调用这个函数。</p></blockquote><ul><li>计数器</li></ul><pre><code class="jsx">import React, &#123; useState &#125; from &quot;react&quot;;function Example() &#123;  // 声明一个叫 “count” 的 state 变量。  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt;    &lt;/div&gt;  );&#125;// 等价的 class 示例class Example extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      count: 0    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;Click me&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><ul><li>声明多个 <code>state</code> 变量</li></ul><pre><code class="jsx">function ExampleWithManyStates() &#123;  // 声明多个 state 变量！  const [age, setAge] = useState(42);  const [fruit, setFruit] = useState(&quot;banana&quot;);  const [todos, setTodos] = useState([&#123; text: &quot;Learn Hooks&quot; &#125;]);  // ...&#125;</code></pre><ul><li>什么是 <code>Hook</code></li></ul><blockquote><p><code>Hook</code> 是一些可以让你在函数组件里“钩入” <code>React state</code> 及生命周期等特性的函数。<code>Hook</code> 不能在 <code>class</code> 组件中使用 —— 这使得你不使用 <code>class</code> 也能使用 <code>React</code>。</p></blockquote><ul><li>惰性 state</li></ul><pre><code class="jsx">const [state, setState] = useState(() =&gt; &#123;  const initialState = someExpensiveComputation(props);  return initialState;&#125;);</code></pre><h3 id="11-2-Effect-Hook"><a href="#11-2-Effect-Hook" class="headerlink" title="11.2 Effect Hook"></a>11.2 Effect Hook</h3><blockquote><p><code>Effect Hook</code> 可以让你在函数组件中执行副作用操作</p></blockquote><h4 id="1-无需清除的-Effect"><a href="#1-无需清除的-Effect" class="headerlink" title="(1) 无需清除的 Effect"></a>(1) 无需清除的 <code>Effect</code></h4><blockquote><p>有时候，我们只想在 <code>React</code> 更新 <code>DOM</code> 之后运行一些额外的代码。比如发送网络请求，手动变更 <code>DOM</code>，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p></blockquote><ul><li>使用 <code>class</code> 的示例</li></ul><pre><code class="jsx">class Example extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      count: 0    &#125;;  &#125;  componentDidMount() &#123;    document.title = `You clicked $&#123;this.state.count&#125; times`;  &#125;  componentDidUpdate() &#123;    document.title = `You clicked $&#123;this.state.count&#125; times`;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;Click me&lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><ul><li>使用 <code>Hook</code> 的示例</li></ul><pre><code class="jsx">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;function Example() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    document.title = `You clicked $&#123;count&#125; times`;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><blockquote><p><code>useEffect</code> 做了什么？ 通过使用这个 <code>Hook</code>，你可以告诉 <code>React</code> 组件需要在渲染后执行某些操作。<code>React</code> 会保存你传递的函数（我们将它称之为 “<code>effect</code>”），并且在执行 <code>DOM</code> 更新之后调用它。在这个 <code>effect</code> 中，我们设置了 <code>document</code> 的 <code>title</code> 属性，不过我们也可以执行数据获取或调用其他命令式的 API。</p></blockquote><blockquote><p>为什么在组件内部调用 <code>useEffect</code>？ 将 <code>useEffect</code> 放在组件内部让我们可以在 <code>effect</code> 中直接访问 <code>count</code> <code>state</code> 变量（或其他 <code>props</code>）。我们不需要特殊的 <code>API</code> 来读取它 —— 它已经保存在函数作用域中。<code>Hook</code> 使用了 <code>JavaScript</code> 的闭包机制，而不用在 <code>JavaScript</code> 已经提供了解决方案的情况下，还引入特定的 React API。</p></blockquote><blockquote><p><code>useEffect</code> 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 <code>effect</code> 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。<code>React</code> 保证了每次运行 <code>effect</code> 的同时，<code>DOM</code> 都已经更新完毕。</p></blockquote><div class="note warning"><p>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 <code>effect</code> 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，<code>effect</code> 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect Hook</code> 供你使用，其 <code>API</code> 与 <code>useEffect</code> 相同。</p></div><h4 id="2-需要清除的-Effect"><a href="#2-需要清除的-Effect" class="headerlink" title="(2) 需要清除的 Effect"></a>(2) 需要清除的 <code>Effect</code></h4><blockquote><p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 <code>Class</code> 和 <code>Hook</code> 来实现。</p></blockquote><ul><li>使用 <code>class</code> 的示例</li></ul><pre><code class="jsx">class FriendStatus extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; isOnline: null &#125;;    this.handleStatusChange = this.handleStatusChange.bind(this);  &#125;  componentDidMount() &#123;    ChatAPI.subscribeToFriendStatus(this.props.friend.id, this.handleStatusChange);  &#125;  componentWillUnmount() &#123;    ChatAPI.unsubscribeFromFriendStatus(this.props.friend.id, this.handleStatusChange);  &#125;  handleStatusChange(status) &#123;    this.setState(&#123;      isOnline: status.isOnline    &#125;);  &#125;  render() &#123;    if (this.state.isOnline === null) &#123;      return &quot;Loading...&quot;;    &#125;    return this.state.isOnline ? &quot;Online&quot; : &quot;Offline&quot;;  &#125;&#125;</code></pre><ul><li>使用 <code>Hook</code> 的示例</li></ul><div class="note warning"><p>眼尖的读者可能已经注意到了，这个示例还需要编写 componentDidUpdate 方法才能保证完全正确。我们先暂时忽略这一点，本章节中后续部分会介绍它。</p></div><pre><code class="jsx">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;function FriendStatus(props) &#123;  const [isOnline, setIsOnline] = useState(null);  useEffect(() =&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    // Specify how to clean up after this effect:    return function cleanup() &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);  if (isOnline === null) &#123;    return &quot;Loading...&quot;;  &#125;  return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;&#125;</code></pre><blockquote><p>为什么要在 <code>effect</code> 中返回一个函数？ 这是 <code>effect</code> 可选的清除机制。每个 <code>effect</code> 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 <code>effect</code> 的一部分。</p></blockquote><blockquote><p><code>React</code> 何时清除 <code>effect</code>？ <code>React</code> 会在组件卸载的时候执行清除操作。正如之前学到的，<code>effect</code> 在每次渲染的时候都会执行。这就是为什么 <code>React</code> 会在执行当前 <code>effect</code> 之前对上一个 <code>effect</code> 进行清除。我们稍后将讨论为什么这将助于避免 <code>bug</code> 以及如何在遇到性能问题时跳过此行为。</p></blockquote><div class="note warning"><p>并不是必须为 <code>effect</code> 中返回的函数命名。这里我们将其命名为 <code>cleanup</code> 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。</p></div><h3 id="11-3-Hook-规则"><a href="#11-3-Hook-规则" class="headerlink" title="11.3 Hook 规则"></a>11.3 Hook 规则</h3><h4 id="1-只在最顶层使用-Hook"><a href="#1-只在最顶层使用-Hook" class="headerlink" title="(1) 只在最顶层使用 Hook"></a>(1) 只在最顶层使用 <code>Hook</code></h4><blockquote><p>不要在循环，条件或嵌套函数中调用 <code>Hook</code>， 确保总是在你的 <code>React</code> 函数的最顶层调用他们。遵守这条规则，你就能确保 <code>Hook</code> 在每一次渲染中都按照同样的顺序被调用。这让 <code>React</code> 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 <code>hook</code> 状态的正确。</p></blockquote><h4 id="2-只在-React-函数中调用-Hook"><a href="#2-只在-React-函数中调用-Hook" class="headerlink" title="(2) 只在 React 函数中调用 Hook"></a>(2) 只在 <code>React</code> 函数中调用 <code>Hook</code></h4><blockquote><p>不要在普通的 <code>JavaScript</code> 函数中调用 <code>Hook</code>。你可以：</p></blockquote><ul><li>✅ 在 <code>React</code> 的函数组件中调用 <code>Hook</code></li><li>✅ 在自定义 <code>Hook</code> 中调用其他 <code>Hook</code></li></ul><h3 id="11-4-自定义-Hook"><a href="#11-4-自定义-Hook" class="headerlink" title="11.4 自定义 Hook"></a>11.4 自定义 Hook</h3><blockquote><p>通过自定义 <code>Hook</code>，可以将组件逻辑提取到可重用的函数中。</p></blockquote><h4 id="1-提取自定义-Hook"><a href="#1-提取自定义-Hook" class="headerlink" title="(1) 提取自定义 Hook"></a>(1) 提取自定义 <code>Hook</code></h4><blockquote><p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 <code>Hook</code> 都是函数，所以也同样适用这种方式。</p></blockquote><blockquote><p>自定义 <code>Hook</code> 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 <code>Hook</code>。 例如，下面的 <code>useFriendStatus</code> 是我们第一个自定义的 <code>Hook</code>:</p></blockquote><pre><code class="jsx">import &#123; useState, useEffect &#125; from &quot;react&quot;;function useFriendStatus(friendID) &#123;  const [isOnline, setIsOnline] = useState(null);  useEffect(() =&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);    return () =&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);    &#125;;  &#125;);  return isOnline;&#125;</code></pre><h4 id="2-使用自定义-Hook"><a href="#2-使用自定义-Hook" class="headerlink" title="(2) 使用自定义 Hook"></a>(2) 使用自定义 <code>Hook</code></h4><pre><code class="jsx">function FriendStatus(props) &#123;  const isOnline = useFriendStatus(props.friend.id);  if (isOnline === null) &#123;    return &quot;Loading...&quot;;  &#125;  return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;&#125;function FriendListItem(props) &#123;  const isOnline = useFriendStatus(props.friend.id);  return &lt;li style=&#123;&#123; color: isOnline ? "green" : "black" &#125;&#125;&gt;&#123;props.friend.name&#125;&lt;/li&gt;;&#125;</code></pre><h3 id="11-5-Hook-API-索引"><a href="#11-5-Hook-API-索引" class="headerlink" title="11.5 Hook API 索引"></a>11.5 Hook API 索引</h3><blockquote><p>参见 <a href="https://react.docschina.org/docs/hooks-reference.html" target="_blank" rel="noopener external nofollow noreferrer">Hook API</a></p></blockquote><h4 id="11-5-1-基础-Hook"><a href="#11-5-1-基础-Hook" class="headerlink" title="11.5.1 基础 Hook"></a>11.5.1 基础 Hook</h4><h5 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h5><blockquote><p><a href="#linkUseState">点击跳转</a></p></blockquote><h5 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h5><blockquote><p><a href="#linkUseEffect">点击跳转</a></p></blockquote><h5 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h5><blockquote><p>订阅 <code>context</code> 的变化，感觉就是对于获取 <code>context</code> 的值换了一种写法而已。相对于之前的写法，在函数组件中添加 <code>context</code> 更加简单。</p></blockquote><pre><code class="jsx">const context = React.createContext(&#123;&#125;)const &#123; Provider, Consumer  &#125; = context;// hooks的写法class App extends React.Component &#123;    return (        &lt;Provider value=&#123;&#123; name: 'li' &#125;&#125;&gt;            &lt;Hello/&gt;        &lt;/Provider&gt;    &lt;/div&gt;&#125;function Hello () &#123;    const value = useContext(context);    return &lt;h1&gt;value: &#123;value.name&#125;&lt;/h1&gt;&#125;// 原本的写法function Hello (props) &#123;    function render (&#123;name&#125;) &#123;      return &lt;h1&gt;value: &#123;value.name&#125;&lt;/h1&gt;    &#125;    return (      &lt;Consumer&gt;        &#123;render&#125;      &lt;/Consumer&gt;    )&#125;</code></pre><h4 id="11-5-2-额外的-Hook"><a href="#11-5-2-额外的-Hook" class="headerlink" title="11.5.2 额外的 Hook"></a>11.5.2 额外的 Hook</h4><h5 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h5><blockquote><p>类似于 <code>redux</code> 那样的状态更新方案。使用场景（基本上就是 <code>redux</code> 的应用场景），管理的状态值是对象，并且键值较多。<code>state</code> 每个 <code>key</code> 修改的逻辑比较复杂，需要单独放到一个文件里面管理。</p></blockquote><pre><code class="jsx">const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &quot;increment&quot;:      return &#123; count: state.count + 1 &#125;;    case &quot;decrement&quot;:      return &#123; count: state.count - 1 &#125;;    default:      throw new Error();  &#125;&#125;function Counter() &#123;  const [state, dispatch] = useReducer(reducer, initialState);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;+&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-&lt;/button&gt;    &lt;/&gt;  );&#125;</code></pre><h5 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h5><blockquote><p>仅在指定的依赖项发生变化时，会返回一个新的函数引用，函数体并没有发生变化。</p></blockquote><pre><code class="jsx">const memoizedCallback = useCallback(() =&gt; &#123;  doSomething(a, b);&#125;, [a, b]);</code></pre><blockquote><p>这样使用的好处：不会在每次组件 <code>render</code> 的时候，重新生成一个函数，节省开销。例如</p></blockquote><pre><code class="jsx">function f() &#123;  const cacheCallback = useCallback(() =&gt; &#123;    doSomething(a, b);  &#125;, [a, b]);  // 和下面这样的形式相比, 每次组件渲染的时候，都会重新创建一个 doSometing 函数  function doSometing(a, b) &#123;&#125;&#125;</code></pre><blockquote><p>可以保持函数的引用保持不变。我们都知道在类组件，事件处理函数基本上都是通过 <code>this.method</code> 的方式绑定的，这样做的方式有一个好处，对方法的引用一直保持不变。 那么在函数组件就可以通过使用 <code>useCallback</code> 来实现。</p></blockquote><blockquote><p>可以实现在子组件把该回调作为依赖处理。</p></blockquote><pre><code class="jsx">function Parent(&#123; a, b &#125;) &#123;  const cacheCallback = useCallback(() =&gt; &#123;    doSometing(a, b);  &#125;, [a, b]);  return &lt;Child handler=&#123;cacheCallback&#125; /&gt;;&#125;function Child(&#123; handler &#125;) &#123;  useEffect(() =&gt; &#123;    handler();  &#125;, [handler]);&#125;</code></pre><h5 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h5><blockquote><p>类似于 <code>vue</code> 的 <code>computed</code>，在依赖发生变化的时候重新计算缓存值。其实自己实现起来也很容易，和 <code>vue</code> 的计算属性不同的是，<code>vue</code> 的计算属性是自动收集依赖的，而使用 <code>useMeno</code> 需要手动在数组种传入依赖项。</p></blockquote><pre><code class="jsx">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code></pre><blockquote><p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p></blockquote><h5 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h5><blockquote><p>故名思义，该 <code>hook</code> 主要是用来获取组件实例或者或者 <code>dom</code> 节点。 但是它更有用的地方，是可以返回一个在组件生命周期内，引用不变的对象。</p></blockquote><pre><code class="jsx">function f() &#123;  const elRef = uesRef(null);  return &lt;div ref=&#123;elRef&#125;&gt;&lt;/div&gt;;&#125;</code></pre><blockquote><p>用来存储数据的话，考虑下面的场景。</p></blockquote><pre><code class="jsx">let handler = () =&gt; &#123;&#125;; // 事件处理函数// 不使用 useRef, 可以使用函数外部的一个变量来存储数据function f() &#123;  useEffect(() =&gt; &#123;    window.addEventListener(&quot;scroll&quot;, handler);  &#125;, []);  const moveScroll = useCallback(() =&gt; &#123;    window.removeEventListener(&quot;scorll&quot;, handler);  &#125;, []);  return (    &lt;div onClick=&#123;moveScroll&#125; ref=&#123;elRef&#125;&gt;      移除scroll监听    &lt;/div&gt;  );&#125;// 使用useRef的版本，可以使代码更加内聚。但是前提是必须要理解useRef这个hooks。function f() &#123;  const handler = useRef(null);  handler.current = () =&gt; &#123;&#125;; // 事件处理  useEffect(() =&gt; &#123;    window.addEventListener(&quot;scroll&quot;, handler.current);  &#125;, []);  const moveScroll = useCallback(() =&gt; &#123;    window.removeEventListener(&quot;scorll&quot;, handler.current);  &#125;, []);  return (    &lt;div onClick=&#123;moveScroll&#125; ref=&#123;elRef&#125;&gt;      移除scroll监听    &lt;/div&gt;  );&#125;</code></pre><h5 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h5><blockquote><p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。</p></blockquote><pre><code class="jsx">const Fancy = React.forwardRef((props, ref) =&gt; &#123;  return (    &lt;div&gt;      &lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;    &lt;/div&gt;  );&#125;);function Hello() &#123;  const ref = useRef(null);  useEffect(() =&gt; &#123;    console.log(&quot;current&quot;, ref); // &#123; current: Input &#125;  &#125;, []);  return &lt;Fancy ref=&#123;ref&#125; /&gt;;&#125;</code></pre><h5 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h5><blockquote><p>函数签名和 <code>useEffect</code> 是一样的， 可以使用它来读取 <code>DOM</code> 布局并 <code>同步</code> 触发重渲染。</p></blockquote><h5 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h5><blockquote><p>用来给 <code>hooks</code> 添加上打印信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 数据驱动</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据驱动？"><a href="#什么是数据驱动？" class="headerlink" title="什么是数据驱动？"></a>什么是数据驱动？</h2><blockquote><p>当数据发生改变的时候，用户界面发生相应的变化，并且开发者不需要去手动操作 <code>dom</code></p></blockquote><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul><li><code>vue</code> 在实例化的过程中，会对实例化对象选项中的 <code>data</code> 选项进行遍历,遍历其所有的属性并使用 <code>Object.defineProperty</code> 把这些属性全部转化成 <code>getter/setter</code>。</li><li>于此同时，每一个实例化对象都有一个 <code>watcher</code> 实例对象，他会在模板编译的过程中，用 <code>getter</code> 去访问 <code>data</code> 中的属性，<code>watcher</code> 此时就会把用到的 <code>data</code> 属性记为依赖，这样就建立了视图与数据之间的联系。</li><li>之后当我们渲染视图的数据依赖发生改变（即数据的 <code>setter</code> 被调用）的时候，<code>watcher</code> 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。</li></ul><h2 id="通俗原理"><a href="#通俗原理" class="headerlink" title="通俗原理"></a>通俗原理</h2><ul><li>在普通 <code>HTML</code> 模板中使用特殊语法将 <code>DOM</code> “绑定”到底层数据。</li><li>一旦创建了绑定，<code>DOM</code> 将与数据保持同步。</li><li>每当修改了数据，<code>DOM</code> 便相应地更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 diff 算法</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20diff%20%E7%AE%97%E6%B3%95/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20diff%20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703926503-0a8b70ad-ee2b-4b15-9f24-cb3008e56d1e.png#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=%E7%BB%93%E6%9E%84%E5%9B%BE.png&originHeight=699&originWidth=1424&size=257532&status=done&style=none&width=1424" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703926503-0a8b70ad-ee2b-4b15-9f24-cb3008e56d1e.png#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=%E7%BB%93%E6%9E%84%E5%9B%BE.png&originHeight=699&originWidth=1424&size=257532&status=done&style=none&width=1424" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="结构图.png"></p><h2 id="三个维度"><a href="#三个维度" class="headerlink" title="三个维度"></a>三个维度</h2><blockquote><p>执行时按照以下顺序依次执行</p></blockquote><h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><blockquote><p><code>tree diff</code> 是对树的每一层进行遍历,如果某个组件不存在了，则会直接销毁。</p></blockquote><blockquote><p>如图所示，左边是旧属，右边是新属，第一层是 <code>R</code> 组件，一模一样，不会发生变化；<br>第二层进入 <code>Component DIFF</code>，同一类型组件继续比较下去，发现 <code>A</code> 组件没有，所以直接删掉 <code>A、B、C</code> 组件；<br>继续第三层，重新创建 <code>A、B、C</code> 组件。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703948400-4b9d5cfa-ddf5-404f-83f0-7de2c979afd2.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&name=tree-diff.png&originHeight=317&originWidth=533&size=61410&status=done&style=none&width=533" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703948400-4b9d5cfa-ddf5-404f-83f0-7de2c979afd2.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&name=tree-diff.png&originHeight=317&originWidth=533&size=61410&status=done&style=none&width=533" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tree-diff.png"></p><h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><blockquote><p>如图所示，第一层遍历完，进行第二层遍历时，D 和 G 组件是不同类型的组件，不同类型组件直接进行替换，将 D 删掉，再将 <code>G</code> 重建。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703964946-362729fd-486b-461b-8210-c191053da87c.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=component-diff.png&originHeight=244&originWidth=566&size=81300&status=done&style=none&width=566" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703964946-362729fd-486b-461b-8210-c191053da87c.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=component-diff.png&originHeight=244&originWidth=566&size=81300&status=done&style=none&width=566" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="component-diff.png"></p><h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><blockquote><p><code>Element DIFF</code> 紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定 <code>key</code>，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。<br>如图所示，第一步将 <code>D</code> 删掉，第二步增加 <code>E</code>，再次执行时 <code>A</code> 和 <code>B</code> 只需要移动位置即可。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703980058-5f99c653-2a0a-46c4-9bb5-f1af80d45afe.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=element-diff.png&originHeight=331&originWidth=523&size=81565&status=done&style=none&width=523" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608703980058-5f99c653-2a0a-46c4-9bb5-f1af80d45afe.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=element-diff.png&originHeight=331&originWidth=523&size=81565&status=done&style=none&width=523" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="element-diff.png"></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Diff 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5 相关问题收集</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF/H5%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF/H5%20%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-html"><a href="#1-html" class="headerlink" title="1. html"></a>1. html</h2><h3 id="设置禁止缩放"><a href="#设置禁止缩放" class="headerlink" title="设置禁止缩放"></a>设置禁止缩放</h3><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot; /&gt;</code></pre><h2 id="2-css"><a href="#2-css" class="headerlink" title="2. css"></a>2. css</h2><h3 id="2-1-移动端滑动问题"><a href="#2-1-移动端滑动问题" class="headerlink" title="2.1 移动端滑动问题"></a>2.1 移动端滑动问题</h3><blockquote><p>设置属性 <code>touch-action:none;</code> 会导致安卓系统无法进行滑动。<code>ios</code> 系统不受影响，因为 <code>ios</code> 默认支持 <code>touch</code> 事件。</p></blockquote><pre><code class="css">/* 禁止触发默认的手势操作 */touch-action: none;</code></pre><h3 id="2-2-视网膜屏显示问题"><a href="#2-2-视网膜屏显示问题" class="headerlink" title="2.2 视网膜屏显示问题"></a>2.2 视网膜屏显示问题</h3><blockquote><p>设置 <code>border</code> 的宽高或者通过 <code>div</code> 设置宽高的的时候，对于视网膜屏幕 <code>(Retina)</code>，<code>1px</code> 会显示成 <code>2px</code>；<br>如果用相对应的 <code>rem</code> 处理，部分手机会无法显示。<br>在 <code>ios8</code> 中，已经支持 <code>0.5px</code>，在 <code>ios7</code> 以下，<code>android</code> 等其他系统里，<code>0.5px</code> 会被显示为 <code>0px</code>，所以需要写 <code>hack</code> 来兼容旧版本的系统。通常会使用以下几种方式</p></blockquote><h4 id="2-2-1-媒体查询的方式，需要判断系统和版本"><a href="#2-2-1-媒体查询的方式，需要判断系统和版本" class="headerlink" title="2.2.1 媒体查询的方式，需要判断系统和版本"></a>2.2.1 媒体查询的方式，需要判断系统和版本</h4><pre><code class="css">div &#123;  border: 1px solid #000;&#125;@media (-webkit-min-device-pixel-ratio: 2) &#123;  div &#123;    border: 0.5px solid #000;  &#125;&#125;</code></pre><h4 id="2-2-2-在-html-的-meta-标签加上以下部分"><a href="#2-2-2-在-html-的-meta-标签加上以下部分" class="headerlink" title="2.2.2 在 html 的 meta 标签加上以下部分"></a>2.2.2 在 html 的 meta 标签加上以下部分</h4><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot; /&gt;</code></pre><h4 id="2-2-3-设置属性-transform-scale-0-5-；"><a href="#2-2-3-设置属性-transform-scale-0-5-；" class="headerlink" title="2.2.3 设置属性 transform: scale(0.5)；"></a>2.2.3 设置属性 <code>transform: scale(0.5)；</code></h4><ul><li>缺点</li></ul><blockquote><p>圆角无法实现，实现 <code>4</code> 条边框比较麻烦，并且只能单独实现，如果嵌套，会对包含的效果产生不想要的效果，所以此方案配合 <code>:after</code> 和 <code>before</code> 独立使用较多。比如画一个商品的边框四条线，容器的 <code>after</code> 和 <code>before</code> 可以画 <code>2</code> 条线，利用容器的父元素的 <code>after</code>、<code>before</code> 再画 <code>2</code> 条线。</p></blockquote><pre><code class="css">div &#123;  height: 1px;  -webkit-transform: scaleY(0.5);  -webkit-transform-origin: 0 0;  overflow: hidden;  background: #000;&#125;</code></pre><pre><code class="css">div &#123;      position: relative;&#125;div:after &#123;  content: &quot;&quot;;  position: absolute;  bottom: 0px;  left: 0px;  right: 0px;  border-bottom: 1px solid #000;  -webkit-transform: scaleY(0.5);  -webkit-transform-origin: 0 0;&#125;</code></pre><h3 id="2-3-实现-0-5px-效果"><a href="#2-3-实现-0-5px-效果" class="headerlink" title="2.3 实现 0.5px 效果"></a>2.3 实现 0.5px 效果</h3><pre><code class="css">xx &#123;  -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125;</code></pre><ul><li>优点</li></ul><blockquote><p>基本所有场景都能满足，包含圆角的 <code>button</code>，单条，多条线。</p></blockquote><ul><li>缺点</li></ul><blockquote><p>颜色不好处理， 黑色 <code>rgba(0, 0, 0, 1)</code> 最深的情况了。有阴影出现，不好用。大量使用 <code>box-shadow</code> 可能会导致性能瓶颈。四条边框实现效果不理想。</p></blockquote><h3 id="2-4-使用-background-image"><a href="#2-4-使用-background-image" class="headerlink" title="2.4 使用 background-image"></a>2.4 使用 background-image</h3><h4 id="2-4-1-渐变-linear-gradient-50-有颜色，50-透明"><a href="#2-4-1-渐变-linear-gradient-50-有颜色，50-透明" class="headerlink" title="2.4.1 渐变 linear-gradient   (50% 有颜色，50% 透明)"></a>2.4.1 渐变 <code>linear-gradient</code>   (<code>50%</code> 有颜色，<code>50%</code> 透明)</h4><pre><code class="css">  /* 单条线 */  div &#123;      height: 1px;      background-image: -webkit-linear-gradient(top,transparent 50%,#000 50%);      background-position: top left;      background-repeat: no-repeat;      background-size: 100% 1px;  &#125;  /* 多条线 */  div &#123;      background-image:-webkit-linear-gradient(top, transparent 50%, #000 50%),-webkit-linear-gradient(bottom, transparent 50%, #000 50%),-webkit-linear-gradient(left, transparent 50%, #000 50%),-webkit-linear-gradient(right, transparent 50%, #000 50%);      background-size: 100% 1px,100% 1px,1px 100%,1px 100%;      background-repeat: no-repeat;      background-position: top left, bottom left, left top, right top;  &#125;</code></pre><ul><li>优点：<ol><li> 可以设置单条</li><li> 多条边框可以设置颜色</li></ol></li><li>缺点：<ol><li> 大量使用渐变可能导致性能瓶颈；</li><li> 代码量大；</li><li> 多背景图片有兼容性问题</li></ol></li></ul><h4 id="2-4-2-用图片-base64-："><a href="#2-4-2-用图片-base64-：" class="headerlink" title="2.4.2 用图片( base64 )："></a>2.4.2 用图片( <code>base64</code> )：</h4><pre><code class="css">div &#123;  border-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==&quot;)    2 0 stretch;  border-width: 0px 0px 1px;&#125;</code></pre><ul><li>优点：<ol><li> 可以设置单条,多条边框</li><li> 没有性能瓶颈的问题</li></ol></li><li>缺点：<ol><li> 修改颜色麻烦, 需要替换图片</li><li> 需要用到两张图片</li><li> 多背景图片有兼容性问题</li></ol></li></ul><h3 id="2-5-iphone-X-兼容"><a href="#2-5-iphone-X-兼容" class="headerlink" title="2.5 iphone X 兼容"></a>2.5 iphone X 兼容</h3><pre><code class="css">/** iphone x*/@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) &#123;  .u-fixed-left &#123;    padding-bottom: 0.6rem;  &#125;  .u-fixed-left &#123;    padding-bottom: 0.6rem;  &#125;&#125;</code></pre><h2 id="3-js"><a href="#3-js" class="headerlink" title="3. js"></a>3. js</h2><h3 id="3-1-setInterval"><a href="#3-1-setInterval" class="headerlink" title="3.1 setInterval"></a>3.1 setInterval</h3><h3 id="3-2-ios-日期兼容"><a href="#3-2-ios-日期兼容" class="headerlink" title="3.2 ios 日期兼容"></a>3.2 ios 日期兼容</h3><ul><li><code>ios</code></li></ul><blockquote><p>不支持 <code>-</code> 连接日期，需要写成</p></blockquote><pre><code class="javascript">var d = new Date(&quot;2017-08-11 12:00:00&quot;.replace(/-/g, &quot;/&quot;));</code></pre><h3 id="3-3-获取元素真实宽高"><a href="#3-3-获取元素真实宽高" class="headerlink" title="3.3 获取元素真实宽高"></a>3.3 获取元素真实宽高</h3><pre><code class="javascript">// example:if (DOM元素.currentStyle) &#123;  // IE、Opera  // console.log(&quot;支持currentStyle&quot;);  // alert(oAbc.currentStyle.width);&#125; else &#123;  // FF、chrome、safari  // alert(getComputedStyle(oAbc,false).width);  _this.$trueWeight = (($art.getBoundingClientRect().width - $lRow[idx].getBoundingClientRect().width) / 2) * 5;&#125;</code></pre><h3 id="3-4-jsonp-失败的回调函数"><a href="#3-4-jsonp-失败的回调函数" class="headerlink" title="3.4 jsonp 失败的回调函数"></a>3.4 jsonp 失败的回调函数</h3><pre><code class="javascript">// 可以使用timeout超时来判断complete: function (XMLHttpRequest, status) &#123;    //请求完成后最终执行参数    if (status == &#39;timeout&#39;) &#123;        //超时,status还有success,error等值的情况        xhr.abort();    &#125;&#125;</code></pre><h3 id="3-5-原生判断滑动方向"><a href="#3-5-原生判断滑动方向" class="headerlink" title="3.5 原生判断滑动方向"></a>3.5 原生判断滑动方向</h3><pre><code class="javascript">// 获取角度this.getAngle = function (angx, angy) &#123;  return (Math.atan2(angy, angx) * 180) / Math.PI;&#125;;//根据起点终点返回方向 1向上 2向下 3向左 4向右 0未滑动this.getDirection = function (startx, starty, endx, endy) &#123;  let angx = endx - startx;  let angy = endy - starty;  let result = 0;  //如果滑动距离太短  if (Math.abs(angx) &lt; 2 &amp;&amp; Math.abs(angy) &lt; 2) &#123;    return result;  &#125;  let angle = this.getAngle(angx, angy);  if (angle &gt;= -135 &amp;&amp; angle &lt;= -45) &#123;    result = 1;  &#125; else if (angle &gt; 45 &amp;&amp; angle &lt; 135) &#123;    result = 2;  &#125; else if ((angle &gt;= 135 &amp;&amp; angle &lt;= 180) || (angle &gt;= -180 &amp;&amp; angle &lt; -135)) &#123;    result = 3;  &#125; else if (angle &gt;= -45 &amp;&amp; angle &lt;= 45) &#123;    result = 4;  &#125;  return result;&#125;;// 下滑的时候，失去焦点// jq 用e.originalEvent.touches[0];// zepto 用e.touches[0];let startx = &quot;&quot;,  starty = &quot;&quot;;//手指接触屏幕_this.$document.on(&quot;touchstart&quot;, function (e) &#123;  startx = e.originalEvent.touches[0].pageX;  starty = e.originalEvent.touches[0].pageY;&#125;);//手指离开屏幕_this.$document.on(&quot;touchmove&quot;, function (e) &#123;  let endx = e.originalEvent.changedTouches[0].pageX,    endy = e.originalEvent.changedTouches[0].pageY;  let direction = _this.getDirection(startx, starty, endx, endy);  if (direction == 1) &#123;    // 上滑的操作  &#125;  if (direction == 2) &#123;    // 下滑的操作  &#125;&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 前端 </category>
          
          <category> H5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 虚拟 dom</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20%E8%99%9A%E6%8B%9F%20dom/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20%E8%99%9A%E6%8B%9F%20dom/</url>
      
        <content type="html"><![CDATA[<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><h3 id="1-Vnode-对象"><a href="#1-Vnode-对象" class="headerlink" title="1.Vnode 对象"></a>1.Vnode 对象</h3><blockquote><p>一个 <code>VNode</code> 的实例对象包含了以下属性:</p></blockquote><ul><li><code>tag</code>: 当前节点的标签名</li><li><code>data</code>: 当前节点的数据对象，具体包含哪些字段可以参考 <code>vue</code> 源码 <code>types/vnode.d.ts</code> 中对 <code>VNodeData</code> 的定义</li><li><code>children</code>: 数组类型，包含了当前节点的子节点</li><li><code>text</code>: 当前节点的文本，一般文本节点或注释节点会有该属性</li><li><code>elm</code>: 当前虚拟节点对应的真实的 <code>dom</code> 节点</li><li><code>ns</code>: 节点的 <code>namespace</code></li><li><code>context</code>: 编译作用域</li><li><code>functionalContext</code>: 函数化组件的作用域</li><li><code>key</code>: 节点的 <code>key</code> 属性，用于作为节点的标识，有利于 <code>patch</code> 的优化</li><li><code>componentOptions</code>: 创建组件实例时会用到的选项信息</li><li><code>child</code>: 当前节点对应的组件实例</li><li><code>parent</code>: 组件的占位节点</li><li><code>raw</code>: <code>raw html</code></li><li><code>isStatic</code>: 静态节点的标识</li><li><code>isRootInsert</code>: 是否作为根节点插入，被 <code>&lt;transition&gt;</code> 包裹的节点，该属性的值为 <code>false</code></li><li><code>isComment</code>: 当前节点是否是注释节点</li><li><code>isCloned</code>: 当前节点是否为克隆节点</li><li><code>isOnce</code>: 当前节点是否有 <code>v-once</code> 指令</li></ul><h3 id="2-Vnode-分类"><a href="#2-Vnode-分类" class="headerlink" title="2.Vnode 分类"></a>2.Vnode 分类</h3><ul><li>简介</li></ul><blockquote><p><code>VNode</code> 可以理解为 <code>vue</code> 框架的虚拟 <code>dom</code> 的基类，通过 <code>new</code> 实例化的 <code>VNode</code> 大致可以分为几类</p></blockquote><ul><li><code>EmptyVNode</code>: 没有内容的注释节点</li><li><code>TextVNode</code>: 文本节点</li><li><code>ElementVNode</code>: 普通元素节点</li><li><code>ComponentVNode</code>: 组件节点</li><li><code>CloneVNode</code>: 克隆节点，可以是以上任意类型的节点，唯一的区别在于 <code>isCloned</code> 属性为 <code>true</code></li></ul><h3 id="3-createElement-解析"><a href="#3-createElement-解析" class="headerlink" title="3.createElement 解析"></a>3.createElement 解析</h3><pre><code class="javascript">const SIMPLE_NORMALIZE = 1;const ALWAYS_NORMALIZE = 2;function createElement(context, tag, data, children, normalizationType, alwaysNormalize) &#123;  // 兼容不传data的情况  if (Array.isArray(data) || isPrimitive(data)) &#123;    normalizationType = children;    children = data;    data = undefined;  &#125;  // 如果alwaysNormalize是true  // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值  if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE;  // 调用_createElement创建虚拟节点  return _createElement(context, tag, data, children, normalizationType);&#125;function _createElement(context, tag, data, children, normalizationType) &#123;  /**   * 如果存在data.__ob__，说明data是被Observer观察的数据   * 不能用作虚拟节点的data   * 需要抛出警告，并返回一个空节点   *   * 被监控的data不能被用作vnode渲染的数据的原因是：   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作   */  if (data &amp;&amp; data.__ob__) &#123;    process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; warn(`Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` + &quot;Always create fresh vnode data objects in each render!&quot;, context);    return createEmptyVNode();  &#125;  // 当组件的is属性被设置为一个falsy的值  // Vue将不会知道要把这个组件渲染成什么  // 所以渲染一个空节点  if (!tag) &#123;    return createEmptyVNode();  &#125;  // 作用域插槽  if (Array.isArray(children) &amp;&amp; typeof children[0] === &quot;function&quot;) &#123;    data = data || &#123;&#125;;    data.scopedSlots = &#123; default: children[0] &#125;;    children.length = 0;  &#125;  // 根据normalizationType的值，选择不同的处理方法  if (normalizationType === ALWAYS_NORMALIZE) &#123;    children = normalizeChildren(children);  &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123;    children = simpleNormalizeChildren(children);  &#125;  let vnode, ns;  // 如果标签名是字符串类型  if (typeof tag === &quot;string&quot;) &#123;    let Ctor;    // 获取标签名的命名空间    ns = config.getTagNamespace(tag);    // 判断是否为保留标签    if (config.isReservedTag(tag)) &#123;      // 如果是保留标签,就创建一个这样的vnode      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);      // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义    &#125; else if ((Ctor = resolveAsset(context.$options, &quot;components&quot;, tag))) &#123;      // 如果找到了这个标签的定义，就以此创建虚拟组件节点      vnode = createComponent(Ctor, data, context, children, tag);    &#125; else &#123;      // 兜底方案，正常创建一个vnode      vnode = new VNode(tag, data, children, undefined, undefined, context);    &#125;    // 当tag不是字符串的时候，我们认为tag是组件的构造类    // 所以直接创建  &#125; else &#123;    vnode = createComponent(tag, data, context, children);  &#125;  // 如果有vnode  if (vnode) &#123;    // 如果有namespace，就应用下namespace，然后返回vnode    if (ns) applyNS(vnode, ns);    return vnode;    // 否则，返回一个空节点  &#125; else &#123;    return createEmptyVNode();  &#125;&#125;</code></pre><h3 id="4-patch-原理"><a href="#4-patch-原理" class="headerlink" title="4.patch 原理"></a>4.patch 原理</h3><h4 id="patch-函数接收-6-个参数"><a href="#patch-函数接收-6-个参数" class="headerlink" title="patch 函数接收 6 个参数"></a>patch 函数接收 6 个参数</h4><ol><li><code>oldVnode</code>: 旧的虚拟节点或旧的真实 <code>dom</code> 节点</li><li><code>vnode</code>: 新的虚拟节点</li><li><code>hydrating</code>: 是否要跟真实 <code>dom</code> 混合</li><li><code>removeOnly</code>: 特殊 <code>flag</code>，用于 <code>&lt;transition-group&gt;</code> 组件</li><li><code>parentElm</code>: 父节点</li><li><code>refElm</code>: 新节点将插入到 <code>refElm</code> 之前</li></ol><h4 id="patch-的策略"><a href="#patch-的策略" class="headerlink" title="patch 的策略"></a>patch 的策略</h4><ul><li>如果<code>vnode</code> 不存在但是 <code>oldVnode</code> 存在，说明意图是要销毁老节点，那么就调用 <code>invokeDestroyHook(oldVnode)</code> 来进行销毁</li><li>如果 <code>oldVnode</code> 不存在但是 <code>vnode</code> 存在，说明意图是要创建新节点，那么就调用 <code>createElm</code> 来创建新节点</li><li>当 <code>vnode</code> 和 <code>oldVnode</code> 都存在时<ul><li>如果 <code>oldVnode</code> 和 <code>vnode</code> 是同一个节点，就调用 <code>patchVnode</code> 来进行 <code>patch</code></li><li>当 <code>vnode</code> 和 <code>oldVnode</code> 不是同一个节点时，如果 <code>oldVnode</code> 是真实 <code>dom</code> 节点 或 <code>hydrating</code> 设置为<code>true</code>，需要用 <code>hydrate</code> 函数将虚拟 <code>dom</code> 和真实 <code>dom</code> 进行映射，然后将 <code>oldVnode</code> 设置为对应的虚拟 <code>dom</code>，找到 <code>oldVnode.elm</code> 的父节点，根据 <code>vnode</code> 创建一个真实 <code>dom</code> 节点并插入到该父节点中 <code>oldVnode.elm</code> 的位置</li></ul></li></ul><blockquote><p>这里面值得一提的是 <code>patchVnode</code> 函数，因为真正的 <code>patch</code> 算法是由它来实现的（<code>patchVnode</code> 中更新子节点的算法其实是在 <code>updateChildren</code> 函数中实现的</p></blockquote><h4 id="patchVnode-算法"><a href="#patchVnode-算法" class="headerlink" title="patchVnode 算法"></a>patchVnode 算法</h4><ol><li>如果 <code>oldVnode</code> 跟 <code>vnode</code> 完全一致，那么不需要做任何事情</li><li>如果 <code>oldVnode</code> 跟 <code>vnode</code> 都是静态节点，且具有相同的 <code>key</code>，当 <code>vnode</code> 是克隆节点或是 <code>v-once</code> 指令控制的节点时，只需要把 <code>oldVnode.elm</code> 和 <code>oldVnode.child</code> 都复制到 <code>vnode</code> 上，也不用再有其他操作</li><li>否则，如果<code>vnode</code>不是文本节点或注释节点</li></ol><ul><li>如果 <code>oldVnode</code>和 <code>vnode</code> 都有子节点，且双方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在 <code>updateChildren</code> 函数中实现），算法如下:</li></ul><blockquote><p>分别获取 <code>oldVnode</code> 和 <code>vnode</code> 的 <code>firstChild</code>、<code>lastChild</code>，赋值给 <code>oldStartVnode</code>、<code>oldEndVnode</code>、<code>newStartVnode</code>、<code>newEndVnode</code></p></blockquote><blockquote><p>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，然后将 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 都设置为下一个子节点，重复上述流程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704111320-57210d35-7b20-45f7-87b1-8a6a541754bc.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&name=virtual_dom1.png&originHeight=204&originWidth=667&size=20067&status=done&style=none&width=667" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704111320-57210d35-7b20-45f7-87b1-8a6a541754bc.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&name=virtual_dom1.png&originHeight=204&originWidth=667&size=20067&status=done&style=none&width=667" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="virtual_dom1.png"></p></blockquote><blockquote><p>如果 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，然后将 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 都设置为上一个子节点，重复上述流程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704123342-e1a719db-cacd-4fe3-a4b5-730e73dec203.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=virtual_dom2.png&originHeight=221&originWidth=676&size=19741&status=done&style=none&width=676" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704123342-e1a719db-cacd-4fe3-a4b5-730e73dec203.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=virtual_dom2.png&originHeight=221&originWidth=676&size=19741&status=done&style=none&width=676" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="virtual_dom2.png"></p></blockquote><blockquote><p>如果 <code>oldStartVnode</code> 和 <code>newEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是<code>false</code>，那么可以把 <code>oldStartVnode.elm</code> 移动到 <code>oldEndVnode.elm</code> 之后，然后把 <code>oldStartVnode</code> 设置为下一个节点，<code>newEndVnode</code> 设置为上一个节点，重复上述流程<img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704137134-da7b6eab-d7ab-4e0d-bd3c-816548aa7050.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=virtual_dom3.png&originHeight=224&originWidth=826&size=24829&status=done&style=none&width=826" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704137134-da7b6eab-d7ab-4e0d-bd3c-816548aa7050.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=virtual_dom3.png&originHeight=224&originWidth=826&size=24829&status=done&style=none&width=826" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="virtual_dom3.png"></p></blockquote><blockquote><p>如果 <code>newStartVnode</code> 和 <code>oldEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是 <code>false</code>，那么可以把 <code>oldEndVnode.elm</code> 移动到 <code>oldStartVnode.elm</code> 之前，然后把 <code>newStartVnode</code> 设置为下一个节点，<code>oldEndVnode</code> 设置为上一个节点，重复上述流程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704166102-db7c7879-3e36-49db-9e96-9f587cfcb771.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=virtual_dom4.png&originHeight=214&originWidth=864&size=24556&status=done&style=none&width=864" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704166102-db7c7879-3e36-49db-9e96-9f587cfcb771.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=virtual_dom4.png&originHeight=214&originWidth=864&size=24556&status=done&style=none&width=864" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="virtual_dom4.png"></p></blockquote><blockquote><p>如果以上都不匹配，就尝试在 <code>oldChildren</code> 中寻找跟 <code>newStartVnode</code> 具有相同 <code>key</code> 的节点，如果找不到相同 <code>key</code>的节点，说明 <code>newStartVnode</code> 是一个新节点，就创建一个，然后把 <code>newStartVnode</code> 设置为下一个节点</p></blockquote><blockquote><p>如果上一步找到了跟 <code>newStartVnode</code> 相同 <code>key</code> 的节点，那么通过其他属性的比较来判断这 2 个节点是否是同一个节点，如果是，就调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是 <code>false</code>，就把 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 之前，把 <code>newStartVnode</code> 设置为下一个节点，重复上述流程<br><img src="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704181185-2af64dae-c1a4-4505-aeeb-5ec7efad8930.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=virtual_dom5.png&originHeight=227&originWidth=869&size=24398&status=done&style=none&width=869" class="lazyload" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/732231/1608704181185-2af64dae-c1a4-4505-aeeb-5ec7efad8930.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=virtual_dom5.png&originHeight=227&originWidth=869&size=24398&status=done&style=none&width=869" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="virtual_dom5.png"></p></blockquote><ul><li>如果只有 <code>oldVnode</code> 有子节点，那就把这些节点都删除</li><li>如果只有 <code>vnode</code> 有子节点，那就创建这些子节点</li><li>如果 <code>oldVnode和vnode</code> 都没有子节点，但是 <code>oldVnode</code> 是文本节点或注释节点，就把 <code>vnode.elm</code> 的文本设置为空字符串</li></ul><ol start="4"><li>如果 <code>vnode</code> 是文本节点或注释节点，但是 <code>vnode.text != oldVnode.text</code> 时，只需要更新 <code>vnode.elm</code> 的文本内容就可以</li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li><code>patch</code> 提供了 <code>5</code> 个生命周期钩子，分别是<ul><li><code>create</code>: 创建 <code>patch</code> 时</li><li><code>activate</code>: 激活组件时</li><li><code>update</code>: 更新节点时</li><li><code>remove</code>: 移除节点时</li><li><code>destroy</code>: 销毁节点时</li></ul></li><li><code>vnode</code>也提供了生命周期钩子，分别是<ul><li><code>init</code>: <code>vdom</code> 初始化时</li><li><code>create</code>: <code>vdom</code> 创建时</li><li><code>prepatch</code>: <code>patch</code> 之前</li><li><code>insert</code>: <code>vdom</code> 插入后</li><li><code>update</code>: <code>vdom</code> 更新前</li><li><code>postpatch</code>: <code>patch</code> 之后</li><li><code>remove</code>: <code>vdom</code> 移除时</li><li><code>destroy</code>: <code>vdom</code> 销毁时</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟 Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hybrid 简介</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF/Hybrid%20%E7%AE%80%E4%BB%8B/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%89%8D%E7%AB%AF/Hybrid%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="hybrid-实现原理"><a href="#hybrid-实现原理" class="headerlink" title="hybrid 实现原理"></a>hybrid 实现原理</h2><blockquote><p>原生的 <code>App</code> 中，使用 <code>WebView</code> 作为容器直接承载 <code>Web</code> 页面。 中间通过 <code>JSBridge</code> 来完成 <code>Native</code> 与 <code>JavaScript</code> 之间的通讯。</p></blockquote><h2 id="hybrid-几种方案"><a href="#hybrid-几种方案" class="headerlink" title="hybrid 几种方案"></a>hybrid 几种方案</h2><h3 id="基于-WebView-UI-的基础方案"><a href="#基于-WebView-UI-的基础方案" class="headerlink" title="基于  WebView UI  的基础方案"></a>基于  WebView UI  的基础方案</h3><blockquote><p>例如微信 <code>JS-SDK</code>，通过 <code>JSBridge</code> 完成 <code>H5</code> 与 <code>Native</code> 的双向通讯，从而赋予 <code>H5</code> 一定程度的原生能力。</p></blockquote><h3 id="基于-Native-UI-的方案"><a href="#基于-Native-UI-的方案" class="headerlink" title="基于  Native UI  的方案"></a>基于  <code>Native UI</code>  的方案</h3><blockquote><p>例如 <code>React-Native、Weex</code> 。在赋予 <code>H5</code> 原生 <code>API</code> 能力的基础上，进一步通过 <code>JSBridge</code> 将 <code>js</code> 解析成的虚拟节点树( <code>Virtual DOM</code> )传递到 <code>Native</code> 并使用原生渲染。</p></blockquote><h3 id="小程序方案"><a href="#小程序方案" class="headerlink" title="小程序方案"></a>小程序方案</h3><blockquote><p>通过更加定制化的 <code>JSBridge</code>，并使用双 <code>WebView</code> 双线程的模式隔离了 <code>JS</code> 逻辑与 <code>UI</code> 渲染，形成了特殊的开发模式，加强了 <code>H5</code> 与 <code>Native</code> 混合程度，提高了页面性能及开发体验。</p></blockquote><h2 id="hybrid-和-h5-对比"><a href="#hybrid-和-h5-对比" class="headerlink" title="hybrid 和 h5 对比"></a>hybrid 和 h5 对比</h2><h3 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h3><ul><li>优点<ul><li>开发速度快，一端开发多端运行</li><li>如果需要频繁更换页面，用 <code>h5</code> 维护会更加容易</li><li>版本更新不需要打包便可发布</li></ul></li><li>缺点<ul><li>流畅度，安全问题</li><li>性能不如原生</li><li>不能调用移动硬件设备的功能</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渐进式 web 应用程序 pwa 简介</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E6%B8%90%E8%BF%9B%E5%BC%8F%20web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%20pwa%20%E7%AE%80%E4%BB%8B/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E6%B8%90%E8%BF%9B%E5%BC%8F%20web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%20pwa%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>介绍</p><blockquote><p>渐进式 Web 应用程序</p></blockquote><h2 id="progressive-web-app"><a href="#progressive-web-app" class="headerlink" title="progressive web app"></a>progressive web app</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>显著提高应用加载速度</li><li><code>web</code> 应用可以在离线环境下使用</li><li><code>web</code> 应用能够像原生应用一样被添加到主屏幕</li><li><code>web</code> 应用能在未被激活时发起推送通知</li><li><code>web</code> 应用于操作系统集成能力进一步提高</li></ol><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><ul><li>w3c web app manifest</li></ul><blockquote><p>由早期的定义在 <code>html</code> 页面头部转换成了定义在 <code>json</code> 文件中</p></blockquote><ul><li><p><code>scope</code>：定义了 <code>web</code> 应用的浏览作用域，比如作用域外面的 <code>URL</code> 就会打开浏览器而不会在当前<code>PWA</code>中继续浏览</p></li><li><p><code>start_url</code>：定义了一个 <code>PWA</code> 的入口页面</p></li><li><p><code>orientation</code>：锁定屏幕旋转</p></li><li><p><code>theme_color</code>/<code>background_color</code>：主题色与背景色，用于配置一些可定制的操作系统 <code>UI</code> 以提高用户体验，比如 <code>Android</code> 的状态栏、任务栏等</p></li><li><p>service worker</p><ul><li>让<code>web</code>应用离线使用的第三次尝试</li><li>可编程的 <code>web worker</code></li><li>像一个位于浏览器与网络之间的客户端代理，可与拦截、处理、相应流经的 <code>HTTP</code> 请求</li><li>配合 <code>Cache Storage API</code>，可以自由管理 <code>HTTP</code> 请求文件粒度的缓存</li></ul></li><li><p>push notification</p><ul><li><code>push api</code> 的出现让推送服务具备了向<code>web</code>应用推送消息的能力</li><li><code>push API</code> 不依赖<code>web</code>应用和浏览器<code>UI</code>存活</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue2 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Vue/Vue2%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-父子组件传值"><a href="#1-父子组件传值" class="headerlink" title="1. 父子组件传值"></a>1. 父子组件传值</h2><ul><li>父子： <code>props</code></li><li>子父： <code>this.$emit(&#39;事件名&#39;, 参数)</code></li></ul><h2 id="2-获取-dom-节点"><a href="#2-获取-dom-节点" class="headerlink" title="2. 获取 dom 节点"></a>2. 获取 dom 节点</h2><blockquote><p><code>this.$refs</code>， 可以获取组件的引用，同时可以获取组件的 <code>data，methods</code> 等</p></blockquote><h2 id="3-路由"><a href="#3-路由" class="headerlink" title="3. 路由"></a>3. 路由</h2><ul><li>后端路由</li></ul><blockquote><p>对于普通的网站，所有的超链接都是 <code>URL</code> 地址，所有的 <code>URL</code> 地址都对应服务器上的资源。</p></blockquote><ul><li>前端路由</li></ul><blockquote><p>对于单页面应用程序（<code>SPA</code>），主要通过 <code>URL</code> 的 <code>hash(#)</code> 来实现不同页面之间的切换；同时，<code>hash</code> 有一个特点，<code>http</code> 请求中不会包含 <code>hash</code> 相关的内容</p></blockquote><h2 id="4-命名视图-router-view"><a href="#4-命名视图-router-view" class="headerlink" title="4. 命名视图 router-view"></a>4. 命名视图 router-view</h2><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;    &lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;    &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var header = &#123;  template: &quot;&lt;div&gt;header&lt;/div&gt;&quot;&#125;;var leftBox = &#123;  template: &quot;&lt;div&gt;left&lt;/div&gt;&quot;&#125;;var mainBox = &#123;  template: &quot;&lt;div&gt;main&lt;/div&gt;&quot;&#125;;var router = new VueRouter(&#123;  routes: [    &#123;      path: &quot;/&quot;,      components: &#123;        default: header,        left: leftBox,        main: mainBox      &#125;    &#125;  ]&#125;);var vm = new Vue(&#123;  el: &quot;#app&quot;,  router&#125;);&lt;/script&gt;</code></pre><h2 id="5-watch"><a href="#5-watch" class="headerlink" title="5. watch"></a>5. watch</h2><pre><code class="vue">&lt;template&gt;  &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;&lt;/template&gt;&lt;script&gt;data: &#123;   msg: &#39;&#39;&#125;,watch: &#123;  msg(newVal, oldVal) &#123;    console.log(newVal, oldVal)  &#125;,  &quot;$route.path&quot;: (newVal, oldVal) =&gt; &#123;    console.log(newVal, oldVal)  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="6-computed"><a href="#6-computed" class="headerlink" title="6. computed"></a>6. computed</h2><ul><li>在 <code>computed</code> 中，可以定义一些属性（计算属性）；计算属性的本质就是一个方法。只不过在我们这些计算属性的时候，是直接把他们的名称当作属性来使用的，并不会把计算属性当作方法来调用。</li><li>计算属性的求值结果，会被缓存起来，方便下次直接使用; 如果 <code>计算属性</code> 方法中，所依赖的所有数据，都没有发生变化，则不会重新对 <code>计算属性</code> 进行求值</li></ul><pre><code class="vue">&lt;template&gt;  &lt;input type=&quot;text&quot; v-model=&quot;firstname&quot; /&gt;  &lt;input type=&quot;text&quot; v-model=&quot;lastname&quot; /&gt;  &lt;input type=&quot;text&quot; v-model=&quot;fullname&quot; /&gt;&lt;/template&gt;&lt;script&gt;data: &#123;    firstname: &#39;&#39;,    lastname: &#39;&#39;&#125;,computed: &#123;    fullname() &#123;        return this.firstname + &#39;-&#39; + this.lastname;    &#125;&#125;&lt;/script&gt;</code></pre><h2 id="7-render"><a href="#7-render" class="headerlink" title="7. render"></a>7. render</h2><ul><li><code>createElements</code> 是一个方法，调用它，能够把指定的组件模板，渲染为 <code>html</code> 结构</li><li>通常习惯性将 <code>createElements</code> 写成 <code>h</code></li></ul><pre><code class="vue">&lt;script&gt;var login = &#123;  template: &quot;&lt;h1&gt;这是登陆组件&lt;/h1&gt;&quot;&#125;;var vm = new Vue(&#123;  el: &quot;#app&quot;,  data: &#123;&#125;,  render: function (createElements) &#123;    return createElements(login);  &#125;&#125;);&lt;/script&gt;</code></pre><h2 id="8-模块的导入与导出"><a href="#8-模块的导入与导出" class="headerlink" title="8. 模块的导入与导出"></a>8. 模块的导入与导出</h2><ul><li><code>commenJs</code> 导入导出模块</li></ul><blockquote><p>导入</p></blockquote><pre><code class="javascript">var 名称 = require(&quot;模块标识符&quot;);</code></pre><blockquote><p>导出</p></blockquote><pre><code class="javascript">module.exports = &#123;&#125;;</code></pre><ul><li><code>import</code> 导入导出模块</li></ul><blockquote><p>导入</p></blockquote><pre><code class="javascript">inport 名称A from &#39;模块标识符&#39;inport &#123; 名称B &#125; &#39;标识路径&#39;</code></pre><blockquote><p>导出</p></blockquote><pre><code class="javascript">export default 名称Aexport 名称B</code></pre><blockquote><p>重命名</p></blockquote><pre><code class="javascript">import 名称A as newA from &#39;模块标识符&#39;import &#123; 名称B as newB &#125; from &#39;标示路径&#39;</code></pre><h2 id="9-vuex"><a href="#9-vuex" class="headerlink" title="9. vuex"></a>9. vuex</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><code>vuex</code> 是 <code>vue.js</code> 应用程序开发的状态管理模式（状态可以理解为数据），它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可检测的方式发生变化</li></ul><h3 id="props，data-和-vuex-的区别"><a href="#props，data-和-vuex-的区别" class="headerlink" title="props，data 和 vuex 的区别"></a>props，data 和 vuex 的区别</h3><ul><li><code>props</code>: 存放父组件传递过来的数据</li><li><code>data</code>: 存放私有数据</li><li><code>vuex</code>: 组件之间共享的数据</li></ul><h3 id="state，mutations，actions，getters，modules"><a href="#state，mutations，actions，getters，modules" class="headerlink" title="state，mutations，actions，getters，modules"></a>state，mutations，actions，getters，modules</h3><ul><li><code>state</code>：类似于 <code>data</code>，用来存数据</li></ul><blockquote><p>访问</p></blockquote><pre><code class="javascript">this.$store.state.数据a...mapState</code></pre><ul><li><code>mutations</code>：类似于 <code>methods</code>，处理同步方法</li></ul><blockquote><p>使用</p></blockquote><pre><code class="javascript">mutations: &#123;    &quot;METHODS&quot;: function(state, value) &#123;        state.value = value;    &#125;&#125;</code></pre><blockquote><p>访问</p></blockquote><pre><code class="javascript">this.$store.commit(&#39;方法名&#39;, &#39;参数&#39;)...mapMutations</code></pre><ul><li><code>actions</code>：类似于 <code>methods</code>，处理异步方法</li></ul><blockquote><p>使用</p></blockquote><pre><code class="javascript">actions: &#123;    async methodsAsync(&#123; commit &#125;, value) &#123;        try &#123;            const result = await apiMethods()            if (result.code === 200) &#123;                commit(&quot;SET_METHODS&quot;, result.data)            &#125;        &#125; catch(err) &#123;            throw new Error(err);        &#125;    &#125;&#125;</code></pre><blockquote><p>访问</p></blockquote><pre><code class="javascript">this.$store.dispatch(&#39;方法名&#39;, &#39;参数&#39;)...mapActions</code></pre><ul><li><code>getters</code>：类似于 <code>computed</code> 和 <code>filter</code>，处理数据</li></ul><blockquote><p>使用</p></blockquote><pre><code class="javascript">getters: &#123;    newData(state) &#123;        return state.arr.filter(item =&gt; item.id === 1)    &#125;&#125;</code></pre><blockquote><p>访问</p></blockquote><pre><code class="javascript">this.$store.getters(&#39;名称&#39;)...mapGetters</code></pre><h2 id="10-props-传递数据未更新"><a href="#10-props-传递数据未更新" class="headerlink" title="10. props 传递数据未更新"></a>10. props 传递数据未更新</h2><blockquote><p>解决方式：使用 <code>watch</code> 监听 <code>props</code></p></blockquote><h2 id="11-生命周期"><a href="#11-生命周期" class="headerlink" title="11. 生命周期"></a>11. 生命周期</h2><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul><li>组件创建阶段</li></ul><blockquote><p>此时，组件的 <code>data</code> 和 <code>methods</code> 以及页面 <code>DOM</code> 结构都还没有初始化</p></blockquote><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul><li>组件创建阶段</li></ul><blockquote><p>此时，组件的 <code>data</code> 和 <code>methods</code> 已经可用了，但是页面 <code>DOM</code> 结构还没有渲染出来；经常用来发起 <code>ajax</code> 请求<br>注意，在 <code>ssr</code> 服务端渲染的时候，在此处发起 <code>ajax</code> 请求会有问题，推荐在 <code>mounted</code> 生命周期函数中来发起 <code>ajax</code> 请求。</p></blockquote><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul><li>组件创建阶段</li></ul><blockquote><p>此时内存中的模板结构还没有<em>真正渲染到页面上</em>；此时，页面上<em>看不到真实的数据</em>，此时用户看到的只是一个模板页面</p></blockquote><h3 id="Mounted"><a href="#Mounted" class="headerlink" title="Mounted"></a>Mounted</h3><ul><li>组件创建阶段</li></ul><blockquote><p>组件挂载完毕，可初始化插件</p></blockquote><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><blockquote><p>_数据肯定是最新的_，然而<em>页面呈现的数据还是旧的</em></p></blockquote><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><blockquote><p>页面已经完成了更新。此时，<code>data</code> 和 <code>view</code> 上都是最新的数据</p></blockquote><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul><li>组件销毁阶段</li></ul><blockquote><p>此时没有真正开始销毁，组件还是正常可用的。同时，<code>data</code> 、<code>methods</code> 等数据或方法，依然可以被正常访问；</p></blockquote><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul><li>组件销毁阶段</li></ul><blockquote><p>组件已经完成了销毁.<code>data</code> 和 <code>methods</code> 都不可用了</p></blockquote><h2 id="12-vue-组件从创建到销毁的整个过程"><a href="#12-vue-组件从创建到销毁的整个过程" class="headerlink" title="12  vue 组件从创建到销毁的整个过程"></a>12  vue 组件从创建到销毁的整个过程</h2><table><thead><tr><th>行为</th><th>指向</th><th>作用</th></tr></thead><tbody><tr><td><code>new Vue()</code></td><td>➡️</td><td>实例化 <code>Vue</code> 对象</td></tr><tr><td><code>Init Events &amp; Lifecycle</code></td><td>➡️</td><td>初始化组件 <code>methods</code> 和 <code>生命周期函数</code></td></tr><tr><td><code>beforeCreate</code></td><td>➡️</td><td><code>data</code>，<code>methods</code> 未被初始化</td></tr><tr><td><code>Init injections &amp; reactivity</code></td><td>➡️</td><td>正在初始化 <code>data</code> 和 <code>methods</code> 中的数据以及方法</td></tr><tr><td><code>created</code></td><td>➡️</td><td><code>data</code>，<code>methods</code> 可用，但 <code>Dom</code> 结构还未被渲染，常发起 <code>ajax</code> 请求</td></tr><tr><td>⬇️</td><td>➡️</td><td>判断是否有 <code>el</code>，<code>template</code> 属性</td></tr><tr><td>⬇️</td><td>➡️</td><td>用来编译模版结构，当所有指令解析完毕，则<code>模板页面就被渲染到内存中了</code>；当模板编译完成，模板页面还没有挂在到页面上，只是存在于内存中，用户看不到页面；</td></tr><tr><td><code>beforeMount</code></td><td>➡️</td><td>此时，页面上看不到 <code>真实数据</code>，此时用户看到的只是一个模板页面</td></tr><tr><td><code>Create vm.$el and replace &quot;el&quot; with it</code></td><td>➡️</td><td>正在把内存中渲染好的模板结构替换到页面上</td></tr><tr><td><code>mounted</code></td><td>➡️</td><td>此时，页面渲染完毕</td></tr><tr><td>⬇️(组件运行中的生命周期函数)</td><td>➡️</td><td>会根据 <code>data</code> 数据的变化，有选择行的触发 <code>0</code>次 或 <code>n</code>次</td></tr><tr><td><code>beforeUpdate</code></td><td>➡️</td><td>数据是新的，但页面呈现的数据仍是旧的</td></tr><tr><td><code>updated</code></td><td>➡️</td><td>页面已经完成了更新，此时，数据是最新的，同时页面上呈现的数据也是最新的</td></tr><tr><td>⬇️(销毁阶段)</td><td></td><td></td></tr><tr><td><code>beforeDestroy</code></td><td>➡️</td><td>组件即将被销毁，但是还没有真 正开始销毁，此时组件还是正常可用的。<code>data</code>，<code>methods</code> 仍可正常访问</td></tr><tr><td><code>Teardown watchers,child components and event listeners</code>(销毁过程)</td><td>➡️</td><td></td></tr><tr><td><code>destroyed</code></td><td>➡️</td><td>组件已经完成了销毁，组件已经废了，<code>data</code> 和 <code>methods</code> 都不可用了</td></tr></tbody></table><h2 id="13-keep-alive"><a href="#13-keep-alive" class="headerlink" title="13. keep-alive"></a>13. keep-alive</h2><h3 id="新增生命周期"><a href="#新增生命周期" class="headerlink" title="新增生命周期"></a>新增生命周期</h3><blockquote><p>被包含在  <code>&lt;keep-alive&gt;</code>  中创建的组件，会多两个生命周期: <code>activated</code>  与  <code>deactivated</code></p></blockquote><ul><li>actived</li></ul><blockquote><p>组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 <code>keep-alive</code> 激活时被调用。</p></blockquote><ul><li>deactivated</li></ul><blockquote><p>组件被停用时调用。</p></blockquote><h3 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h3><ul><li>include</li></ul><blockquote><p>包含的组件缓存生效。对应 <code>.vue</code> 文件的 <code>name</code> 属性</p></blockquote><ul><li>exclude</li></ul><blockquote><p>排除的组件不缓存，优先级大于 <code>include</code>。对应 <code>.vue</code> 文件的 <code>name</code> 属性</p></blockquote><h2 id="14-nextTick"><a href="#14-nextTick" class="headerlink" title="14. nextTick"></a>14. <code>nextTick</code></h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>在官方文档中说明 <code>Vue</code> 是异步执行 <code>DOM</code> 更新的，所以在某些场景下需要进行特殊处理才可正常执行某些逻辑。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在 <code>Vue</code> 生命周期的 <code>created()</code> 钩子函数进行的 <code>DOM</code> 操作一定要放在 <code>Vue.nextTick()</code> 的回调函数中</li></ul><blockquote><p>原因: 在 <code>created()</code> 钩子函数执行的时候 <code>DOM</code> 其实并未进行任何渲染，而此时进行 <code>DOM</code> 操作毫无意义，因此一定要将操作 <code>Dom</code> 部分的代码放入 <code>Vue.nextTick()</code> 的回调函数中。与之对应的就是 <code>mounted()</code> 钩子函数，因为该钩子函数执行时所有的<code>DOM</code> 挂载和渲染都已完成，此时在该钩子函数中进行任何 <code>DOM</code> 操作都不会有问题 。</p></blockquote><ul><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 <code>DOM</code> 结构的时候，这个操作都应该放进 <code>Vue.nextTick()</code> 的回调函数中。</li></ul><h3 id="nextTick-源码浅析"><a href="#nextTick-源码浅析" class="headerlink" title="nextTick 源码浅析"></a>nextTick 源码浅析</h3><blockquote><p><code>Vue.nextTick</code> 用于延迟执行一段代码，它接受 <code>2</code> 个参数（ <code>回调函数</code> 和 <code>执行回调函数的上下文环境</code>），如果没有提供回调函数，那么将返回 <code>promise</code> 对象。</p></blockquote><blockquote><p>主要的实现方式为判断设备所支持的三种属性，依据各自支持的属性来进行异步操作。如果支持 <code>promise</code>，会使用 <code>Promise.then</code> 来做延迟调用函数。如果设备不支持 <code>Promise</code> 对象，再判断是否支持 <code>MutationObserver</code> 对象，如果支持该对象，就使用<code>MutationObserver</code> 来做延迟，最后如果上面两种都不支持的话，我们会使用 <code>setTimeout</code> 来做延迟操作。</p></blockquote><h2 id="15-自定义指令"><a href="#15-自定义指令" class="headerlink" title="15. 自定义指令"></a>15. 自定义指令</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>除了核心功能默认内置的指令 ( <code>v-model</code>  和  <code>v-show</code>)， <code>Vue</code>  也允许注册自定义指令。</p></blockquote><blockquote><p>注意，在 <code>Vue2.0</code> 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 <code>DOM</code>  元素进行底层操作，这时候就会用到自定义指令。</p></blockquote><ul><li>例</li></ul><blockquote><p>当页面加载时，该元素将获得焦点 (注意： <code>autofocus</code>  在移动版 <code>Safari</code>  上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p></blockquote><pre><code class="javascript">// 注册一个全局自定义指令 `v-focus`Vue.directive(&quot;focus&quot;, &#123;  // 当被绑定的元素插入到 DOM 中时……  inserted: function (el) &#123;    // 聚焦元素    el.focus();  &#125;&#125;);</code></pre><blockquote><p>如果想注册局部指令，组件中也接受一个 <code>directives</code>  的选项：</p></blockquote><pre><code class="javascript">directives: &#123;  focus: &#123;    // 指令的定义    inserted: function (el) &#123;      el.focus()    &#125;  &#125;&#125;</code></pre><blockquote><p>然后你可以在模板中任何元素上使用新的  <code>v-focus</code>   <code>property</code>，如下</p></blockquote><pre><code class="html">&lt;input v-focus /&gt;</code></pre><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><blockquote><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p></blockquote><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li><code>componentUpdated</code>：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><blockquote><p>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p></blockquote><h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><blockquote><p>指令钩子函数会被传入以下参数：</p></blockquote><ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>。</li><li><code>binding</code>：一个对象，包含以下 <code>property</code>：<ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li></ul></li><li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener external nofollow noreferrer">VNode API</a> 来了解更多详情。</li><li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul><blockquote><p>除了  <code>el</code>  之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset" target="_blank" rel="noopener external nofollow noreferrer"><code>dataset</code></a>  来进行。</p></blockquote><ul><li>例</li></ul><pre><code class="html">&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">Vue.directive(&quot;demo&quot;, &#123;  bind: function (el, binding, vnode) &#123;    var s = JSON.stringify;    el.innerHTML =      &quot;name: &quot; +      s(binding.name) +      &quot;&lt;br&gt;&quot; +      &quot;value: &quot; +      s(binding.value) +      &quot;&lt;br&gt;&quot; +      &quot;expression: &quot; +      s(binding.expression) +      &quot;&lt;br&gt;&quot; +      &quot;argument: &quot; +      s(binding.arg) +      &quot;&lt;br&gt;&quot; +      &quot;modifiers: &quot; +      s(binding.modifiers) +      &quot;&lt;br&gt;&quot; +      &quot;vnode keys: &quot; +      Object.keys(vnode).join(&quot;, &quot;);  &#125;&#125;);new Vue(&#123;  el: &quot;#hook-arguments-example&quot;,  data: &#123;    message: &quot;hello!&quot;  &#125;&#125;);</code></pre><h3 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h3><blockquote><p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p></blockquote><blockquote><p>例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：</p></blockquote><pre><code class="html">&lt;div id=&quot;baseexample&quot;&gt;  &lt;p&gt;Scroll down the page&lt;/p&gt;  &lt;p v-pin=&quot;200&quot;&gt;Stick me 200px from the top of the page&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">Vue.directive(&quot;pin&quot;, &#123;  bind: function (el, binding, vnode) &#123;    el.style.position = &quot;fixed&quot;;    el.style.top = binding.value + &quot;px&quot;;  &#125;&#125;);new Vue(&#123;  el: &quot;#baseexample&quot;&#125;);</code></pre><blockquote><p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p></blockquote><pre><code class="html">&lt;div id=&quot;dynamicexample&quot;&gt;  &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt;  &lt;p v-pin:[direction]=&quot;200&quot;&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">Vue.directive(&quot;pin&quot;, &#123;  bind: function (el, binding, vnode) &#123;    el.style.position = &quot;fixed&quot;;    var s = binding.arg == &quot;left&quot; ? &quot;left&quot; : &quot;top&quot;;    el.style[s] = binding.value + &quot;px&quot;;  &#125;&#125;);new Vue(&#123;  el: &quot;#dynamicexample&quot;,  data: function () &#123;    return &#123;      direction: &quot;left&quot;    &#125;;  &#125;&#125;);</code></pre><h3 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h3><blockquote><p>在很多时候，你可能想在  <code>bind</code>  和  <code>update</code>  时触发相同行为，而不关心其它的钩子。比如这样写：</p></blockquote><pre><code class="javascript">Vue.directive(&quot;color-swatch&quot;, function (el, binding) &#123;  el.style.backgroundColor = binding.value;&#125;);</code></pre><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><blockquote><p>如果指令需要多个值，可以传入一个 <code>JavaScript</code> 对象字面量。记住，指令函数能够接受所有合法的 <code>JavaScript</code> 表达式。</p></blockquote><pre><code class="html">&lt;div v-demo=&quot;&#123; color: &#39;white&#39;, text: &#39;hello!&#39; &#125;&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">Vue.directive(&quot;demo&quot;, function (el, binding) &#123;  console.log(binding.value.color); // =&gt; &quot;white&quot;  console.log(binding.value.text); // =&gt; &quot;hello!&quot;&#125;);</code></pre><h2 id="15-vue-3-0-尝鲜"><a href="#15-vue-3-0-尝鲜" class="headerlink" title="15. vue 3.0 尝鲜"></a>15. vue 3.0 尝鲜</h2><p><a href="https://www.liulongbin.top:8085/" target="_blank" rel="noopener external nofollow noreferrer">中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络请求 ajax 和 fetch</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%20ajax%20%E5%92%8C%20fetch/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%20ajax%20%E5%92%8C%20fetch/</url>
      
        <content type="html"><![CDATA[<h2 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1. ajax"></a>1. ajax</h2><blockquote><p><code>ajax</code> 是一种使用现有标准的新方法。指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术，接下来我们介绍一下原生的实现。</p></blockquote><h3 id="1-1-原生-ajax-实现"><a href="#1-1-原生-ajax-实现" class="headerlink" title="1.1 原生 ajax 实现"></a>1.1 原生 ajax 实现</h3><blockquote><ol><li>创建 <code>XMLHttpRequest</code> 对象</li><li>发送请求</li><li>服务器端的响应</li></ol></blockquote><pre><code class="javascript">var movieUrl = &quot;https://***&quot;;//    1.创建XMLHttpRequest对象var xmlhttp;if (window.XMLHttpRequest) &#123;  xmlhttp = new XMLHttpRequest();&#125; else &#123;  xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;//    2.发送请求xmlhttp.open(&quot;GET&quot;, movieUrl, true); //    第三个参数 true:异步xmlhttp.send();//    3.服务器端的响应xmlhttp.addEventListener(&quot;readystatechange&quot;, function () &#123;  if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123;    var obj = JSON.parse(xmlhttp.responseText);    console.log(obj);  &#125;&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attr 函数</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Css3/Attr%20%E5%87%BD%E6%95%B0/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Css3/Attr%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CSS 表达式 <code>attr()</code> 用来获取选择到的元素的某一 HTML 属性值，并用于其样式。它也可以用于伪元素，属性值采用伪元素所依附的元素。<br><code>attr()</code>  表达式可以用于任何 <code>css</code>  属性。</p></blockquote><blockquote><p><code>attr(attribute-name &lt;type-or-unit&gt;? [, &lt;fallback&gt; ]? )</code></p></blockquote><ul><li><strong>attribute-name</strong></li></ul><p>**<br>CSS 所引用的 HTML 属性名称。</p><ul><li><strong><type-or-unit></strong></li></ul><p>**<br>表示所引用的属性值的单位。如果该单位相对于所引用的属性值不合法，那么<code>attr()</code>表达式也不合法。若省略，则默认值为<code>string</code>。其合法值包括：</p><table><thead><tr><th align="left">关键字</th><th align="left">类型</th><th align="left">备注</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>string</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/string" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;string&gt;</code></a></td><td align="left">属性值将被解析为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/string" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;string&gt;</code></a></td><td align="left">空字符串</td></tr><tr><td align="left"><code>color</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/color_value" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;color&gt;</code></a></td><td align="left">属性值将被解析为#xxx、#xxxxxx 或关键字的形式，且必须为合法 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/string" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;string&gt;</code></a> 值。</td><td align="left"></td></tr><tr><td align="left">前缀与后缀空格将被截掉。</td><td align="left">当前颜色</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>url</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/uri" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;uri&gt;</code></a></td><td align="left">属性值将被解析为可用于<code>url()</code>函数的字符串。</td><td align="left"></td></tr></tbody></table><p>相对 URL 是根据 HTML 文档的路径解析，而不是样式文件所在的路径。<br>前缀与后缀空格将被截掉。 | URL <code>about:invalid</code>，表示资源不存在。 |<br>| <code>integer</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;integer&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/integer" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;integer&gt;</code></a>。若不是合法值（不是整数或超出 CSS 属性规定的数字范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0</code>，或该属性允许的最小值（如果 0 是不合法的值）。 |<br>| <code>number</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;number&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;number&gt;</code></a>。 若不是合法值（不是数字或超出 CSS 属性规定的数字范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0</code>，或该属性允许的最小值（如果 0 是不合法的值）。 |<br>| <code>length</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;length&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;length&gt;</code></a>，带单位，比如 <code>12.5em</code>。 若不是合法值（不是长度值或超出 CSS 属性规定的范围），则使用默认值。<br>若属性值是一个相对长度， <code>attr()</code>会将其计算为绝对长度。<br>前缀与后缀空格将被截掉。 | <code>0</code>，或该属性允许的最小值（如果 0 是不合法的值）。 |<br>| <code>em</code>, <code>ex</code>, <code>px</code>, <code>rem</code>, <code>vw</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code>, <code>mm</code>, <code>cm</code>, <code>in</code>, <code>pt</code>, or <code>pc</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;length&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;number&gt;</code></a>，不带单位，如 <code>12.5</code>，并被解释为带有所规定单位的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;length&gt;</code></a> 值。若不是合法值（不是长度值或超出 CSS 属性规定的范围），则使用默认值。<br>若属性值是一个相对长度， <code>attr()</code>会将其计算为绝对长度。<br>前缀与后缀空格将被截掉。 | <code>0</code>，或该属性允许的最小值（如果 0 是不合法的值）。 |<br>| <code>angle</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;angle&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;angle&gt;</code></a>，带单位，如<code>30.5deg</code>。若不是合法值（不是角度值或超出 CSS 属性规定的范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0deg</code>，或该属性允许的最小值（如果 0deg 是不合法的值）。 |<br>| <code>deg</code>, <code>grad</code>, <code>rad</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;angle&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;number&gt;</code></a>，不带单位，如<code>12.5</code>)，并被解释为带有所规定单位的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;angle&gt;</code></a> 值。若不是合法值（不是角度值或超出 CSS 属性规定的范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0deg</code>，或该属性允许的最小值（如果 0deg 是不合法的值）。 |<br>| <code>time</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/time" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;time&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/time" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;time&gt;</code></a>，带单位，如<code>30.5ms</code>。若不是合法值（不是时间值或超出 CSS 属性规定的范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0s</code>，或该属性允许的最小值（如果 0s 是不合法的值）。 |<br>| <code>s</code>, <code>ms</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/time" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;time&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/time" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;time&gt;</code></a>，不带单位，如<code>30.5</code>，并被解释为带有所规定单位的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/time" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;time&gt;</code></a> 值。。若不是合法值（不是时间值或超出 CSS 属性规定的范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0s</code>，或该属性允许的最小值（如果 0s 是不合法的值）。 |<br>| <code>frequency</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/frequency" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;frequency&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/frequency" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;frequency&gt;</code></a>，带单位，如<code>12.5kHz</code>)。若不是合法值（不是频率值或超出 CSS 属性规定的范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0Hz</code>，或该属性允许的最小值（如果 0Hz 是不合法的值）。 |<br>| <code>Hz</code>, <code>kHz</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/frequency" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;frequency&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/frequency" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;frequency&gt;</code></a>，不带单位，如<code>12.5</code>)，并被解释为带有所规定单位的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/frequency" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;frequency&gt;</code></a>值。若不是合法值（不是频率值或超出 CSS 属性规定的范围），则使用默认值。<br>前缀与后缀空格将被截掉。 | <code>0Hz</code>，或该属性允许的最小值（如果 0Hz 是不合法的值）。 |<br>| <code>%</code> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;percentage&gt;</code></a> | 属性值将被解析为 CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/number" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;number&gt;</code></a>，不带单位，如<code>12.5</code>)，并被解释为带有所规定单位的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage" target="_blank" rel="noopener external nofollow noreferrer"><code>&lt;percentage&gt;</code></a>值。若不是合法值（不是数字或超出 CSS 属性规定的范围），则使用默认值。<br>若属性值用作长度，<code>attr()</code>将其计算为绝对长度。<br>前缀与后缀空格将被截掉。 | <code>0%</code>，或该属性允许的最小值（如果 0%是不合法的值）。 |</p><ul><li><strong><fallback></strong></li></ul><p>**<br>如果 <code>HTML</code>  元素缺少所规定的属性值或属性值不合法，则使用<code>fallback</code>值。该值必须合法，且不能包含另一个<code>attr()</code>表达式。如果<code>attr()</code>不是所在 <code>CSS</code>  属性值的唯一值，其<code>&lt;fallback&gt;</code>值必须为<code>&lt;type-or-unit&gt;</code>所指定的类型，否则 <code>CSS</code>  会使用相应<code>&lt;type-or-unit&gt;</code>定义的默认值（见上表）。</p><pre><code class="css">ul li::before &#123;  position: absolute;  color: #fff;  left: calc(100% - 50px);  font-size: 12px;  content: attr(data-tip);  line-height: 40px;  transform: scale(0);  transition: all 0.8s;&#125;</code></pre><pre><code class="html">&lt;li data-tip=&quot;about&quot;&gt;  &lt;a href=&quot;&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;&lt;li data-tip=&quot;center&quot;&gt;  &lt;a href=&quot;&quot;&gt;项目中心&lt;/a&gt;&lt;/li&gt;&lt;li data-tip=&quot;media&quot;&gt;  &lt;a href=&quot;&quot;&gt;媒体报道&lt;/a&gt;&lt;/li&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Css3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>元素隐藏问题</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Css3/%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Css3/%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>• <code>display:none</code>: 不占空间，绑定给元素的事件也无法触发<br>• <code>opacity:0</code>: 占空间，事件仍旧可以触发<br>• <code>visibility:hidden</code> : 占空间，也无法触发事件</p>]]></content>
      
      
      <categories>
          
          <category> Css3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>外边距合并问题</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/Css3/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/Css3/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当两个元素是兄弟关系的时候，如果给上方元素设置<code>margin-bottom</code> 给下方元素设置<code>margin-top</code>，外边距会合并，最终外边距是这两个值中较大的那一个；</p></blockquote><blockquote><p>当两个元素是父子关系的时候，如果给内部元素设置<code>margin-top</code>，则父元素也会随着向下移动；解决方式：给父元素添加<code>over-flow:hidden</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Css3 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端自动化测试</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h2><p>对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。</p><h3 id="1-1-单元测试的优缺点"><a href="#1-1-单元测试的优缺点" class="headerlink" title="1.1 单元测试的优缺点"></a>1.1 单元测试的优缺点</h3><ol><li>测试覆盖率高</li><li>业务耦合度高</li><li>代码量大</li><li>过于独立</li></ol><h3 id="1-2-总结"><a href="#1-2-总结" class="headerlink" title="1.2 总结"></a>1.2 总结</h3><p>在某些场景下适合适用单元测试，某些场景下不适合适用单元测试</p><h2 id="2-集成测试"><a href="#2-集成测试" class="headerlink" title="2. 集成测试"></a>2. 集成测试</h2><p>又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p><h2 id="3-jest-中的匹配器"><a href="#3-jest-中的匹配器" class="headerlink" title="3. jest 中的匹配器"></a>3. jest 中的匹配器</h2><p><a href="https://jestjs.io/docs/en/expect" target="_blank" rel="noopener external nofollow noreferrer">jest 匹配器官网</a></p><p>修改 <code>jest</code>  默认配置命令 <code>npx jest --init</code></p><h3 id="3-1-实时监听测试用例的改变"><a href="#3-1-实时监听测试用例的改变" class="headerlink" title="3.1 实时监听测试用例的改变"></a>3.1 实时监听测试用例的改变</h3><p><code>jest --watchAll</code> 一旦某个测试用例发生变化，所有的测试用例都将会重新执行</p><p><code>jest --watch</code>  默认进入 <code>o</code>  模式，即只对发生变化的测试用例重新执行</p><h3 id="3-2-常用匹配器"><a href="#3-2-常用匹配器" class="headerlink" title="3.2 常用匹配器"></a>3.2 常用匹配器</h3><h3 id="3-2-1-toBe"><a href="#3-2-1-toBe" class="headerlink" title="3.2.1 toBe()"></a>3.2.1 toBe()</h3><pre><code class="jsx">test(&quot;测试toBe的匹配器&quot;, () =&gt; &#123;  const a = &#123; name: &quot;张三&quot; &#125;;  expect(a).toBe(&#123; name: &quot;张三&quot; &#125;);&#125;);// ❌ 因为引用类型使用toBe不是全等效果</code></pre><p><code>toBe</code> 匹配器类似于 <code>===</code>。</p><hr><h3 id="3-2-2-toEqual"><a href="#3-2-2-toEqual" class="headerlink" title="3.2.2 toEqual()"></a>3.2.2 toEqual()</h3><pre><code class="jsx">test(&quot;测试toEqual的匹配器&quot;, () =&gt; &#123;  const a = &#123; name: &quot;张三&quot; &#125;;  expect(a).toBe(&#123; name: &quot;张三&quot; &#125;);&#125;);// ✅ 因为toEqual只是对结果的匹配，而不是全等效果</code></pre><p><code>toEqual</code> 匹配器只是对结果相等与否进行匹配</p><hr><h3 id="3-2-3-toBeNull"><a href="#3-2-3-toBeNull" class="headerlink" title="3.2.3 toBeNull()"></a>3.2.3 toBeNull()</h3><pre><code class="jsx">test(&quot;测试toBeNull的匹配器&quot;, () =&gt; &#123;  const a = null;  expect(a).toBeNull();&#125;);// ✅</code></pre><p><code>toBeNull</code> 是对 <code>null</code> 值的匹配</p><hr><h3 id="3-2-4-toBeUndefined"><a href="#3-2-4-toBeUndefined" class="headerlink" title="3.2.4 toBeUndefined()"></a>3.2.4 toBeUndefined()</h3><pre><code class="jsx">test(&quot;测试toBeUndefined的匹配器&quot;, () =&gt; &#123;  const a = undefined;  expect(a).toBeUndefined();&#125;);// ✅</code></pre><p><code>toBeUndefined</code> 是对 <code>undefined</code> 值的匹配</p><hr><h3 id="3-2-5-toBeDefined"><a href="#3-2-5-toBeDefined" class="headerlink" title="3.2.5 toBeDefined()"></a>3.2.5 toBeDefined()</h3><pre><code class="jsx">test(&quot;测试toBeDefined的匹配器&quot;, () =&gt; &#123;  const a = 1;  expect(a).toBeDefined();&#125;);// ✅</code></pre><p><code>toBeDefined</code> 是对已经定义的值的匹配，若为 <code>undefined</code> 则不通过</p><hr><h3 id="3-2-6-toBeTruthy"><a href="#3-2-6-toBeTruthy" class="headerlink" title="3.2.6 toBeTruthy()"></a>3.2.6 toBeTruthy()</h3><pre><code class="jsx">test(&quot;测试toBeTruthy的匹配器&quot;, () =&gt; &#123;  const a = 0;  expect(a).toBeTruthy();&#125;);// 0 =&gt; ❌，因为 toBeTruthy 是对 true 值的匹配// 1 =&gt; ✅</code></pre><p><code>toBeTruthy</code> 是对 <code>true</code> 值的匹配</p><hr><h3 id="3-2-7-toBeFalsy"><a href="#3-2-7-toBeFalsy" class="headerlink" title="3.2.7 toBeFalsy()"></a>3.2.7 toBeFalsy()</h3><pre><code class="jsx">test(&quot;测试toBeFalsy的匹配器&quot;, () =&gt; &#123;  const a = 1;  expect(a).toBeFalsy();&#125;);// 1 =&gt; ❌// 0 =&gt; ✅</code></pre><p><code>toBeFalsy</code> 是对 <code>false</code> 值的匹配</p><hr><h3 id="3-2-8-toBeGreaterThan"><a href="#3-2-8-toBeGreaterThan" class="headerlink" title="3.2.8 toBeGreaterThan()"></a>3.2.8 toBeGreaterThan()</h3><pre><code class="jsx">test(&quot;测试toBeGreaterThan匹配器&quot;, () =&gt; &#123;  const count = 10;  expect(a).toBeGreaterThan(9);&#125;);// ✅</code></pre><p><code>toBeGreaterThan</code> 相当于 <code>&gt;</code></p><hr><h3 id="3-2-9-toBeLessThan"><a href="#3-2-9-toBeLessThan" class="headerlink" title="3.2.9 toBeLessThan()"></a>3.2.9 toBeLessThan()</h3><pre><code class="jsx">test(&quot;测试toBeLessThan匹配器&quot;, () =&gt; &#123;  const count = 8;  expect(a).toBeLessThan(9);&#125;);// ✅</code></pre><p><code>toBeLessThan</code> 相当于 <code>&lt;</code></p><hr><h3 id="3-2-10-toBeGreaterThanOrEqual"><a href="#3-2-10-toBeGreaterThanOrEqual" class="headerlink" title="3.2.10 toBeGreaterThanOrEqual()"></a>3.2.10 toBeGreaterThanOrEqual()</h3><pre><code class="jsx">test(&quot;测试toBeGreaterThanOrEqual匹配器&quot;, () =&gt; &#123;  const count = 10;  expect(a).toBeGreaterThanOrEqual(10);&#125;);// ✅</code></pre><p><code>toBeGreaterThanOrEqual</code> 相当于 <code>&gt;=</code></p><hr><h3 id="3-2-11-toBeLessThanOrEqual"><a href="#3-2-11-toBeLessThanOrEqual" class="headerlink" title="3.2.11 toBeLessThanOrEqual()"></a>3.2.11 toBeLessThanOrEqual()</h3><pre><code class="jsx">test(&quot;测试toBeLessThanOrEqual匹配器&quot;, () =&gt; &#123;  const count = 10;  expect(a).toBeLessThanOrEqual(10);&#125;);// ✅</code></pre><p><code>toBeLessThanOrEqual</code> 相当于 <code>&lt;=</code></p><hr><h3 id="3-2-12-toBeCloseTo"><a href="#3-2-12-toBeCloseTo" class="headerlink" title="3.2.12 toBeCloseTo()"></a>3.2.12 toBeCloseTo()</h3><pre><code class="jsx">test(&quot;测试toBeCloseTo匹配器&quot;, () =&gt; &#123;  const one = 0.1;  const two = 0.2;  expect(one + two).toEqual(0.3);&#125;);// ❌ 因为浮点精度不同test(&quot;测试toBeCloseTo匹配器&quot;, () =&gt; &#123;  const one = 0.1;  const two = 0.2;  expect(one + two).toBeCloseTo(0.3);&#125;);// ✅</code></pre><p><code>toBeCloseTo</code> 为了解决浮点精度不同导致的无法匹配的问题</p><hr><h3 id="3-2-13-toMatch"><a href="#3-2-13-toMatch" class="headerlink" title="3.2.13 toMatch()"></a>3.2.13 toMatch()</h3><pre><code class="jsx">test(&quot;测试toMatch匹配器&quot;, () =&gt; &#123;  const str = &quot;张三、李四、王五&quot;;  expect(str).toMatch(&quot;李四&quot;);&#125;);// ✅test(&quot;测试toMatch匹配器&quot;, () =&gt; &#123;  const str = &quot;张三、李四、王五&quot;;  expect(str).toMatch(/李四/);&#125;);// ✅</code></pre><p><code>toMatch</code> 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式</p><hr><h3 id="3-2-14-toContain"><a href="#3-2-14-toContain" class="headerlink" title="3.2.14 toContain()"></a>3.2.14 toContain()</h3><pre><code class="jsx">test(&quot;测试toContain匹配器&quot;, () =&gt; &#123;  const arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];  expect(arr).toContain(&quot;张三&quot;);&#125;);// ✅test(&quot;测试toContain匹配器&quot;, () =&gt; &#123;  const arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];  const data = new Set(arr);  expect(data).toContain(&quot;张三&quot;);&#125;);</code></pre><p><code>toContain</code> 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 <code>Set</code> 测试</p><hr><h3 id="3-2-15-toHaveLength"><a href="#3-2-15-toHaveLength" class="headerlink" title="3.2.15 toHaveLength()"></a>3.2.15 toHaveLength()</h3><pre><code class="jsx">/// functions.jsexport default &#123;  getIntArray(num) &#123;    if (!Number.isInteger(num)) &#123;      throw Error(&#39;&quot;getIntArray&quot;只接受整数类型的参数&#39;);    &#125;    let result = [];    for (let i = 0, len = num; i &lt; len; i++) &#123;      result.push(i);    &#125;    return result;  &#125;&#125;;/// functions.test.jsimport &#123; getIntArray &#125; from &quot;../src/functions&quot;;test(&quot;getIntArray(3)返回的数组长度应该为3&quot;, () =&gt; &#123;  expect(getIntArray(3)).toHaveLength(3);&#125;);</code></pre><p><code>toHaveLength</code>可以很方便的用来测试字符串和数组类型的长度是否满足预期。</p><h3 id="3-2-16-toThrow"><a href="#3-2-16-toThrow" class="headerlink" title="3.2.16 toThrow()"></a>3.2.16 toThrow()</h3><pre><code class="jsx">const throwNewErrorFunc = () =&gt; &#123;  throw new Error(&quot;this is a new error&quot;);&#125;;test(&quot;测试toThrow匹配器&quot;, () =&gt; &#123;  expect(throwNewErrorFunc).toThrow();&#125;);</code></pre><p><code>toThrow</code> 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常</p><pre><code class="jsx">const throwNewErrorFunc = () =&gt; &#123;  throw new Error(&quot;this is a new error&quot;);&#125;;test(&quot;测试toThrow匹配器&quot;, () =&gt; &#123;  expect(throwNewErrorFunc).toThrow(&quot;this is a new error&quot;);&#125;);</code></pre><p>我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。</p><hr><h3 id="3-2-17-not"><a href="#3-2-17-not" class="headerlink" title="3.2.17 not()"></a>3.2.17 not()</h3><pre><code class="jsx">const throwNewErrorFunc = () =&gt; &#123;  throw new Error(&quot;this is a new error&quot;);&#125;;test(&quot;测试not匹配器&quot;, () =&gt; &#123;  expect(throwNewErrorFunc).not.toThrow();&#125;);</code></pre><p><code>not</code> 匹配器是 <code>jest</code> 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用<code>not</code> 匹配器。</p><hr><h3 id="3-3-异步代码测试方法"><a href="#3-3-异步代码测试方法" class="headerlink" title="3.3 异步代码测试方法"></a>3.3 异步代码测试方法</h3><h3 id="3-3-1-回调函数式"><a href="#3-3-1-回调函数式" class="headerlink" title="3.3.1 回调函数式"></a>3.3.1 回调函数式</h3><pre><code class="jsx">/// fetchData.jsimport axios from &quot;axios&quot;;export const fetchData = fn =&gt; &#123;  axios.get(&quot;http://a.jspang.com/jestTest.json&quot;).then(res =&gt; &#123;    fn(res.data);  &#125;);&#125;;/// fetchData.test.jsimport &#123; fetchData &#125; from &quot;./fetchData.js&quot;;test(&quot;fetchData测试&quot;, done =&gt; &#123;  fetchData(data =&gt; &#123;    expect(data).toEqual(&#123; success: true &#125;);    done();  &#125;);&#125;);</code></pre><p>必须加入一个 <code>done</code> 方法，保证我们的回调已经完成了，这时候我们表示测试完成</p><hr><h3 id="3-3-2-直接返回-Promise"><a href="#3-3-2-直接返回-Promise" class="headerlink" title="3.3.2 直接返回 Promise"></a>3.3.2 直接返回 Promise</h3><pre><code class="jsx">/// fetchTwoData.jsimport axios from &quot;axios&quot;;export const fetchTwoData = () =&gt; axios.get(&quot;http://a.jspang.com/jestTest.json&quot;;/// fetchTwoData.test.jsimport &#123; fetchTwoData &#125; from &quot;./fetchTwoData.js&quot;;test(&quot;fetchTwoData的测试用例&quot;, () =&gt; &#123; return fetchTwoData().then(res =&gt; &#123;  expect(res.data).toEqual(&#123; success: true &#125;); &#125;);&#125;);</code></pre><p>注意要 <code>return</code></p><h3 id="3-3-3-不存在的接口"><a href="#3-3-3-不存在的接口" class="headerlink" title="3.3.3 不存在的接口"></a>3.3.3 不存在的接口</h3><pre><code class="jsx">/// fetchData.jsexport const fetchData = () =&gt; &#123;  return axios.get(&quot;http://a.jspang.com/jestTest_error.json&quot;); // 此地址并不存在&#125;;/// fetchData.test.js// 方式1test(&quot;fetchData测试&quot;, () =&gt; &#123;  expect.assertions(1); // 断言，必须执行一次 expect  return fetchData().catch(err =&gt; &#123;    expect(err.toString().indexOf(&quot;404&quot;) &gt; -1).toBe(true);  &#125;);&#125;);// 方式2test(&quot;fetchData测试&quot;, async () =&gt; &#123;  return await fetchData().rejects.toThrow();&#125;);// 方式3test(&quot;fetchData测试&quot;, async () =&gt; &#123;  expect().assertions(1); // 断言，必须执行一次 expect  try &#123;    await fetchData();  &#125; catch (err) &#123;    expect(err.toString().indexOf(&quot;404&quot;) &gt; -1).toBe(true);  &#125;&#125;);</code></pre><p>因为测试用例使用了 <code>catch</code> 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，<code>jest</code> 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。</p><h3 id="3-3-4-async-await"><a href="#3-3-4-async-await" class="headerlink" title="3.3.4 async/await"></a>3.3.4 async/await</h3><pre><code class="jsx">/// fetchData.jsexport const fetchData = () =&gt; &#123; return axios.get(&quot;http://a.jspang.com/jestTest.json&quot;); // 此地址并不存在&#125;;/// fetchData.test.js// 方式1test(&quot;fetchData测试&quot;, async () =&gt; &#123; await expect(fetchData()).resolves.toMatchObject(&#123;  data: &#123;   success: true  &#125; &#125;);&#125;);// 方式2test(&quot;fetchData测试&quot;, async () =&gt; &#123; const response = await fetchData(); expect(response.data).toEqual(&#123; success: true &#125;);&#125;);</code></pre><p>这时候我们的代码使用 <code>async....await...</code> 的形式，这里我们还使用了 <code>resolves</code> 用于把现有对象转换成 <code>Promise</code> 对象，然后使用 <code>jest</code> 中的 <code>toMatchObject</code> 进行匹配对象中的属性。</p><h2 id="4-jest-中的四个钩子函数"><a href="#4-jest-中的四个钩子函数" class="headerlink" title="4. jest 中的四个钩子函数"></a>4. jest 中的四个钩子函数</h2><h3 id="4-1-beforeAll"><a href="#4-1-beforeAll" class="headerlink" title="4.1 beforeAll()"></a>4.1 beforeAll()</h3><p><code>beforeAll()</code>钩子函数的意思是在所有测试用例之前进行执行。</p><h3 id="4-2-afterAll"><a href="#4-2-afterAll" class="headerlink" title="4.2 afterAll()"></a>4.2 afterAll()</h3><p><code>afterAll()</code>钩子函数是在完成所有测试用例之后才执行的函数。</p><h3 id="4-3-beforeEach"><a href="#4-3-beforeEach" class="headerlink" title="4.3 beforeEach()"></a>4.3 beforeEach()</h3><p><code>beforeEach()</code>钩子函数，是在每个测试用例前都会执行一次的钩子函数。</p><h3 id="4-4-afterEach"><a href="#4-4-afterEach" class="headerlink" title="4.4 afterEach()"></a>4.4 afterEach()</h3><p><code>afterEach()</code>钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。</p><h2 id="5-jest-测试用例分组"><a href="#5-jest-测试用例分组" class="headerlink" title="5. jest 测试用例分组"></a>5. jest 测试用例分组</h2><pre><code class="jsx">/// eat.jsexport default class Eat &#123;  setName(number) &#123;    this.name = number === 1 ? &quot;水饺&quot; : &quot;火锅&quot;;  &#125;  setDesc() &#123;    this.desc = this.user + &quot;描述&quot;;  &#125;  setMoney() &#123;    this.money = this.name === &quot;水饺&quot; ? 80 : 300;  &#125;&#125;/// eat.test.jsimport Eat from &quot;./eat&quot;;const eat = new Eat();beforeAll(() =&gt; &#123;  console.log(&quot;开始吃饭&quot;);&#125;);afterAll(() =&gt; &#123;  console.log(&quot;吃完饭了&quot;);&#125;);describe(&quot;水饺相关内容&quot;, () =&gt; &#123;  test(&quot;测试水饺描述&quot;, () =&gt; &#123;    eat.setName(1);    eat.setDesc();    expect(eat.desc).toEqual(&quot;水饺描述&quot;);  &#125;);  test(&quot;测试水饺价格&quot;, () =&gt; &#123;    eat.setName(1);    eat.setMoney();    expect(eat.money).toEqual(80);  &#125;);&#125;);describe(&quot;火锅相关内容&quot;, () =&gt; &#123;  test(&quot;测试火锅描述&quot;, () =&gt; &#123;    eat.setName(2);    eat.setDesc();    expect(eat.desc).toEqual(&quot;火锅描述&quot;);  &#125;);  test(&quot;测试火锅价格&quot;, () =&gt; &#123;    eat.setName(2);    eat.setMoney();    expect(eat.money).toEqual(300);  &#125;);&#125;);</code></pre><h2 id="6-钩子函数的作用域"><a href="#6-钩子函数的作用域" class="headerlink" title="6. 钩子函数的作用域"></a>6. 钩子函数的作用域</h2><h3 id="6-1-钩子函数在父级分组可作用域子集，类似继承"><a href="#6-1-钩子函数在父级分组可作用域子集，类似继承" class="headerlink" title="6.1 钩子函数在父级分组可作用域子集，类似继承"></a>6.1 钩子函数在父级分组可作用域子集，类似继承</h3><p>即父级作用域下的钩子函数在子作用域下也生效</p><h3 id="6-2-钩子函数同级分组作用域互不干扰，各起作用"><a href="#6-2-钩子函数同级分组作用域互不干扰，各起作用" class="headerlink" title="6.2 钩子函数同级分组作用域互不干扰，各起作用"></a>6.2 钩子函数同级分组作用域互不干扰，各起作用</h3><p>同作用域下将都会执行</p><h3 id="6-3-先执行外部的钩子函数，再执行内部的钩子函数"><a href="#6-3-先执行外部的钩子函数，再执行内部的钩子函数" class="headerlink" title="6.3 先执行外部的钩子函数，再执行内部的钩子函数"></a>6.3 先执行外部的钩子函数，再执行内部的钩子函数</h3><p>优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数</p><h3 id="6-4-在进行测试准备的时候，将对应逻辑写到钩子函数"><a href="#6-4-在进行测试准备的时候，将对应逻辑写到钩子函数" class="headerlink" title="6.4 在进行测试准备的时候，将对应逻辑写到钩子函数"></a>6.4 在进行测试准备的时候，将对应逻辑写到钩子函数</h3><p>如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数</p><h3 id="6-5-对单个测试用例的调试"><a href="#6-5-对单个测试用例的调试" class="headerlink" title="6.5 对单个测试用例的调试"></a>6.5 对单个测试用例的调试</h3><p>当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 <code>test.only</code></p><pre><code class="jsx">test.only(&quot;测试用例&quot;, () =&gt; &#123;  expect(1 + 1).toBe(2);&#125;);</code></pre><h2 id="7-Jest-中的-Mock"><a href="#7-Jest-中的-Mock" class="headerlink" title="7. Jest 中的 Mock"></a>7. Jest 中的 Mock</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a>7.1 作用</h3><h3 id="7-1-1-捕获函数的调用和返回结果，以及-this-和调用顺序"><a href="#7-1-1-捕获函数的调用和返回结果，以及-this-和调用顺序" class="headerlink" title="7.1.1 捕获函数的调用和返回结果，以及 this 和调用顺序"></a>7.1.1 捕获函数的调用和返回结果，以及 <code>this</code> 和调用顺序</h3><h3 id="7-1-2-它可以让我们自由的设置返回结果"><a href="#7-1-2-它可以让我们自由的设置返回结果" class="headerlink" title="7.1.2 它可以让我们自由的设置返回结果"></a>7.1.2 它可以让我们自由的设置返回结果</h3><h3 id="7-1-3-改变内部函数的实现"><a href="#7-1-3-改变内部函数的实现" class="headerlink" title="7.1.3 改变内部函数的实现"></a>7.1.3 改变内部函数的实现</h3><h3 id="7-2-判定函数是否被调用"><a href="#7-2-判定函数是否被调用" class="headerlink" title="7.2 判定函数是否被调用"></a>7.2 判定函数是否被调用</h3><pre><code class="jsx">// demo.jsexport const runCallback = callback =&gt; &#123;  callback();&#125;;// demo.test.jsimport &#123; runCallback &#125; from &quot;./demo&quot;;test(&quot;测试 runCallback&quot;, () =&gt; &#123;  const func = jest.fn();  runCallback(func);  expect(func).toBeCalled(); // 测试用例被调用&#125;);</code></pre><p><code>jest.fn()</code>  可以帮助我们捕获函数的调用</p><h3 id="7-3-jest-fn-mock-calls-判定函数被调用了几次和传递的参数"><a href="#7-3-jest-fn-mock-calls-判定函数被调用了几次和传递的参数" class="headerlink" title="7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数"></a>7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数</h3><pre><code class="jsx">// demo.jsexport const runCallback = callback =&gt; &#123;  callback(&quot;张三&quot;);&#125;;// demo.test.jsimport &#123; runCallback &#125; from &quot;./demo&quot;;test(&quot;测试 runCallback&quot;, () =&gt; &#123;  const func = jest.fn();  runCallback(func);  runCallback(func);  expect(func.mock.calls.length).toBe(2); // 测试用例被调用2次  expect(func.mock.calls[0]).toEqual([&quot;张三&quot;]); // 测试用例传递的第一个参数是 &quot;张三&quot;&#125;);</code></pre><p>此处打印 <code>func.mock</code>  将会打印一些常用的方法，可以根据需求进行相应的用例测试</p><h3 id="7-4-jest-fn-mockReturnValue-判定函数执行了几次和返回结果"><a href="#7-4-jest-fn-mockReturnValue-判定函数执行了几次和返回结果" class="headerlink" title="7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果"></a>7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果</h3><pre><code class="jsx">// demo.jsexport const runCallback = callback =&gt; &#123;  callback(&quot;张三&quot;);&#125;;// demo.test.jsimport &#123; runCallback &#125; from &quot;./demo&quot;;test(&quot;测试 runCallback&quot;, () =&gt; &#123;  const func = jest.fn();  // func.mockReturnValue(&quot;Common&quot;)  // 所有模拟返回值都是 &quot;Common&quot;  func.mockReturnValueOnce(&quot;A&quot;); // 第一次模拟返回值返回 &quot;A&quot;  func.mockReturnValueOnce(&quot;B&quot;); // 第二次模拟返回值返回 &quot;B&quot;  func.mockReturnValueOnce(&quot;C&quot;); // 第三次模拟返回值返回 &quot;C&quot;  runCallback(func);  runCallback(func);  runCallback(func);  expect(func.mock.results[0].value).toBe(&quot;A&quot;);  expect(func.mock.results[1].value).toBe(&quot;B&quot;);  expect(func.mock.results[2].value).toBe(&quot;C&quot;);&#125;);</code></pre><p><code>func.mockReturnValue()</code>  将对所有模拟返回的值生效</p><p><code>func.mockReturnValueOnce()</code>  执行到第几次就对第几个函数的模拟返回值生效</p><p>支持链式调用</p><h3 id="7-5-jest-fn-mock-invocationCallOrder-判定函数执行顺序"><a href="#7-5-jest-fn-mock-invocationCallOrder-判定函数执行顺序" class="headerlink" title="7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序"></a>7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序</h3><pre><code class="jsx">// demo.jsexport const runCallback = callback =&gt; &#123;  callback(&quot;张三&quot;);&#125;;// demo.test.jsimport &#123; runCallback &#125; from &quot;./demo&quot;;test(&quot;测试 runCallback&quot;, () =&gt; &#123;  const func = jest.fn();  runCallback(func);  runCallback(func);  runCallback(func);  expect(func.mock.invocationCallOrder).toEqual([1, 2, 3]);&#125;);</code></pre><h3 id="7-6-jest-fn-mock-instances-判定函数调用了几次以及-this-指向"><a href="#7-6-jest-fn-mock-instances-判定函数调用了几次以及-this-指向" class="headerlink" title="7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向"></a>7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向</h3><pre><code class="jsx">// demo.jsexport const createObject = (ClassItem) =&gt; &#123;  new ClassItem();&#125;// demo.test.jsimport &#123; createObject &#125; from &quot;./demo&quot;;test(&quot;测试 createObject&quot;, () =&gt; &#123;  const func = jest.fn();  createObject(func);  expect(func.mock.instances).toEqual([mockConstructor&#123;&#125;]); // 此处的 this 就是 mockConstructor&#125;);</code></pre><h3 id="7-7-jest-fn-mockImplementation-判定函数返回结果和其他逻辑处理"><a href="#7-7-jest-fn-mockImplementation-判定函数返回结果和其他逻辑处理" class="headerlink" title="7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理"></a>7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理</h3><pre><code class="jsx">// demo.jsexport const runCallback = callback =&gt; &#123;  callback(&quot;张三&quot;);&#125;;// demo.test.jsimport &#123; runCallback &#125; from &quot;./demo&quot;;test(&quot;测试 runCallback&quot;, () =&gt; &#123;  const func = jest.fn();  // func.mockImplementation(() =&gt; &quot;hello&quot;); 等价于 jest.fn(() =&gt; &quot;hello&quot;)  // func.mockImplementation(() =&gt; this); 等价于 jest.fn().mockReturnThis()  func.mockImplementationOnce(() =&gt; &quot;dell&quot;);  func.mockImplementationOnce(() =&gt; &quot;lee&quot;);  runCallback(func);  runCallback(func);  runCallback(func);  expect(func.mock.results[0].value).toBe(&quot;dell&quot;);  expect(func.mock.results[1].value).toBe(&quot;lee&quot;);&#125;);</code></pre><p><code>mockImplementation</code>  比 <code>mockReturnValue</code>  更健壮，因为内部可以写一些额外的逻辑</p><h3 id="7-8-toBeCalledWith-来判定每次函数调用时的参数"><a href="#7-8-toBeCalledWith-来判定每次函数调用时的参数" class="headerlink" title="7.8 toBeCalledWith() 来判定每次函数调用时的参数"></a>7.8 toBeCalledWith() 来判定每次函数调用时的参数</h3><pre><code class="jsx">// demo.jsexport const runCallback = (callback) =&gt; &#123;  callback(&quot;ABC&quot;);&#125;// demo.test.jsimport &#123; runCallback &#125; from &quot;./demo&quot;;test(&quot;测试 runCallback&quot;, () =&gt; &#123;  const func = jest.fn();  runCallback(func);  expect(func.mock.results[0]).toEqual([&quot;ABC&quot;);  expect(func).toBeCalledWith(&quot;ABC&quot;);&#125;);</code></pre><h3 id="7-9-模拟异步请求"><a href="#7-9-模拟异步请求" class="headerlink" title="7.9 模拟异步请求"></a>7.9 模拟异步请求</h3><p>对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容</p><h3 id="7-9-1-通过模拟库的方式来模拟异步测试"><a href="#7-9-1-通过模拟库的方式来模拟异步测试" class="headerlink" title="7.9.1 通过模拟库的方式来模拟异步测试"></a>7.9.1 通过模拟库的方式来模拟异步测试</h3><pre><code class="jsx">// demo.jsexport const getData = () =&gt; &#123;  return axios.get(&quot;/api&quot;).then(res =&gt; res.data);&#125;;// demo.test.jsimport axios from &quot;axios&quot;;import &#123; getData &#125; from &quot;./demo&quot;;jest.mock(&quot;axios&quot;); // 对 axios 进行模拟，这样就不会请求真正数据test(&quot;测试 getData&quot;, async () =&gt; &#123;  axios.get.mockResolvedValue(&#123; data: &quot;hello&quot; &#125;); // 使用 axios 请求的时候模拟成功的返回值就是 hello  await getData().then(data =&gt; &#123;    expect(data).toBe(&quot;hello&quot;);  &#125;);&#125;);</code></pre><p><code>mockResolvedValue</code> 模拟不限次数</p><p><code>mockResolvedValueOnce</code> 模拟一次，模拟两次就会报错，需再次调用</p><h3 id="7-9-2-通过模拟-Promise-方式模拟异步"><a href="#7-9-2-通过模拟-Promise-方式模拟异步" class="headerlink" title="7.9.2 通过模拟 Promise 方式模拟异步"></a>7.9.2 通过模拟 Promise 方式模拟异步</h3><pre><code class="jsx">// demo.jsexport const fetchData = () =&gt; &#123;  return axios.get(&quot;/&quot;).then(res =&gt; res.data);&#125;;// __mocks__/demo.jsexport const fetchData = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    resolve(&quot;function() &#123; return &#39;123&#39; &#125;&quot;);  &#125;);&#125;;// demo.test.jsjest.mock(&quot;./demo&quot;);import &#123; fetchData &#125; from &quot;./demo&quot;;test(&quot;测试fetchData&quot;, () =&gt; &#123;  return fetchData().then(data =&gt; &#123;    expect(eval(data)).toEqual(&quot;123&quot;);  &#125;);&#125;);/// 实现方式3// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换// 等同于 jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)&#123;  automock: true; &#125;</code></pre><h3 id="7-9-3-通过修改-jest-config-js-来自动识别mocks下的文件"><a href="#7-9-3-通过修改-jest-config-js-来自动识别mocks下的文件" class="headerlink" title="7.9.3 通过修改 jest.config.js 来自动识别mocks下的文件"></a>7.9.3 通过修改 jest.config.js 来自动识别<strong>mocks</strong>下的文件</h3><p>修改 <code>jest.config.js</code> 可以自动查找项目内部 <code>__mocks__</code> 下与要测试文件名字相同的文件做替换</p><p>等同于&gt; <code>jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)</code></p><h3 id="7-9-4-使用-jest-unmock-可取消-mock-模拟"><a href="#7-9-4-使用-jest-unmock-可取消-mock-模拟" class="headerlink" title="7.9.4 使用 jest.unmock() 可取消 mock 模拟"></a>7.9.4 使用 jest.unmock() 可取消 mock 模拟</h3><h3 id="7-9-5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题"><a href="#7-9-5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题" class="headerlink" title="7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题"></a>7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题</h3><pre><code class="jsx">// demo.jsexport const fetchData = () =&gt; &#123;  return axios.get(&quot;/&quot;).then(res =&gt; res.data);&#125;;export const getNumber = () =&gt; 123;// __mocks__/demo.jsexport const fetchData = () =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    resolve(&quot;function() &#123; return &#39;123&#39; &#125;&quot;);  &#125;);&#125;;// demo.test.jsjest.mock(&quot;./demo&quot;);import &#123; fetchData &#125; from &quot;./demo&quot;;const &#123; getNumber &#125; = jest.requireActual(&quot;./demo&quot;); // 引入真实文件test(&quot;测试 fetchData&quot;, () =&gt; &#123;  return fetchData().then(data =&gt; &#123;    expect(eval(data)).toEqual(&quot;123&quot;);  &#125;);&#125;);test(&quot;测试 getNumber&quot;, () =&gt; &#123;  expect(getNumber()).toEqual(123);&#125;);</code></pre><h2 id="8-snapshot-快照测试"><a href="#8-snapshot-快照测试" class="headerlink" title="8. snapshot 快照测试"></a>8. snapshot 快照测试</h2><p>常用于测试配置文件</p><h3 id="8-1-toMatchSnapshot"><a href="#8-1-toMatchSnapshot" class="headerlink" title="8.1 toMatchSnapshot()"></a>8.1 toMatchSnapshot()</h3><pre><code class="jsx">// demo.jsexport const generateConfig = () =&gt; &#123;  return &#123;    server: &quot;http://localhost&quot;,    port: 8080,    domain: &quot;localhost&quot;  &#125;;&#125;;// demo.test.jsimport &#123; generateConfig &#125; from &quot;./demo&quot;;test(&quot;测试 generateConfig&quot;, () =&gt; &#123;  expect(generateConfig()).toMatchSnapshot(); // 将会在项目里生成快照文件&#125;);</code></pre><p>如果要确认更新快照，需要在控制台选择。 <code>u</code>  代表对所有快照进行更新， <code>i</code>  代表对单个确认的快照进行更新</p><h3 id="8-2-测试部分可变变量的内容"><a href="#8-2-测试部分可变变量的内容" class="headerlink" title="8.2 测试部分可变变量的内容"></a>8.2 测试部分可变变量的内容</h3><pre><code class="jsx">// demo.jsexport const generateConfig = () =&gt; &#123;  return &#123;    server: &quot;http://localhost&quot;,    port: 8080,    domain: &quot;localhost&quot;,    time: new Date(),    // 可变变量    random: Math.random()    // 可变变量  &#125;;&#125;;// demo.test.jsimport &#123; generateConfig &#125; from &quot;./demo&quot;;test(&quot;测试 generateConfig&quot;, () =&gt; &#123;  expect(generateConfig()).toMatchSnapshot(&#123;    time: expect.any(Date),    random: expect.any(Number)  &#125;);&#125;);</code></pre><h3 id="8-3-行内的-snapshot"><a href="#8-3-行内的-snapshot" class="headerlink" title="8.3 行内的 snapshot"></a>8.3 行内的 snapshot</h3><p><code>npm install prettier --save</code></p><p>可以快照放到行内的测试用例中</p><pre><code class="jsx">// demo.jsexport const generateConfig = () =&gt; &#123;  return &#123;    server: &quot;http://localhost&quot;,    port: 8080,    domain: &quot;localhost&quot;,    time: new Date(),    // 可变变量    random: Math.random()    // 可变变量  &#125;;&#125;;// demo.test.jsimport &#123; generateConfig &#125; from &quot;./demo&quot;;test(&quot;测试 generateConfig&quot;, () =&gt; &#123;  // toMatchInlineSnapshot 可以快照放到行内的测试用例中  expect(generateConfig()).toMatchInlineSnapshot(&#123;    time: expect.any(Date),    random: expect.any(Number)  &#125;);&#125;);</code></pre><hr><h2 id="9-Test-Driven-Development-TDD-测试驱动开发"><a href="#9-Test-Driven-Development-TDD-测试驱动开发" class="headerlink" title="9. Test Driven Development(TDD) 测试驱动开发"></a>9. Test Driven Development(TDD) 测试驱动开发</h2><h3 id="9-1-TDD-开发流程"><a href="#9-1-TDD-开发流程" class="headerlink" title="9.1 TDD 开发流程"></a>9.1 TDD 开发流程</h3><ol><li>编写测试用例（知道功能，先写测试用例）</li><li>运行测试，测试用例无法通过测试</li><li>编写代码，使测试用例通过测试</li><li>优化代码， 完成开发</li><li>新增功能，重复执行 1-4</li></ol><h3 id="9-2-TDD-的优势"><a href="#9-2-TDD-的优势" class="headerlink" title="9.2 TDD 的优势"></a>9.2 TDD 的优势</h3><ol><li>长期减少项目的回归 bug（减少修改代码产生的 bug）</li><li>代码质量更好（组织，可维护性好）</li><li>测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）</li><li>错误测试代码不容易出现</li></ol><h3 id="9-3-TDD-的适用场景"><a href="#9-3-TDD-的适用场景" class="headerlink" title="9.3 TDD 的适用场景"></a>9.3 TDD 的适用场景</h3><ol><li>不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）</li><li>适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）</li></ol><hr><h2 id="10-Behavior-Driven-Development-BDD-行为驱动开发"><a href="#10-Behavior-Driven-Development-BDD-行为驱动开发" class="headerlink" title="10. Behavior Driven Development(BDD) 行为驱动开发"></a>10. Behavior Driven Development(BDD) 行为驱动开发</h2><h3 id="10-1-BDD-开发流程"><a href="#10-1-BDD-开发流程" class="headerlink" title="10.1 BDD 开发流程"></a>10.1 BDD 开发流程</h3><ol><li>先编写业务代码，不关心测试</li><li>思考并描述用户行为</li><li>根据用户行为模拟测试</li></ol><h3 id="10-2-vue-example"><a href="#10-2-vue-example" class="headerlink" title="10.2 vue example"></a>10.2 vue example</h3><pre><code class="jsx">/// testUtils.jsexport const findTestWrapper = (wrapper, tag) =&gt; &#123;  return wrapper.find(`[data-test=&quot;$&#123;tag&#125;&quot;]`);&#125;;</code></pre><pre><code class="jsx">/// __tests__/integration/TodoList.test.jsimport &#123; mount &#125; from &quot;@vue/test-utils&quot;;import &#123; findTestWrapper &#125; from &quot;../../../../utils/testUtils&quot;;import TodoList from &quot;../../TodoList&quot;;// import store from &quot;../../../../store&quot;it(`     新增内容逻辑的集成测试     1. 用户会在header输入框输入内容     2. 用户会点击回车按钮   3. 列表项应该增加用户输入内容的列表项`, () =&gt; &#123;  const wrapper = mount(TodoList);  // const wrapper = mount(TodoList, &#123; store &#125;)  // 如果使用 vuex，也几乎无改动  const inputElem = findTestWrapper(wrapper, &quot;header-input&quot;).at(0);  const content = &quot;Dell lee&quot;;  inputElem.setValue(content);  inputElem.trigger(&quot;change&quot;);  inputElem.trigger(&quot;keyup.enter&quot;);  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;).at(0);  expect(listItems.length).toBe(1);  expect(listItems.at(0).text()).toContain(content);&#125;);</code></pre><h3 id="10-3-react-example"><a href="#10-3-react-example" class="headerlink" title="10.3 react example"></a>10.3 react example</h3><pre><code class="jsx">/// testUtils.jsexport const findTestWrapper = (wrapper, tag) =&gt; &#123;  return wrapper.find(`[data-test=&quot;$&#123;tag&#125;&quot;]`);&#125;;</code></pre><pre><code class="jsx">/// __tests__/integration/TodoList.test.jsimport React from &quot;react&quot;;// import &#123; Provider &#125; from &quot;react-redux&quot;;import Enzyme, &#123; mount &#125; from &quot;enzyme&quot;;import Adapter from &quot;enzyme-adapter-react-16&quot;;import TodoList from &quot;../../TodoList&quot;;// import store from &quot;../../../../store/createStore&quot;;Enzyme.configure(&#123; adapter: new Adapter() &#125;);it(`    新增内容逻辑的集成测试    1. 用户会在header输入框输入内容    2. 用户会点击回车按钮   3. 列表项应该增加用户输入内容的列表项`, () =&gt; &#123;  const wrapper = mount(&lt;TodoList /&gt;);  /**   const wrapper = mount(   &lt;Provider store=&#123;store&#125;&gt;    &lt;TodoList /&gt;&lt;/Provider&gt;   &lt;/Provider&gt;  )    // 如果使用 redux，也几乎无改动 */  const inputElem = findTestWrapper(wrapper, &quot;header-input&quot;);  const content = &quot;Dell lee&quot;;  inputElem.simulate(&quot;change&quot;, &#123; target: &#123; value: content &#125; &#125;);  inputElem.simulate(&quot;keyUp&quot;, &#123; keyCode: 13 &#125;);  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);  expect(listItems.length).toBe(1);  expect(listItems.text()).toContain(content);&#125;);</code></pre><hr><h2 id="11-TDD-和-BDD-的对比"><a href="#11-TDD-和-BDD-的对比" class="headerlink" title="11. TDD 和 BDD 的对比"></a>11. TDD 和 BDD 的对比</h2><ol><li><code>TDD</code> 先写测试后写代码; <code>BDD</code> 先写代码后写测试</li><li><code>TDD</code> 创建的是 <code>unit</code> 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); <code>BDD</code> 创建的是 <code>integration</code> 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)</li><li><code>TDD</code> 测试重点在代码; <code>BDD</code> 测试重点在 <code>UI</code> ( <code>DOM</code>)</li><li><code>TDD</code> 安全感低(无法保证各个组件拼撞到一起是否不会有问题); <code>BDD</code> 安全感高</li><li><code>TDD</code> 速度快; <code>BDD</code> 速度慢</li></ol><hr><h2 id="12-TDD-与-BDD-混用"><a href="#12-TDD-与-BDD-混用" class="headerlink" title="12. TDD 与 BDD 混用"></a>12. TDD 与 BDD 混用</h2><h3 id="12-1-对一些工具函数的测试"><a href="#12-1-对一些工具函数的测试" class="headerlink" title="12.1 对一些工具函数的测试"></a>12.1 对一些工具函数的测试</h3><h3 id="12-2-对-vuex-的-store-进行测试"><a href="#12-2-对-vuex-的-store-进行测试" class="headerlink" title="12.2 对 vuex 的 store 进行测试"></a>12.2 对 vuex 的 store 进行测试</h3><pre><code class="jsx">/// __tests__/unit/store.test.jsimport store from &quot;../../../../store&quot;;it(&quot;当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化&quot;, () =&gt; &#123;  const value = &quot;123&quot;;  store.commit(&quot;changeInputValue&quot;, value);  expect(store.state.inputValue).toBe(value);&#125;);</code></pre><h3 id="12-3-对-redux-的-store-进行测试"><a href="#12-3-对-redux-的-store-进行测试" class="headerlink" title="12.3 对 redux 的 store 进行测试"></a>12.3 对 redux 的 store 进行测试</h3><pre><code class="jsx">/// __tests__/unit/store.test.jsimport store from &quot;../../../../store/createStore&quot;;import &#123; changeInputValue &#125; from &quot;../../../../store/actions&quot;;it(&quot;当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化&quot;, () =&gt; &#123;  const value = &quot;123&quot;;  /**     const changeInputValue = (payload) =&gt; (&#123;    type: CHANGE_IMPUT_VALUE, payload   &#125;)    */  store.dispatch(changeInputValue(value));  expect(store.getState().inputValue).toBe(value);&#125;);</code></pre><hr><h2 id="13-异步测试"><a href="#13-异步测试" class="headerlink" title="13. 异步测试"></a>13. 异步测试</h2><p>注意：异步测试如果用到了异步函数，则需要调用 <code>done</code>  函数</p><h3 id="13-1-vue-的异步测试"><a href="#13-1-vue-的异步测试" class="headerlink" title="13.1 vue 的异步测试"></a>13.1 vue 的异步测试</h3><pre><code class="javascript">/// __mocks__/axios.jsconst undoList = &#123;  success: true,  data: [ &#123; status: &quot;div&quot;, value: &quot;dell&quot; &#125;, &#123; status: &quot;div&quot;, value: &quot;lee&quot; &#125;]&#125;;export default &#123; get(url) &#123;  if (url === &quot;/getUndoList.json&quot;) &#123;   return new Promise((resolve, reject) =&gt; &#123;    if (this.success === true) &#123;     resolve(undoList);    &#125; else &#123;     reject(new Error());    &#125;   &#125;);  &#125; &#125;&#125;;/// __tests__/integration/TodoList.test.jsimport &#123; mount &#125; from &quot;@vue/test-utils&quot;;import &#123; findTestWrapper &#125; from &quot;../../../../utils/testUtils&quot;;import TodoList from &quot;../../TodoList&quot;;import store from &quot;../../../../store&quot;;beforeEach(() =&gt; &#123; axios.success = true; jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响&#125;);it(`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`, done =&gt; &#123;  const wrapper = mount(TodoList, &#123; store &#125;);  wrapper.vm.$nickTick(() =&gt; &#123;   const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);   expect(listItems.length).toBe(2);   done();  &#125;); &#125;);it(`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`, done =&gt; &#123; const wrapper = mount(TodoList, &#123; store &#125;); expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器 jest.runAllTimers(); wrapper.vm.$nickTick(() =&gt; &#123;  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);  expect(listItems.length).toBe(2);  done(); &#125;);&#125;);it(`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`, done =&gt; &#123; axios.success = false; const wrapper = mount(TodoList, &#123; store &#125;); expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器 jest.runAllTimers(); wrapper.vm.$nickTick(() =&gt; &#123;  const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);  expect(listItems.length).toBe(0);  done(); &#125;);&#125;);</code></pre><h3 id="13-2-react-的异步测试"><a href="#13-2-react-的异步测试" class="headerlink" title="13.2 react 的异步测试"></a>13.2 react 的异步测试</h3><pre><code class="jsx">/// __mocks__/axios.jsconst undoList = &#123;  success: true,  data: [    &#123; status: &quot;div&quot;, value: &quot;dell&quot; &#125;,    &#123; status: &quot;div&quot;, value: &quot;lee&quot; &#125;  ]&#125;;export default &#123;  get(url) &#123;    if (url === &quot;/getUndoList.json&quot;) &#123;      return new Promise((resolve, reject) =&gt; &#123;        if (this.success === true) &#123;          resolve(undoList);        &#125; else &#123;          reject(new Error());        &#125;      &#125;);    &#125;  &#125;&#125;;/// __tests__/integration/TodoList.test.jsimport React from &quot;react&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import Enzyme, &#123; mount &#125; from &quot;enzyme&quot;;import Adapter from &quot;enzyme-adapter-react-16&quot;;import TodoList from &quot;../../TodoList&quot;;import store from &quot;../../../../store/createStore&quot;;Enzyme.configure(&#123; adapter: new Adapter() &#125;);beforeEach(() =&gt; &#123;  axios.success = true;  jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响&#125;);it(`    1. 用户进入页面时，请求远程测试    2. 列表应该显示远程返回的数据`, done =&gt; &#123;  const wrapper = mount(    &lt;Provider store=&#123;store&#125;&gt;      &lt;TodoList /&gt;    &lt;/Provider&gt;  );  process.nickTick(() =&gt; &#123;    wrapper.update();    const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);    expect(listItems.length).toBe(2);    done();  &#125;);&#125;);it(`    1. 用户进入页面时，等待5s    2. 列表应该显示远程返回的数据`, done =&gt; &#123;  const wrapper = mount(    &lt;Provider store=&#123;store&#125;&gt;      &lt;TodoList /&gt;    &lt;/Provider&gt;  );  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器  jest.runAllTimers();  process.nickTick(() =&gt; &#123;    wrapper.update(); // 更新 wrapper 防止取上一次的 wrapper    const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);    expect(listItems.length).toBe(2);    done();  &#125;);&#125;);it(`  1. 用户进入页面时，请求远程数据失败  2. 列表应该显示空数据，不应该挂掉`, done =&gt; &#123;  axios.success = false;  const wrapper = mount(    &lt;Provider store=&#123;store&#125;&gt;      &lt;TodoList /&gt;    &lt;/Provider&gt;  );  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器  jest.runAllTimers();  process.nickTick(() =&gt; &#123;    wrapper.update();    const listItems = findTestWrapper(wrapper, &quot;list-item&quot;);    expect(listItems.length).toBe(0);    done();  &#125;);&#125;);</code></pre><hr><h2 id="14-vue-项目的自动化测试"><a href="#14-vue-项目的自动化测试" class="headerlink" title="14. vue 项目的自动化测试"></a>14. vue 项目的自动化测试</h2><h3 id="14-1-使用传统方式对-vue-组件进行测试"><a href="#14-1-使用传统方式对-vue-组件进行测试" class="headerlink" title="14.1 使用传统方式对 vue 组件进行测试"></a>14.1 使用传统方式对 vue 组件进行测试</h3><pre><code class="jsx">// HelloWorld.test.jsimport Vue from &quot;vue&quot;;import HelloWorld from &quot;@/components/HelloWorld&quot;;describe(&quot;HelloWorld.vue&quot;, () =&gt; &#123;  it(&quot;renders props.msg when passed&quot;, () =&gt; &#123;    const root = document.createElement(&quot;div&quot;);    root.className = &quot;root&quot;;    document.body.appendChild(root);    new Vue(&#123;      render: h =&gt;        h(HelloWorld, &#123;          props: &#123;            msg: &quot;dell lee&quot;          &#125;        &#125;)    &#125;).$mount(&quot;.root&quot;);    expect(document.getElementByClassName(&quot;hello&quot;).length).toBe(1);  &#125;);&#125;);</code></pre><p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p><h3 id="14-2-使用-vue-test-utils-对-vue-组件进行测试"><a href="#14-2-使用-vue-test-utils-对-vue-组件进行测试" class="headerlink" title="14.2 使用 @vue/test-utils 对 vue 组件进行测试"></a>14.2 使用 @vue/test-utils 对 vue 组件进行测试</h3><ul><li><a href="https://vue-test-utils.vuejs.org/zh/" target="_blank" rel="noopener external nofollow noreferrer">官方文档</a></li></ul><h3 id="14-2-1-for-example"><a href="#14-2-1-for-example" class="headerlink" title="14.2.1 for example"></a>14.2.1 for example</h3><pre><code class="jsx">// HelloWorld.test.jsimport &#123; shallowMount &#125; from &quot;@vue/test-utils&quot;;import HelloWorld from &quot;@/components/HelloWorld&quot;;describe(&quot;HelloWorld.vue&quot;, () =&gt; &#123;  it(&quot;renders props.msg when passed&quot;, () =&gt; &#123;    const msg = &quot;dell lee&quot;;    const wrapper = shallowMount(HelloWorld, &#123;      propsData: &#123; msg &#125;    &#125;);    expect(wrapper.text()).toMatch(msg);  &#125;);&#125;);</code></pre><h3 id="14-2-2-快照测试"><a href="#14-2-2-快照测试" class="headerlink" title="14.2.2 快照测试"></a>14.2.2 快照测试</h3><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p><p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p><pre><code class="jsx">// HelloWorld.test.jsimport &#123; shallowMount &#125; from &quot;@vue/test-utils&quot;;import HelloWorld from &quot;@/components/HelloWorld&quot;;describe(&quot;HelloWorld.vue 组件渲染正常&quot;, () =&gt; &#123;  it(&quot;renders props.msg when passed&quot;, () =&gt; &#123;    const msg = &quot;dell lee&quot;;    const wrapper = shallowMount(HelloWorld, &#123;      propsData: &#123; msg &#125;    &#125;);    expect(wrapper).toMatchSnapshot();  &#125;);&#125;);</code></pre><hr><h2 id="15-react-项目的自动化测试"><a href="#15-react-项目的自动化测试" class="headerlink" title="15. react 项目的自动化测试"></a>15. react 项目的自动化测试</h2><h3 id="15-1-使用传统方式对-react-组件进行测试"><a href="#15-1-使用传统方式对-react-组件进行测试" class="headerlink" title="15.1 使用传统方式对 react 组件进行测试"></a>15.1 使用传统方式对 react 组件进行测试</h3><pre><code class="jsx">// App.test.jsimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import App from &quot;./App&quot;;it(&quot;render App&quot;, () =&gt; &#123;  const div = document.createElement(&quot;div&quot;);  ReactDOM.render(&lt;App /&gt;, div);  const container = div.getElementsByClassName(&quot;App&quot;);  expect(container.length).toBe(1);&#125;);</code></pre><p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p><h3 id="15-2-enzyme-的配置和使用"><a href="#15-2-enzyme-的配置和使用" class="headerlink" title="15.2 enzyme 的配置和使用"></a>15.2 enzyme 的配置和使用</h3><ul><li><a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener external nofollow noreferrer">官方文档</a></li><li><a href="https://github.com/enzymejs/enzyme" target="_blank" rel="noopener external nofollow noreferrer">github</a></li><li><a href="https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme" target="_blank" rel="noopener external nofollow noreferrer">jest-enzyme</a></li></ul><h3 id="15-2-1-for-example"><a href="#15-2-1-for-example" class="headerlink" title="15.2.1 for example"></a>15.2.1 for example</h3><pre><code class="jsx">// App.test.jsimport React from &quot;react&quot;;import Enzyme, &#123; shallow &#125; from &quot;enzyme&quot;;import Adapter from &quot;enzyme-adapter-react-16&quot;;import App from &quot;App&quot;;Enzyme.configure(&#123; adapter: new Adapter() &#125;);it(&quot;render App&quot;, () =&gt; &#123;  const wrapper = shallow(&lt;App /&gt;);  expect(wrapper.find(&#39;[data-test=&quot;App&quot;]&#39;).length).toBe(2);&#125;);</code></pre><p>使用自定义 <code>props</code> 可以降低代码耦合度</p><p><code>shallow</code> 适合单元测试，属于浅渲染； <code>mount</code> 适合集成测试，会将当前组件包括其子组件一起渲染</p><p>单元测试时更倾向于使用 <code>api</code> <code>.state()</code> ；集成测试时更倾向于使用 <code>api</code> <code>.prop()</code></p><h3 id="15-2-2-快照测试"><a href="#15-2-2-快照测试" class="headerlink" title="15.2.2 快照测试"></a>15.2.2 快照测试</h3><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p><p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p><pre><code class="jsx">// App.test.jsimport React from &quot;react&quot;;import Enzyme, &#123; shallow &#125; from &quot;enzyme&quot;;import Adapter from &quot;enzyme-adapter-react-16&quot;;import App from &quot;App&quot;;Enzyme.configure(&#123; adapter: new Adapter() &#125;);it(&quot;render App&quot;, () =&gt; &#123;  const wrapper = shallow(&lt;App /&gt;);  expect(wrapper).toMatchSnapshot();&#125;);</code></pre><hr><h2 id="16-前端自动化测试的优势"><a href="#16-前端自动化测试的优势" class="headerlink" title="16. 前端自动化测试的优势"></a>16. 前端自动化测试的优势</h2><ul><li>更好的代码组织，项目的可维护性强</li><li>更少的 <code>Bug</code> 出现概率，尤其是回归测试中的 <code>Bug</code></li><li>修改工程质量差的项目，更加安全</li><li>项目具备潜在的文档特性</li><li>扩展前端的知识面</li></ul><h2 id="17-总结重要的点"><a href="#17-总结重要的点" class="headerlink" title="17 总结重要的点"></a>17 总结重要的点</h2><ol><li><code>BDD</code> 和 <code>TDD</code></li><li>集成测试 和 单元测试</li><li>测试和业务的解耦</li><li>代码测试覆盖率并不代表一定靠谱</li><li>功能性测试 和 <code>UI</code>测试</li><li>测试越独立，隐藏的问题就越多</li></ol>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%90%8E%E7%AB%AF/Go%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%90%8E%E7%AB%AF/Go%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、go-基础语法"><a href="#一、go-基础语法" class="headerlink" title="一、go 基础语法"></a>一、go 基础语法</h2><h3 id="1-1-标识符"><a href="#1-1-标识符" class="headerlink" title="1.1 标识符"></a>1.1 标识符</h3><p>一个标识符实际上就是一个或是多个字母( <code>A~Z</code> 和 <code>a~z</code> )数字( <code>0~9</code> )、下划线 <code>_</code> 组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p><h3 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h3><table><thead><tr><th align="left"><strong><code>break</code></strong></th><th align="left"><strong><code>default</code></strong></th><th align="left"><strong><code>func</code></strong></th><th align="left"><strong><code>interface</code></strong></th><th align="left"><strong><code>select</code></strong></th></tr></thead><tbody><tr><td align="left"><strong><code>case</code></strong></td><td align="left"><strong><code>defer</code></strong></td><td align="left"><strong><code>go</code></strong></td><td align="left"><strong><code>map</code></strong></td><td align="left"><strong><code>struct</code></strong></td></tr><tr><td align="left"><strong><code>chan</code></strong></td><td align="left"><strong><code>else</code></strong></td><td align="left"><strong><code>goto</code></strong></td><td align="left"><strong><code>package</code></strong></td><td align="left"><strong><code>switch</code></strong></td></tr><tr><td align="left"><strong><code>const</code></strong></td><td align="left"><strong><code>fallthrough</code></strong></td><td align="left"><strong><code>if</code></strong></td><td align="left"><strong><code>range</code></strong></td><td align="left"><strong><code>type</code></strong></td></tr><tr><td align="left"><strong><code>continue</code></strong></td><td align="left"><strong><code>for</code></strong></td><td align="left"><strong><code>import</code></strong></td><td align="left"><strong><code>return</code></strong></td><td align="left"><strong><code>var</code></strong></td></tr></tbody></table><h3 id="1-3-预定义标识符"><a href="#1-3-预定义标识符" class="headerlink" title="1.3 预定义标识符"></a>1.3 预定义标识符</h3><table><thead><tr><th align="left"><strong><code>append</code></strong></th><th align="left"><strong><code>bool</code></strong></th><th align="left"><strong><code>byte</code></strong></th><th align="left"><strong><code>cap</code></strong></th><th align="left"><strong><code>close</code></strong></th></tr></thead><tbody><tr><td align="left"><strong><code>complex</code></strong></td><td align="left"><strong><code>complex64</code></strong></td><td align="left"><strong><code>complex128</code></strong></td><td align="left"><strong><code>uint16</code></strong></td><td align="left"><strong><code>copy</code></strong></td></tr><tr><td align="left"><strong><code>false</code></strong></td><td align="left"><strong><code>float32</code></strong></td><td align="left"><strong><code>float64</code></strong></td><td align="left"><strong><code>imag</code></strong></td><td align="left"><strong><code>int</code></strong></td></tr><tr><td align="left"><strong><code>int8</code></strong></td><td align="left"><strong><code>int16</code></strong></td><td align="left"><strong><code>uint32</code></strong></td><td align="left"><strong><code>int32</code></strong></td><td align="left"><strong><code>int64</code></strong></td></tr><tr><td align="left"><strong><code>iota</code></strong></td><td align="left"><strong><code>len</code></strong></td><td align="left"><strong><code>make</code></strong></td><td align="left"><strong><code>new</code></strong></td><td align="left"><strong><code>nil</code></strong></td></tr><tr><td align="left"><strong><code>panic</code></strong></td><td align="left"><strong><code>uint64</code></strong></td><td align="left"><strong><code>print</code></strong></td><td align="left"><strong><code>println</code></strong></td><td align="left"><strong><code>real</code></strong></td></tr><tr><td align="left"><strong><code>recover</code></strong></td><td align="left"><strong><code>string</code></strong></td><td align="left"><strong><code>true</code></strong></td><td align="left"><strong><code>uint</code></strong></td><td align="left"><strong><code>uint8</code></strong></td></tr><tr><td align="left"><strong><code>uintptr</code></strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="二、go-语言数据类型"><a href="#二、go-语言数据类型" class="headerlink" title="二、go 语言数据类型"></a>二、go 语言数据类型</h2><p><em><strong>1.</strong></em> 在 <code>Go</code> 语言中，数据类型用于声明函数和变量</p><p><em><strong>2.</strong></em> 数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，好处是可以充分利用内存</p><h3 id="2-1-布尔型"><a href="#2-1-布尔型" class="headerlink" title="2.1 布尔型"></a><strong>2.1</strong> <strong>布尔型</strong></h3><p>布尔型的值只可以是常量 <code>true</code> 或者 <code>false</code>。一个简单的例子：</p><pre><code class="go">var b bool = true</code></pre><h3 id="2-2-字符串类型"><a href="#2-2-字符串类型" class="headerlink" title="2.2 字符串类型"></a><strong>2.2</strong> <strong>字符串类型</strong></h3><h4 id="2-2-1-说明"><a href="#2-2-1-说明" class="headerlink" title="2.2.1 说明"></a><strong>2.2.1 说明</strong></h4><p>字符串就是一串固定长度的字符连接起来的字符序列。</p><p><code>Go</code> 的字符串是由单个字节连接起来的。<code>Go</code> 语言的字符串的字节使用 <code>UTF-8</code> 编码标识 <code>Unicode</code> 文本。</p><h4 id="2-2-2-常见转义符"><a href="#2-2-2-常见转义符" class="headerlink" title="2.2.2 常见转义符"></a><strong>2.2.2 常见转义符</strong></h4><table><thead><tr><th align="left">转义符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>\r</code></td><td align="left">回车符（返回行首）</td></tr><tr><td align="left"><code>\n</code></td><td align="left">换行符（直接跳到下一行的同列位置）</td></tr><tr><td align="left"><code>\t</code></td><td align="left">制表符</td></tr><tr><td align="left"><code>\&#39;</code></td><td align="left">单引号</td></tr><tr><td align="left"><code>\&quot;</code></td><td align="left">双引号</td></tr><tr><td align="left"><code>\\</code></td><td align="left">反斜杠</td></tr></tbody></table><h4 id="2-2-3-单引号"><a href="#2-2-3-单引号" class="headerlink" title="2.2.3 单引号"></a><strong>2.2.3 单引号</strong></h4><p>在 <code>go</code> 语言中表示 <code>golang</code> 中的 <code>rune(int32)</code> 类型，单引号里面是 <strong>单个字符</strong>，对应的值为该字符的 <code>ASCII</code> 值。</p><h4 id="2-2-4-双引号"><a href="#2-2-4-双引号" class="headerlink" title="2.2.4 双引号"></a><strong>2.2.4 双引号</strong></h4><p>在 <code>go</code> 语言中双引号里面可以是单个字符也可以是字符串，双引号里面可以有转义字符，如 <code>\n</code>、<code>\r</code> 等，对应 <code>go</code> 语言中的 <code>string</code> 类型。</p><h4 id="2-2-5-反引号"><a href="#2-2-5-反引号" class="headerlink" title="2.2.5 反引号"></a><strong>2.2.5 反引号</strong></h4><p>用来定义多行字符串字面量，不支持转义。</p><pre><code class="go">const str = `    first,    second,    third`fmt.Println(str)</code></pre><h4 id="2-2-6-字符"><a href="#2-2-6-字符" class="headerlink" title="2.2.6 字符"></a><strong>2.2.6 字符</strong></h4><p>字符串中的每一个元素叫做“字符”，分为以下两种：</p><ol><li><code>uint8（byte）类型</code></li></ol><p>代表 ASCII 码的一个字符</p><ol><li><code>rune（int32）类型</code></li></ol><p>用来处理中文、日文或者其它复合字符</p><pre><code class="go">var a byte = &#39;a&#39;fmt.Printf(&quot;%d %T\n&quot;, a, a) // 97 unint8var b rune = &#39;你&#39;fmt.Printf(&quot;%d %T\n&quot;, b, b) // 20320 int32</code></pre><h3 id="2-3-派生类型"><a href="#2-3-派生类型" class="headerlink" title="2.3 派生类型"></a><strong>2.3</strong> <strong>派生类型</strong></h3><h4 id="2-3-1-指针类型-Pointer"><a href="#2-3-1-指针类型-Pointer" class="headerlink" title="2.3.1 指针类型(Pointer)"></a><strong>2.3.1 指针类型(<code>Pointer</code>)</strong></h4><h4 id="2-3-2-数组类型"><a href="#2-3-2-数组类型" class="headerlink" title="2.3.2 数组类型"></a><strong>2.3.2 数组类型</strong></h4><h4 id="2-3-3-结构化类型-struct"><a href="#2-3-3-结构化类型-struct" class="headerlink" title="2.3.3 结构化类型(struct)"></a><strong>2.3.3 结构化类型(<code>struct</code>)</strong></h4><h4 id="2-3-4-Channel类型"><a href="#2-3-4-Channel类型" class="headerlink" title="2.3.4 Channel类型"></a><strong>2.3.4 <code>Channel</code>类型</strong></h4><h4 id="2-3-5-函数类型"><a href="#2-3-5-函数类型" class="headerlink" title="2.3.5 函数类型"></a><strong>2.3.5 函数类型</strong></h4><h4 id="2-3-6-切片类型"><a href="#2-3-6-切片类型" class="headerlink" title="2.3.6 切片类型"></a><strong>2.3.6 切片类型</strong></h4><h4 id="2-3-7-接口类型（interface）"><a href="#2-3-7-接口类型（interface）" class="headerlink" title="2.3.7 接口类型（interface）"></a><strong>2.3.7 接口类型（<code>interface</code>）</strong></h4><h4 id="2-3-8-Map-类型"><a href="#2-3-8-Map-类型" class="headerlink" title="2.3.8 Map 类型"></a><strong>2.3.8 <code>Map</code> 类型</strong></h4><h3 id="2-4-数字类型"><a href="#2-4-数字类型" class="headerlink" title="2.4 数字类型"></a>2.4 <strong>数字类型</strong></h3><h4 id="2-4-1-说明"><a href="#2-4-1-说明" class="headerlink" title="2.4.1 说明"></a><strong>2.4.1 说明</strong></h4><p>整型 <code>int</code> 和浮点型 <code>float32</code>、<code>float64</code>，<code>Go</code> 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</p><h4 id="2-4-2-数字类型"><a href="#2-4-2-数字类型" class="headerlink" title="2.4.2 数字类型"></a><strong>2.4.2 数字类型</strong></h4><table><thead><tr><th align="left">序号</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>uint8</code></td><td align="left">无符号 8 位整型 (0 到 255)</td></tr><tr><td align="left">2</td><td align="left"><code>uint16</code></td><td align="left">无符号 16 位整型 (0 到 65535)</td></tr><tr><td align="left">3</td><td align="left"><code>uint32</code></td><td align="left">无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td align="left">4</td><td align="left"><code>uint64</code></td><td align="left">无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td align="left">5</td><td align="left"><code>int8</code></td><td align="left">有符号 8 位整型 (-128 到 127)</td></tr><tr><td align="left">6</td><td align="left"><code>int16</code></td><td align="left">有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td align="left">7</td><td align="left"><code>int32</code></td><td align="left">有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="left">8</td><td align="left"><code>int64</code></td><td align="left">有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h4 id="2-4-3-浮点类型"><a href="#2-4-3-浮点类型" class="headerlink" title="2.4.3 浮点类型"></a><strong>2.4.3 浮点类型</strong></h4><table><thead><tr><th align="left">序号</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>float32</code></td><td align="left"><code>IEEE-754</code> 32 位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><code>float64</code></td><td align="left"><code>IEEE-754</code> 64 位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><code>complex64</code></td><td align="left"><code>32</code> 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><code>complex128</code></td><td align="left"><code>64</code> 位实数和虚数</td></tr></tbody></table><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;math&quot;)func main() &#123;    fmt.Printf(&quot;%f\n&quot;, math.Pi) // 按默认宽度和精度输出    fmt.Printf(&quot;%.2f\n&quot;, math.Pi) // 按默认宽度，2位精度输出&#125;</code></pre><h4 id="2-4-4-其它数字类型"><a href="#2-4-4-其它数字类型" class="headerlink" title="2.4.4 其它数字类型"></a><strong>2.4.4 其它数字类型</strong></h4><table><thead><tr><th align="left">序号</th><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>byte</code></td><td align="left">类似 uint8</td></tr><tr><td align="left">2</td><td align="left"><code>rune</code></td><td align="left">类似 int32</td></tr><tr><td align="left">3</td><td align="left"><code>uint</code></td><td align="left">32 或 64 位</td></tr><tr><td align="left">4</td><td align="left"><code>int</code></td><td align="left">与 uint 一样大小</td></tr><tr><td align="left">5</td><td align="left"><code>uintptr</code></td><td align="left">无符号整型，用于存放一个指针</td></tr></tbody></table><h2 id="三、go-语言变量"><a href="#三、go-语言变量" class="headerlink" title="三、go 语言变量"></a>三、go 语言变量</h2><h3 id="3-1-变量声明"><a href="#3-1-变量声明" class="headerlink" title="3.1 变量声明"></a>3.1 变量声明</h3><h4 id="3-1-1-声明变量的一般形式"><a href="#3-1-1-声明变量的一般形式" class="headerlink" title="3.1.1 声明变量的一般形式"></a><strong>3.1.1 声明变量的一般形式</strong></h4><pre><code class="go">   var a int // 整型   var b string // 字符串   var c []float32 // 32位浮点切片，浮点切片表示由多个浮点类型组成的数据结构   var d func() bool // 返回布尔类型的函数变量   var e struct &#123; // 声明一个结构体类型的变量，这个结构体拥有一个整型的 x 字段       x int   &#125;</code></pre><h4 id="3-1-2-变量声明（第一种）"><a href="#3-1-2-变量声明（第一种）" class="headerlink" title="3.1.2 变量声明（第一种）"></a><strong>3.1.2 变量声明（第一种）</strong></h4><p>指定变量类型，如果没有初始化，则变量默认为零值。</p><ul><li>数值类型(包括 <code>complex64/128</code> ) 为 <code>0</code></li><li>布尔类型为 <code>false</code></li><li>字符串为 <code>&quot;&quot;</code>(空字符串)</li><li>以下几种类型为 <code>nil</code></li></ul><pre><code class="go">var a *intvar a []intvar map[string] intvar a chan intvar a func(string) intvar a error // error 是接口</code></pre><pre><code class="go">// var v_name v_type// v_name = value// 零值就是变量没有做初始化时系统默认设置的值package mainimport &quot;fmt&quot;func main() &#123;    // 声明一个变量并初始化    var a = &quot;RUNNOB&quot;    fmt.Println(a)    // 没有初始化就为零    var b int    fmt.Println(b)    // bool 零值为 false    var c bool    fmt.Println(c)    var i1 int    var f1 float64    var b1 bool    var s1 string    fmt.Printf(&quot;%v %v %v %q\n&quot;, i1, f1, b1, s1)&#125;</code></pre><h4 id="3-1-3-变量声明（第二种）"><a href="#3-1-3-变量声明（第二种）" class="headerlink" title="3.1.3 变量声明（第二种）"></a><strong>3.1.3 变量声明（第二种）</strong></h4><p>根据值自行判定变量类型</p><pre><code class="go">// var v_name = valuepackage mainimport &quot;fmt&quot;func main() &#123;    var d = true    fmt.Println(d)&#125;</code></pre><h4 id="3-1-4-变量声明（第三种）"><a href="#3-1-4-变量声明（第三种）" class="headerlink" title="3.1.4 变量声明（第三种）"></a><strong>3.1.4 变量声明（第三种）</strong></h4><p>省略 <code>var</code>，注意 <code>:=</code> 左侧如果没有声明新的变量，就产生编译错误</p><pre><code class="go">// v_name := valuevar intVal intintVal := 1 // 这时候会产生编译错误intVal, intVal1 := 1, 2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句// 可以将 var f string = &quot;Runoob&quot; 简写为 f := &quot;Runoob&quot;package mainimport &quot;fmt&quot;func main() &#123;    f := &quot;Runoob&quot;    fmt.Println(f)&#125;</code></pre><h3 id="3-2-多变量声明"><a href="#3-2-多变量声明" class="headerlink" title="3.2 多变量声明"></a>3.2 多变量声明</h3><pre><code class="go">//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var (    vname1 v_type1    vname2 v_type2)</code></pre><pre><code class="go">package mainvar x, y intvar (  // 这种因式分解关键字的写法一般用于声明全局变量    a int    b bool)var c, d int = 1, 2var e, f = 123, &quot;hello&quot;// 这种不带声明格式的只能在函数体中出现// g, h := 123, &quot;hello&quot;func main()&#123;    g, h := 123, &quot;hello&quot;    println(x, y, a, b, c, d, e, f, g, h)&#125;</code></pre><h3 id="3-3-值类型和引用类型"><a href="#3-3-值类型和引用类型" class="headerlink" title="3.3 值类型和引用类型"></a>3.3 值类型和引用类型</h3><h4 id="3-3-1-值类型"><a href="#3-3-1-值类型" class="headerlink" title="3.3.1 值类型"></a><strong>3.3.1 值类型</strong></h4><ol><li>所有像  <code>int</code>、<code>float</code>、<code>bool</code> 和  <code>string</code> 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值</li><li>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 <code>i</code> 的值进行拷贝</li><li>你可以通过 <code>&amp;i</code> 来获取变量  <code>i</code>   的内存地址，例如：<code>0xf840000040</code>（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</li><li>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</li></ol><h4 id="3-3-2-引用类型"><a href="#3-3-2-引用类型" class="headerlink" title="3.3.2 引用类型"></a><strong>3.3.2 引用类型</strong></h4><ol><li>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</li><li>一个引用类型的变量 <code>r1</code> 存储的是 <strong><code>r1</code> 的值所在的内存地址（数字）</strong>，或 <strong>内存地址中第一个字所在的位置</strong>。这个内存地址为称之为<strong>指针</strong>，<strong>这个指针实际上也被存在另外的某一个字中</strong>。</li><li>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（<strong>内存布局是连续的</strong>），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，<strong>每个字都指示了下一个字所在的内存地址</strong>。</li><li>当使用赋值语句 <code>r2 = r1</code> 时，只有引用（地址）被复制。如果 <code>r1</code> 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，<code>r2</code> 也会受到影响。</li><li>简短形式，使用 <code>:=</code> 赋值操作符<ul><li>我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 <code>var</code> 关键字其实是显得有些多余了，因此我们可以将它们简写为 <code>a := 50</code> 或  <code>b := false</code>。<code>a</code> 和 <code>b</code> 的类型（<code>int</code> 和 <code>bool</code>）将由编译器自动推断。</li></ul></li><li>这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 <code>:=</code> 可以高效地创建一个新的变量，称之为 <strong>初始化声明</strong>。</li><li>注意事项<ul><li>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：<code>a := 20</code> 就是不被允许的，编译器会提示错误 <code>no new variables on left side of :=</code>，但是 <code>a = 20</code> 是可以的，因为这是给相同的变量赋予一个新的值。</li><li>如果你在定义变量 <code>a</code> 之前使用它，则会得到编译错误 <code>undefined: a</code>。</li><li>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 <code>a</code>：```go<br>// 尝试编译这段代码将得到错误 a declared and not used。<br>package main<br>import &quot;fmt&quot;<br>func main() {<br>var a string = &quot;abc&quot;<br>fmt.Println(&quot;hello, world&quot;)<br>}</li></ul></li></ol><pre><code>   - 此外，单纯地给 `a` 赋值也是不够的，这个值必须被使用，所以使用`fmt.Println(&quot;hello, world&quot;, a)`会移除错误。   - 但是全局变量是允许声明但不使用。 同一类型的多个变量可以声明在同一行，如：```govar a, b, c int</code></pre><ul><li>多变量可以在同一行进行赋值，如：```go<br>var a, b int<br>var c string<br>a, b, c = 5, 7, &quot;abc&quot;</li></ul><pre><code>   - 上面这行假设了变量 `a`，`b`和 `c`都已经被声明，**否则的话应该这样使用**：```goa, b, c := 5, 7, &quot;abc&quot;</code></pre><ul><li>右边的这些值以相同的顺序赋值给左边的变量，所以 <code>a</code> 的值是 <code>5</code>， <code>b</code>的值是 <code>7</code>，<code>c</code> 的值是 <code>&quot;abc&quot;</code>。[<strong>这被称为 <code>并行</code> 或 <code>同时</code> 赋值。</strong>]如果你想要交换两个变量的值，则可以简单地使用 **<code>a, b = b, a</code>**，两个变量的类型必须是相同。</li><li>空白标识符 <code>_</code> 也被用于<strong>抛弃值</strong>，如值 <code>5</code> 在：<code>_, b = 5, 7</code> 中被抛弃。<code>_</code>实际上是一个只写变量，你不能得到它的值。这样做是因为 <code>Go</code> 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</li><li>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 <code>val</code> 和错误 <code>err</code> 是通过调用 <code>Func1</code> 函数同时得到：<code>val, err = Func1(var1)</code>。</li></ul><h2 id="四、go-语言常量"><a href="#四、go-语言常量" class="headerlink" title="四、go 语言常量"></a>四、go 语言常量</h2><h3 id="4-1-const"><a href="#4-1-const" class="headerlink" title="4.1 const"></a>4.1 const</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是 <strong>布尔型</strong>、<strong>数字型</strong>（<strong>整数型</strong>、<strong>浮点型</strong> 和 <strong>复数</strong>）和 <strong>字符串型</strong>。</p><p>常量的定义格式：</p><pre><code class="go">const identifier [type] = value</code></pre><p>你可以省略类型说明符[<code>type</code>]，因为编译器可以根据变量的值来推断其类型</p><ul><li>显式类型定义：<code>const b string = &quot;abc&quot;</code></li><li>隐式类型定义：<code>const b = &quot;abc&quot;</code></li></ul><p>多个相同类型的声明可以简写为： <code>const c_name1, c_name2 = value1, value2</code></p><p>以下实例演示了常量的应用：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    const LENGTH int = 10    const WIDTH int = 5    var area int    const a, b, c = 1, false, &quot;str&quot; // 多重赋值    area = WIDTH * LENGTH    fmt.Printf(&quot;面积为：%d&quot;, area)    println()    println(a, b, c)&#125;</code></pre><p>常量还可以用作枚举：</p><pre><code class="go">const (    unknown = 0    Female = 1    Male = 2)</code></pre><p>数字 <code>0</code>、<code>1</code> 和 <code>2</code> 分别代表 <code>未知性别</code>、<code>女性</code> 和 <code>男性</code></p><p>常量可以用 <code>len()</code>、<code>cap()</code>、<code>unsafe.Sizeof()</code> 函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p><pre><code class="go">package mainimport &quot;unsafe&quot;const (    a = &quot;abc&quot;    b = len(a)    c = unsafe.Sizeof(a))func main() &#123;    println(a, b, c)&#125;</code></pre><h3 id="4-2-iota"><a href="#4-2-iota" class="headerlink" title="4.2 iota"></a>4.2 iota</h3><p><code>iota</code>, 特殊常量，可以认为是一个可以被编译器修改的常量</p><p><code>iota</code> 在 <code>const</code> 关键字出现时将被重置为 <code>0</code>(<code>const</code> 内部的第一行之前)，<code>const</code> 中每新增一行常量声明将使 <code>iota</code> 计数一次（<code>iota</code> 可理解为 <code>const</code> 语句块中的行索引）</p><p><code>iota</code> 可以被用作枚举值：</p><pre><code class="go">const (    a = iota    b = iota    c = iota)</code></pre><p>第一个 <code>iota</code> 等于 <code>0</code>，每当 <code>iota</code> 在新的一行被使用时，它的值都会自动加 <code>1</code>；所以 <code>a=0</code>，<code>b=1</code>，<code>c=2</code> 可以简写为如下形式：</p><pre><code class="go">const (    a = iota    b    c)</code></pre><h4 id="4-2-1-iota-用法"><a href="#4-2-1-iota-用法" class="headerlink" title="4.2.1 iota 用法"></a><strong>4.2.1 iota 用法</strong></h4><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    const (        a = iota // 0        b // 1        c // 2        d = &quot;ha&quot; // 独立值，iota += 1        e // &quot;ha&quot; iota += 1        f = 100 // iota += 1        g // 100 iota += 1        h = iota // 7，恢复计数        i // 8    )    fmt.Println(a, b, c, d, e, f, g, h, i)&#125;</code></pre><ul><li>再看个有趣的的 <code>iota</code> 实例：</li></ul><pre><code class="go">package mainimport &quot;fmt&quot;const (    i=1&lt;&lt;iota    j=3&lt;&lt;iota    k    l)func main() &#123;    fmt.Println(&quot;i=&quot;,i)    fmt.Println(&quot;j=&quot;,j)    fmt.Println(&quot;k=&quot;,k)    fmt.Println(&quot;l=&quot;,l)&#125;</code></pre><p><code>iota</code> 表示从 <code>0</code> 开始自动加 <code>1</code>，所以 <code>i=1&lt;&lt;0</code>, <code>j=3&lt;&lt;1</code>（<code>&lt;&lt;</code>表示左移的意思），即：<code>i=1</code>, <code>j=6</code>，这没问题，关键在 <code>k</code> 和 <code>l</code>，从输出结果看 <code>k=3&lt;&lt;2</code>，<code>l=3&lt;&lt;3</code>。</p><ul><li>简单表述：<ul><li><code>i=1</code>：左移 <code>0</code> 位,不变仍为 <code>1</code>;</li><li><code>j=3</code>：左移 <code>1</code> 位,变为二进制 <code>110</code>, 即 <code>6</code>;</li><li><code>k=3</code>：左移 <code>2</code> 位,变为二进制 <code>1100</code>, 即 <code>12</code>;</li><li><code>l=3</code>：左移 <code>3</code> 位,变为二进制 <code>11000</code>,即 <code>24</code>。</li></ul></li></ul><h2 id="五、go-语言运算符"><a href="#五、go-语言运算符" class="headerlink" title="五、go 语言运算符"></a>五、go 语言运算符</h2><p>运算符用于在程序运行时执行数学或逻辑运算</p><table><thead><tr><th align="left">序号</th><th align="left"><code>go</code>语言内置的运算符</th></tr></thead><tbody><tr><td align="left"><code>1</code></td><td align="left">算数运算符</td></tr><tr><td align="left"><code>2</code></td><td align="left">关系运算符</td></tr><tr><td align="left"><code>3</code></td><td align="left">逻辑运算符</td></tr><tr><td align="left"><code>4</code></td><td align="left">位运算符</td></tr><tr><td align="left"><code>5</code></td><td align="left">赋值运算符</td></tr><tr><td align="left"><code>6</code></td><td align="left">其它运算符</td></tr></tbody></table><h3 id="5-1-算数运算符"><a href="#5-1-算数运算符" class="headerlink" title="5.1 算数运算符"></a>5.1 算数运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">相加</td></tr><tr><td align="left"><code>-</code></td><td align="left">相减</td></tr><tr><td align="left"><code>*</code></td><td align="left">相乘</td></tr><tr><td align="left"><code>/</code></td><td align="left">相除</td></tr><tr><td align="left"><code>%</code></td><td align="left">求余</td></tr><tr><td align="left"><code>++</code></td><td align="left">自增</td></tr><tr><td align="left"><code>--</code></td><td align="left">自减</td></tr></tbody></table><h3 id="5-2-关系运算符"><a href="#5-2-关系运算符" class="headerlink" title="5.2 关系运算符"></a>5.2 关系运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>==</code></td><td align="left">检查两个值是否相等，如果相等返回 <code>True</code> 否则返回 <code>False</code>。</td></tr><tr><td align="left"><code>!=</code></td><td align="left">检查两个值是否不相等，如果不相等返回 <code>True</code> 否则返回 <code>False</code>。</td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">检查左边值是否大于右边值，如果是返回 <code>True</code> 否则返回 <code>False</code>。</td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">检查左边值是否小于右边值，如果是返回 <code>True</code>否则返回 <code>False</code>。</td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left">检查左边值是否大于等于右边值，如果是返回 <code>True</code> 否则返回 <code>False</code>。</td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left">检查左边值是否小于等于右边值，如果是返回 <code>True</code> 否则返回 <code>False</code>。</td></tr></tbody></table><h3 id="5-3-逻辑运算符"><a href="#5-3-逻辑运算符" class="headerlink" title="5.3 逻辑运算符"></a>5.3 逻辑运算符</h3><p>| 运算符 | 描述                                                                              |<br>| :----- | :-------------------------------------------------------------------------------- | --- | --------------------------------------------------------------------------------- |<br>| <code>&amp;&amp;</code>   | 逻辑 <code>AND</code> 运算符。 如果两边的操作数都是 <code>True</code>，则条件 <code>True</code>，否则为 <code>False</code>。  |<br>| <code>     |                                                                                   |</code>   | 逻辑 <code>OR</code> 运算符。 如果两边的操作数有一个 <code>True</code>，则条件 <code>True</code>，否则为 <code>False</code>。 |<br>| <code>!</code>    | 逻辑 <code>NOT</code> 运算符。 如果条件为 <code>True</code>，则逻辑 <code>NOT</code> 条件 <code>False</code>，否则为 <code>True</code>。 |</p><h3 id="5-4-位运算符"><a href="#5-4-位运算符" class="headerlink" title="5.4 位运算符"></a>5.4 位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。下表列出了位运算符 <code>&amp;</code>, <code>|</code>, 和 <code>^</code> 的计算：</p><table><thead><tr><th align="left"><code>p</code></th><th align="left"><code>q</code></th><th align="left"><code>p &amp; q</code></th><th align="left">`p</th><th align="left">q`</th><th><code>p ^ q</code></th></tr></thead><tbody><tr><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td></td></tr><tr><td align="left"><code>0</code></td><td align="left"><code>1</code></td><td align="left"><code>0</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td></td></tr><tr><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td align="left"><code>0</code></td><td></td></tr><tr><td align="left"><code>1</code></td><td align="left"><code>0</code></td><td align="left"><code>0</code></td><td align="left"><code>1</code></td><td align="left"><code>1</code></td><td></td></tr></tbody></table><p>假定 <code>A = 60</code>; <code>B = 13</code>; 其二进制数转换为：</p><pre><code class="go">A = 0011 1100B = 0000 1101-----------------A &amp; B = 0000 1100A | B = 0011 1101A ^ B = 0011 0001</code></pre><p><code>Go</code> 语言支持的位运算符如下表所示。假定 <code>A 为 60</code>，<code>B 为 13</code>：</p><p>| 运算符 | 描述                                                                                                                                                                    |<br>| :----- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | --------------------------------------------------------- |<br>| <code>&amp;</code>    | 按位与运算符<code>&quot;&amp;&quot;</code>是双目运算符。 其功能是参与运算的两数各对应的二进位相与。                                                                                              |<br>| <code>     |</code>                                                                                                                                                                       | 按位或运算符<code>&quot; | &quot;</code>是双目运算符。 其功能是参与运算的两数各对应的二进位相或 |<br>| <code>^</code>    | 按位异或运算符<code>&quot;^&quot;</code>是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为 1。                                                        |<br>| <code>&lt;&lt;</code>   | 左移运算符<code>&quot;&lt;&lt;&quot;</code>是双目运算符。左移<code>n</code>位就是乘以<code>2</code>的<code>n</code>次方。 其功能把<code>&quot;&lt;&lt;&quot;</code>左边的运算数的各二进位全部左移若干位，由<code>&quot;&lt;&lt;&quot;</code>右边的数指定移动的位数，高位丢弃，低位补<code>0</code>。 |<br>| <code>&gt;&gt;</code>   | 右移运算符<code>&quot;&gt;&gt;&quot;</code>是双目运算符。右移<code>n</code>位就是除以<code>2</code>的<code>n</code>次方。 其功能是把<code>&quot;&gt;&gt;&quot;</code>左边的运算数的各二进位全部右移若干位，<code>&quot;&gt;&gt;&quot;</code>右边的数指定移动的位数。                      |</p><h3 id="5-5-赋值运算符"><a href="#5-5-赋值运算符" class="headerlink" title="5.5 赋值运算符"></a>5.5 赋值运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>=</code></td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left"><code>C = A + B</code> 将 <code>A + B</code> 表达式结果赋值给 <code>C</code></td></tr><tr><td align="left"><code>+=</code></td><td align="left">相加后再赋值</td><td align="left"><code>C += A</code> 等于 <code>C = C + A</code></td></tr><tr><td align="left"><code>-=</code></td><td align="left">相减后再赋值</td><td align="left"><code>C -= A</code> 等于<code>C = C - A</code></td></tr><tr><td align="left"><code>*=</code></td><td align="left">相乘后再赋值</td><td align="left"><code>C *= A</code> 等于 <code>C = C * A</code></td></tr><tr><td align="left"><code>/=</code></td><td align="left">相除后再赋值</td><td align="left"><code>C /= A</code> 等于 <code>C = C / A</code></td></tr><tr><td align="left"><code>%=</code></td><td align="left">求余后再赋值</td><td align="left"><code>C %= A</code> 等于 <code>C = C % A</code></td></tr><tr><td align="left"><code>&lt;&lt;=</code></td><td align="left">左移后赋值</td><td align="left"><code>C &lt;&lt;= 2</code> 等于 <code>C = C &lt;&lt; 2</code></td></tr><tr><td align="left"><code>&gt;&gt;=</code></td><td align="left">右移后赋值</td><td align="left"><code>C &gt;&gt;= 2</code> 等于 <code>C = C &gt;&gt; 2</code></td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left">按位与后赋值</td><td align="left"><code>C &amp;= 2</code> 等于 <code>C = C &amp; 2</code></td></tr><tr><td align="left"><code>^=</code></td><td align="left">按位异或后赋值</td><td align="left"><code>C ^= 2</code> 等于 <code>C = C ^ 2</code></td></tr><tr><td align="left"><code>|=</code></td><td align="left">按位或后赋值</td><td align="left"><code>C |= 2</code> 等于 <code>C = C | 2</code></td></tr></tbody></table><h3 id="5-6-其它运算符"><a href="#5-6-其它运算符" class="headerlink" title="5.6 其它运算符"></a>5.6 其它运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>&amp;</code></td><td align="left">返回变量存储地址</td><td align="left"><code>&amp;a</code>; 将给出变量的实际地址。</td></tr><tr><td align="left"><code>*</code></td><td align="left">指针变量。</td><td align="left"><code>*a</code>; 是一个指针变量</td></tr></tbody></table><h3 id="5-7-运算符优先级"><a href="#5-7-运算符优先级" class="headerlink" title="5.7 运算符优先级"></a>5.7 运算符优先级</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><p>| 优先级 | 运算符             |<br>| :----- | :----------------- | --- | --- |<br>| <code>5</code>    | <code>* / % &lt;&lt; &gt;&gt; &amp; &amp;^</code> |<br>| <code>4</code>    | <code>+ -               | ^</code>  |<br>| <code>3</code>    | <code>== != &lt; &lt;= &gt; &gt;=</code>  |<br>| <code>2</code>    | <code>&amp;&amp;</code>               |<br>| <code>1</code>    | <code>                 |     |</code>   |</p><p>可以通过使用括号来临时提升某个表达式的整体运算优先级。</p><h2 id="六、go-语言条件语句"><a href="#六、go-语言条件语句" class="headerlink" title="六、go 语言条件语句"></a>六、go 语言条件语句</h2><p>以下为常用条件语句：</p><table><thead><tr><th align="left">语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>if</code> 语句</td><td align="left"><code>if</code> 语句 由一个布尔表达式后紧跟一个或多个语句组成。</td></tr><tr><td align="left"><code>if...else</code> 语句</td><td align="left"><code>if</code> 语句 后可以使用可选的 <code>else</code> 语句, <code>else</code> 语句中的表达式在布尔表达式为 <code>false</code> 时执行。</td></tr><tr><td align="left"><code>if</code> 嵌套语句</td><td align="left">你可以在 <code>if</code> 或 <code>else if</code> 语句中嵌入一个或多个 <code>if</code> 或 <code>else if</code> 语句。</td></tr><tr><td align="left"><code>switch</code> 语句</td><td align="left"><code>switch</code> 语句用于基于不同条件执行不同动作。</td></tr><tr><td align="left"><code>select</code> 语句</td><td align="left"><code>select</code> 语句类似于 <code>switch</code> 语句，但是 <code>select</code> 会随机执行一个可运行的 <code>case</code>。如果没有 <code>case</code> 可运行，它将阻塞，直到有 <code>case</code> 可运行。</td></tr></tbody></table><h3 id="6-1-select-语句"><a href="#6-1-select-语句" class="headerlink" title="6.1 select 语句"></a>6.1 <code>select</code> 语句</h3><ul><li>语法<ul><li>每个 <code>case</code> 都必须是一个 <strong>通信</strong></li><li>所有 <code>channel</code> 表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其它被忽略</li><li>如果有多个 <code>case</code> 都可以运行，<code>select</code> 会随机公平地选出一个执行。其他不会执行。<br>否则： - 如果有 <code>default</code> 子句，则执行该语句 - 如果没有 <code>default</code> 子句，<code>select</code> 将阻塞，直到某个通信可以运行；<code>Go</code> 不会重新对 <code>channel</code> 或值进行求值</li></ul></li></ul><pre><code class="go">select &#123;    case communication clause :        statement(s);    case communication clause :        statement(s);    default :        statement(s);&#125;</code></pre><p>例子 1：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var c1, c2, c3 chan int    var i1, i2 int    select &#123;    case i1 = &lt;-c1: // 从 Channel c1 中接收数据，并将值赋给 i1        fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)    case c2 &lt;- i2: // 发送 i2 到 Channel c2 中        fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)    case i3, ok := (&lt;-c3): // same as: i3, ok := &lt;-c3 ; 从 Channel c3 中接收数据，并将值赋给 i3, ok        if ok &#123;            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)        &#125; else &#123;            fmt.Printf(&quot;c3 is closed\n&quot;)        &#125;    default:        fmt.Printf(&quot;no communication\n&quot;)    &#125;&#125;</code></pre><p>例子 2：</p><pre><code class="go">package mainimport &quot;fmt&quot;func fibonacci(c, quit chan int) &#123;    x, y := 0, 1    for &#123;        select &#123;            case c &lt;- x:                x, y = y, x + y            case &lt;-quit:                fmt.Println(&quot;quit&quot;)                return        &#125;    &#125;&#125;func main() &#123;    c := make(chan int)    quit := make(chan int)    go func() &#123;        for i := 0; i &lt; 10; i++ &#123;            fmt.Println(&lt;-c)        &#125;        quit &lt;- 0    &#125;()    fibonacci(c, quit)&#125;</code></pre><h2 id="七、go-语言循环语句"><a href="#七、go-语言循环语句" class="headerlink" title="七、go 语言循环语句"></a>七、go 语言循环语句</h2><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>for</code> 循环</td><td align="left">重复执行语句块</td></tr><tr><td align="left">循环嵌套</td><td align="left">在 <code>for</code> 循环中嵌套一个或多个 <code>for</code> 循环</td></tr></tbody></table><h3 id="7-1-for-循环"><a href="#7-1-for-循环" class="headerlink" title="7.1 for 循环"></a>7.1 <code>for</code> 循环</h3><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var b int = 15    var a int    numbers := [6]int&#123;1, 2, 3, 5&#125;    // for 循环    for a := 0; a &lt; 10; a++ &#123;        fmt.Printf(&quot;a 的值为：%d\n&quot;, a)    &#125;    for a &lt; b &#123;        a++        fmt.Printf(&quot;a 的值为：%d\n&quot;, a)    &#125;    for i, x := range numbers &#123;        fmt.Printf(&quot;第 %d 位 x 的值 = %d\n&quot;, i, x)    &#125;&#125;</code></pre><h4 id="7-1-1-类似-c-语言的-for-循环"><a href="#7-1-1-类似-c-语言的-for-循环" class="headerlink" title="7.1.1 类似 c 语言的 for 循环"></a>7.1.1 类似 <code>c</code> 语言的 <code>for</code> 循环</h4><pre><code class="go">for init; condition; post &#123; &#125;</code></pre><h4 id="7-1-2-类似-c-语言的-while"><a href="#7-1-2-类似-c-语言的-while" class="headerlink" title="7.1.2 类似 c 语言的 while"></a>7.1.2 类似 <code>c</code> 语言的 <code>while</code></h4><pre><code class="go">for condition &#123; &#125;</code></pre><h4 id="7-1-3-类似-c-语言的-for"><a href="#7-1-3-类似-c-语言的-for" class="headerlink" title="7.1.3 类似 c 语言的 for(;;)"></a>7.1.3 类似 <code>c</code> 语言的 <code>for(;;)</code></h4><pre><code class="go">for &#123; &#125;</code></pre><h4 id="7-1-4-range-格式"><a href="#7-1-4-range-格式" class="headerlink" title="7.1.4 range 格式"></a>7.1.4 <code>range</code> 格式</h4><p><code>for</code> 循环的 <code>range</code> 格式可以对 <code>slice</code>、<code>map</code>、数组、字符串等进行迭代操作</p><pre><code class="go">for key, value := range oldMap &#123;    newMap[key] = value&#125;</code></pre><h4 id="7-1-5-循环嵌套"><a href="#7-1-5-循环嵌套" class="headerlink" title="7.1.5 循环嵌套"></a>7.1.5 循环嵌套</h4><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var i, j int    for i = 2; i &lt; 100; i++ &#123;        for j = 2; j &lt;= (i / j); j++ &#123;            if i%j == 0 &#123;                break            &#125;        &#125;        if j &gt; (i / j) &#123;            fmt.Printf(&quot;%d 是素数\n&quot;, i)        &#125;    &#125;&#125;</code></pre><h3 id="7-2-循环控制语句"><a href="#7-2-循环控制语句" class="headerlink" title="7.2 循环控制语句"></a>7.2 循环控制语句</h3><p>循环控制语句可以控制循环体内语句的执行过程。</p><p><code>GO</code> 语言支持以下几种循环控制语句：</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>break</code> 语句</td><td align="left">经常用于中断当前 <code>for</code> 循环或跳出 <code>switch</code> 语句</td></tr><tr><td align="left"><code>continue</code> 语句</td><td align="left">跳过当前循环的剩余语句，然后继续进行下一轮循环。</td></tr><tr><td align="left"><code>goto</code> 语句</td><td align="left">将控制转移到被标记的语句。</td></tr></tbody></table><h4 id="7-2-1-break-语句"><a href="#7-2-1-break-语句" class="headerlink" title="7.2.1 break 语句"></a>7.2.1 <code>break</code> 语句</h4><pre><code class="go">// 变量大于 15 时跳出循环package mainimport &quot;fmt&quot;func main() &#123;    var a int = 10    for a &lt; 20 &#123;        fmt.Printf(&quot;a 的值为：%d \n&quot;, a);        a++        if a &gt; 15 &#123;            break;        &#125;    &#125;&#125;</code></pre><h4 id="7-2-2-continue-语句"><a href="#7-2-2-continue-语句" class="headerlink" title="7.2.2 continue 语句"></a>7.2.2 <code>continue</code> 语句</h4><pre><code class="go">// 在变量 a 等于 15 的时候跳过本次循环执行下一次循环：package mainimport &quot;fmt&quot;func main() &#123;    var a int = 10    for a &lt; 20 &#123;        if a == 15 &#123;            a = a + 1            continue        &#125;        fmt.Printf(&quot;a 的值为 ：%d\n&quot;, a)        a++    &#125;&#125;</code></pre><h4 id="7-2-3-goto-语句"><a href="#7-2-3-goto-语句" class="headerlink" title="7.2.3 goto 语句"></a>7.2.3 <code>goto</code> 语句</h4><p><code>Go</code> 语言的 <code>goto</code> 语句可以无条件地转移到过程中指定的行。</p><p><code>goto</code> 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用 <code>goto</code> 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><ul><li>语法格式</li></ul><pre><code class="go">goto label;...label: statement</code></pre><pre><code class="go">// 在变量 a 等于 15 的时候跳过本次循环并回到循环的开始语句 Loop 处package mainimport &quot;fmt&quot;func main() &#123;    var a int = 10    // 循环    LOOP: for a &lt; 20 &#123;        if a == 15 &#123;            // 跳过迭代            a = a + 1            goto LOOP        &#125;        fmt.Printf(&quot;a 的值为 ： %d\n&quot;, a)        a++    &#125;&#125;</code></pre><h3 id="7-3-无限循环"><a href="#7-3-无限循环" class="headerlink" title="7.3 无限循环"></a>7.3 无限循环</h3><p>如果循环中条件语句永远不为 <code>false</code> 则会进行无限循环，我们可以通过 <code>for</code> 循环语句中只设置一个条件表达式来执行无限循环：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    for true &#123;        fmt.Printf(&quot;这是无限循环。\n&quot;)    &#125;&#125;</code></pre><h2 id="八、go-语言函数"><a href="#八、go-语言函数" class="headerlink" title="八、go 语言函数"></a>八、go 语言函数</h2><h3 id="8-1-函数定义"><a href="#8-1-函数定义" class="headerlink" title="8.1 函数定义"></a>8.1 函数定义</h3><pre><code class="go">// Go 语言函数定义格式如下：func function_name( [parameter list] ) [return_types] &#123; 函数体 &#125;</code></pre><blockquote><p>函数定义解析：</p><ul><li><code>func</code>：函数由 <code>func</code> 开始声明</li><li><code>function_name</code>：函数名称、函数名和参数列表一起构成了函数签名</li><li><code>parameter list</code>：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数</li><li><code>return_types</code>：返回类型，函数返回一列值。<code>return_types</code> 是该列值的数据类型。有些功能不需要返回值，这种情况下 <code>return_types</code> 不是必须的</li><li>函数体：函数定义的代码集合</li></ul></blockquote><pre><code class="go">func max(num1, num2 int) int &#123;    var result int    if num1 &gt; num2 &#123;        result = num1    &#125; else &#123;        result = num2    &#125;    return result&#125;</code></pre><h3 id="8-2-函数调用"><a href="#8-2-函数调用" class="headerlink" title="8.2 函数调用"></a>8.2 函数调用</h3><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var a int = 100    var b int = 200    var ret int    ret = max(a, b)    fmt.Printf(&quot;最大值是：%d\n&quot;, ret)&#125;func max(num1, num2 int) int &#123;    var result int    if num1 &gt; num2 &#123;        result = num1    &#125; else &#123;        result = num2    &#125;&#125;</code></pre><h3 id="8-3-函数返回多个值"><a href="#8-3-函数返回多个值" class="headerlink" title="8.3 函数返回多个值"></a>8.3 函数返回多个值</h3><pre><code class="go">package mainimport &quot;fmt&quot;func swap(x, y string) (string, string) &#123;    return y, x&#125;func main() &#123;    a, b := swap(&quot;Google&quot;, &quot;Runoob&quot;)    fmt.Println(a, b)&#125;</code></pre><h3 id="8-4-函数参数"><a href="#8-4-函数参数" class="headerlink" title="8.4 函数参数"></a>8.4 函数参数</h3><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p>调用函数，可以通过两种方式来传递参数：</p><table><thead><tr><th align="left">传递类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">值传递</td><td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td align="left">引用传递</td><td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><p>默认情况下，<code>Go</code> 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><h3 id="8-5-函数用法"><a href="#8-5-函数用法" class="headerlink" title="8.5 函数用法"></a>8.5 函数用法</h3><table><thead><tr><th align="left">函数用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">函数作为另外一个函数的实参</td><td align="left">函数定义后可作为另外一个函数的实参数传入</td></tr><tr><td align="left">闭包</td><td align="left">闭包是匿名函数，可在动态编程中使用</td></tr><tr><td align="left">方法</td><td align="left">方法就是一个包含了接受者的函数</td></tr></tbody></table><h4 id="8-5-1-函数作为另外一个函数的实参"><a href="#8-5-1-函数作为另外一个函数的实参" class="headerlink" title="8.5.1 函数作为另外一个函数的实参"></a>8.5.1 函数作为另外一个函数的实参</h4><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;math&quot;)func main() &#123;    // 声明函数变量    getSquareBoot := func(x float64) float64 &#123;        return math.Sqrt(x)    &#125;    // 使用函数    fmt.Println(getSquareBoot(9))&#125;</code></pre><pre><code class="go">package mainimport &quot;fmt&quot;// 声明一个函数类型type cb func(int) intfunc main() &#123;    testCallBack(1, callBack)    testCallBack(2, func(x int) int &#123;        fmt.Printf(&quot;我是回调，x：%d\n&quot;, x)        return x    &#125;)&#125;func testCallBack(x int, f cb) &#123;    f(x)&#125;func callBack(x int) int &#123;    fmt.Printf(&quot;我是回调，x：%d\n&quot;, x)    return x&#125;</code></pre><h4 id="8-5-2-闭包"><a href="#8-5-2-闭包" class="headerlink" title="8.5.2 闭包"></a>8.5.2 闭包</h4><p><code>Go</code> 语言支持匿名函数，可作为闭包。匿名函数是一个&quot;内联&quot;语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p><p>以下实例中，我们创建了函数 <code>getSequence()</code> ，返回另外一个函数。该函数的目的是在闭包中递增 <code>i</code> 变量，代码如下：</p><pre><code class="go">package mainimport &quot;fmt&quot;func getSequence() func() int &#123;    i := 0    return func() int &#123;        i += 1        return i    &#125;&#125;func main() &#123;    nextNumber := getSequence()    fmt.Println(nextNumber())    fmt.Println(nextNumber())    fmt.Println(nextNumber())    nextNumber1 := getSequence()    fmt.Println(nextNumber1())    fmt.Println(nextNumber1())&#125;</code></pre><p>带参数的闭包函数调用</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    add_func := add(1, 2)    fmt.Println(add_func())    fmt.Println(add_func())    fmt.Println(add_func())&#125;func add(x1, x2 int) func() (int, int) &#123;    i := 0    return func() (int, int) &#123;        i++        return i, x1 + x2    &#125;&#125;</code></pre><p>闭包带参数</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    add_func := add(1, 2)    fmt.Println(add_func(1, 1))    fmt.Println(add_func(0, 0))    fmt.Println(add_func(2, 2))&#125;// 闭包使用方法func add(x1, x2 int) func(x3 int, x4 int) (int, int, int) &#123;    i := 0    return func(x3 int, x4 int) (int, int, int) &#123;        i++        return i, x1 + x2, x3 + x4    &#125;&#125;</code></pre><h4 id="8-5-3-方法"><a href="#8-5-3-方法" class="headerlink" title="8.5.3 方法"></a>8.5.3 方法</h4><p><code>Go</code> 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是 <strong>命名类型</strong> 或者 <strong>结构体类型的一个值</strong> 或者是 <strong>一个指针</strong>。所有给定类型的方法属于该类型的方法集。语法格式如下：</p><pre><code class="go">func (variable_name variable_data_type) function_name() [return_type]&#123;   /* 函数体*/&#125;</code></pre><p>下面定义一个结构体类型和该类型的一个方法：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)// 定义结构体type Circle struct &#123;    radius float64&#125;func main() &#123;    var c1 Circle    c1.radius = 10.00    fmt.Println(&quot;圆的面积 = &quot;, c1.getArea())&#125;// 该 method 属于 Circle 类型对象的方法func (c Circle) getArea() float64 &#123;    // c.radius 即为 Circle 类型对象中的属性    return 3.14 * c.radius * c.radius&#125;</code></pre><h2 id="九、go-语言数组"><a href="#九、go-语言数组" class="headerlink" title="九、go 语言数组"></a>九、go 语言数组</h2><p><code>Go</code> 语言提供了数组类型的数据结构。</p><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p><p>相对于去声明 number0, number1, ..., number99 的变量，使用数组形式 numbers[0], numbers[1] ..., numbers[99] 更加方便且易于扩展。</p><p>数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/06/goarray.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=650&status=done&style=none&width=650" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2015/06/goarray.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&originHeight=170&originWidth=650&status=done&style=none&width=650" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="9-1-声明数组"><a href="#9-1-声明数组" class="headerlink" title="9.1 声明数组"></a>9.1 声明数组</h3><blockquote><p><code>Go</code> 语言数组声明需要指定元素类型及元素个数，<strong>语法格式</strong> 如下：</p><pre><code class="go">var variable_name [SIZE] variable_type</code></pre></blockquote><pre><code>&gt; 以上为一维数组的定义方式。例如以下定义了数组 `balance` 长度为 `10` 类型为 `float32：`&gt; ```govar balance [10] float32</code></pre><h3 id="9-2-初始化数组"><a href="#9-2-初始化数组" class="headerlink" title="9.2 初始化数组"></a>9.2 初始化数组</h3><blockquote><p>以下演示了数组初始化：</p><pre><code class="go">var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></pre></blockquote><pre><code>&gt; 初始化数组中 `&#123;&#125;` 中的元素个数**不能大于** `[]` 中的数字。&gt; 如果忽略 `[]` 中的数字不设置数组大小，`Go` 语言会根据元素的个数来设置数组的大小：&gt; ```govar balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></pre><blockquote><p>该实例与上面的实例是一样的，虽然没有设置数组的大小。</p><pre><code class="go">balance[4] = 50.0</code></pre></blockquote><pre><code>&gt; 以上实例读取了第五个元素。数组元素可以通过索引（位置）来读取（或者修改），索引从 `0` 开始，第一个元素索引为 `0`，第二个索引为 `1`，以此类推。&gt; ![](https://www.runoob.com/wp-content/uploads/2015/06/array_presentation.jpg#align=left&amp;display=inline&amp;height=67&amp;margin=%5Bobject%20Object%5D&amp;originHeight=67&amp;originWidth=465&amp;status=done&amp;style=none&amp;width=465)### 9.3 访问数组元素&gt; 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如：&gt; ```govar salary float32 = balance[9]</code></pre><blockquote><p>以上实例读取了数组 <code>balance</code> 第 <code>10</code> 个元素的值。<br>以下演示了数组完整操作（声明、赋值、访问）的实例：</p></blockquote><pre><code class="go"> package main import &quot;fmt&quot; func main() &#123;    var n [10] int // n 是一个长度为 10 的数组    var i, j int    // 为数组 n 初始化元素    for i = 0; i &lt; 10; i++ &#123;        n[i] = i + 100 // 设置元素为 i + 100    &#125;    // 输出每个数组元素的值    for j = 0; j &lt; 10; j++ &#123;        fmt.Printf(&quot;Element[%d] = %d\n&quot;, j, n[j])    &#125;&#125;</code></pre><h3 id="9-4-更多内容"><a href="#9-4-更多内容" class="headerlink" title="9.4 更多内容"></a>9.4 更多内容</h3><p>数组对 <code>Go</code> 语言来说是非常重要的，以下我们将介绍数组更多的内容：</p><p>| 内容 | 描述 |<br>| :=== | :=== |<br>| 多维数组 | <code>Go</code> 语言支持多维数组，最简单的多维数组是二维数组 |<br>| 向函数传递数组 | 你可以向函数传递数组参数 |</p><h4 id="9-4-1-Go-语言多维数组"><a href="#9-4-1-Go-语言多维数组" class="headerlink" title="9.4.1 Go 语言多维数组"></a>9.4.1 <code>Go</code> 语言多维数组</h4><p><code>Go</code> 语言支持多维数组，以下为常用的多维数组声明方式：</p><blockquote><pre><code class="go">var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</code></pre></blockquote><pre><code>以下实例声明了三维的整型数组：&gt; ```govar threedim [5][10][4]int</code></pre><h5 id="1-二维数组"><a href="#1-二维数组" class="headerlink" title="(1) 二维数组"></a>(1) 二维数组</h5><p>二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：</p><blockquote><pre><code class="go">var arrayName [ x ][ y ] variable_type</code></pre></blockquote><pre><code>`variable_type` 为 `Go` 语言的数据类型，`arrayName` 为数组名，二维数组可认为是一个表格，`x` 为行，`y` 为列，下图演示了一个二维数组 `a` 为三行四列：二维数组中的元素可通过 `a[ i ][ j ]` 来访问。![](https://www.runoob.com/wp-content/uploads/2015/06/two_dimensional_arrays.jpg#align=left&amp;display=inline&amp;height=125&amp;margin=%5Bobject%20Object%5D&amp;originHeight=125&amp;originWidth=427&amp;status=done&amp;style=none&amp;width=427)##### (2) 初始化二维数组多维数组可通过大括号来初始值。以下实例为一个 `3` 行 `4` 列的二维数组：```goa = [3][4]int&#123; &#123;0, 1, 2, 3&#125; ,   /*  第一行索引为 0 */ &#123;4, 5, 6, 7&#125; ,   /*  第二行索引为 1 */ &#123;8, 9, 10, 11&#125;,   /* 第三行索引为 2 */&#125;</code></pre><blockquote><p>注意：以上代码中倒数第二行的 <code>&#125;</code> 必须要有逗号，因为最后一行的 <code>&#125;</code> 不能单独一行，也可以写成这样：</p></blockquote><pre><code class="go">a = [3][4]int&#123; &#123;0, 1, 2, 3&#125; ,   /*  第一行索引为 0 */ &#123;4, 5, 6, 7&#125; ,   /*  第二行索引为 1 */ &#123;8, 9, 10, 11&#125;&#125;   /* 第三行索引为 2 */</code></pre><h5 id="3-访问二维数组"><a href="#3-访问二维数组" class="headerlink" title="(3) 访问二维数组"></a>(3) 访问二维数组</h5><p>二维数组通过指定坐标来访问。如数组中的行索引与列索引，例如：</p><pre><code class="go">val := a[2][3]或var value int = a[2][3]</code></pre><p>以上实例访问了二维数组 <code>val</code> 第三行的第四个元素。</p><p>二维数组可以使用循环嵌套来输出元素：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    // 数组 5行2列    var a = [5][2]int&#123;&#123;0,0&#125;, &#123;1,2&#125;, &#123;2,4&#125;, &#123;3,6&#125;, &#123;4,8&#125;&#125;    var i, j int    // 输出数组元素    for i = 0; i &lt; 5; i++ &#123;        for j = 0; j &lt; 2; j++ &#123;            fmt.Printf(&quot;a[%d]&#123;%d] = %d\n&quot;, i, j, a[i][j])        &#125;    &#125;&#125;</code></pre><h4 id="9-4-2-Go-语言向函数传递数组"><a href="#9-4-2-Go-语言向函数传递数组" class="headerlink" title="9.4.2 Go 语言向函数传递数组"></a>9.4.2 <code>Go</code> 语言向函数传递数组</h4><p>如果你想向函数传递数组参数，你需要在函数定义时，声明形参为数组，我们可以通过以下两种方式来声明：</p><ul><li>方式一</li></ul><p>形参设定数组大小：</p><pre><code class="go">void myFunction(param [10]int) &#123;    ...&#125;</code></pre><ul><li>方式二</li></ul><p>形参未设定数组大小：</p><pre><code class="go">void myFunction(param []int) &#123;    ...&#125;</code></pre><ul><li>实例</li></ul><p>让我们看下以下实例，实例中函数接收整型数组参数，另一个参数指定了数组元素的个数，并返回平均值：</p><pre><code class="go">func getAverage(arr []int, size int) float32 &#123;    var i int    var avg, sum float32    for i = 0; i &lt; size; i++ &#123;        sum += arr[i]    &#125;    avg = sum / size    return avg&#125;</code></pre><p>接下来我们来调用这个函数：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    // 数组长度为 5    var balance = [5]int&#123;1000, 2, 3, 17, 50&#125;    var avg float32    // 数组作为参数传递给函数    avg = getAverage(banance, 5)    // 输出的平均值    fmt.Printf(&quot;平均值为：%f&quot;, avg) //  214.399994&#125;func getAverage(arr [5]int, size int) float32 &#123;    var i, sum int    var avg float32    for i = 0; i &lt; size; i++ &#123;        sum += arr[i]    &#125;    avg = float32(sum) / float32(size)    return avg&#125;</code></pre><p>以上实例中我们使用的形参并未设定数组大小。</p><p>浮点数计算输出有一定的偏差，你也可以转整型来设置精度。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)func main() &#123;    a := 1.69    b := 1.7    c := a * b    fmt.Println(c)&#125;</code></pre><p>设置固定精度：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)func main() &#123;    a := 1690    b := 1700    c := a * b    fmt.Println(c)    fmt.Println(float64(c) / 1000000)&#125;</code></pre><h2 id="十、Go-语言指针"><a href="#十、Go-语言指针" class="headerlink" title="十、Go 语言指针"></a>十、Go 语言指针</h2><p><code>Go</code> 语言中指针是很容易学习的，<code>Go</code> 语言中使用指针可以更简单的执行一些任务。</p><p>接下来让我们来一步步学习 <code>Go</code> 语言指针。</p><p>我们都知道，<strong>变量</strong> 是一种使用方便的占位符，用于引用计算机内存地址。</p><p><code>Go</code> 语言的取地址符是 <code>&amp;</code>，放到一个变量前使用就会返回相应变量的内存地址。</p><p>以下实例演示了变量在内存中地址：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var a int = 10    fmt.Printf(&quot;变量的地址：%x\n&quot;, &amp;a) // 20818a220&#125;</code></pre><h3 id="10-1-什么是指针"><a href="#10-1-什么是指针" class="headerlink" title="10.1 什么是指针"></a>10.1 什么是指针</h3><p>一个指针变量指向了一个值的内存地址</p><p>类似于变量和常量，在使用指针前你需要声明指针。指针的声明格式如下：</p><pre><code class="go">var var_name *var_type</code></pre><p><code>var-type</code> 为指针类型，<code>var_name</code> 为指针变量名，<code>*</code> 号用于指定变量是作为一个指针。以下是有效的指针声明：</p><pre><code class="go">var ip *int // 指向整型var fp *float32 // 指向浮点型</code></pre><h3 id="10-2-如何使用指针"><a href="#10-2-如何使用指针" class="headerlink" title="10.2 如何使用指针"></a>10.2 如何使用指针</h3><p>指针使用流程：</p><ul><li>定义指针变量</li><li>为指针变量赋值</li><li>访问指针变量中指向地址的值</li></ul><p>在指针类型前面加上 <code>*</code> 号（前缀）来获取指针所指向的内容。</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var a int = 20    var ip *int    ip = &amp;a    fmt.Printf(&quot;a 的变量地址为：%x\n&quot;, &amp;a)    fmt.Printf(&quot;ip 变量储存的地址为：%x\n&quot;, ip)    fmt.Printf(&quot;*ip 变量的值：%d\n&quot;, *ip)&#125;</code></pre><h3 id="10-3-Go-空指针"><a href="#10-3-Go-空指针" class="headerlink" title="10.3 Go 空指针"></a>10.3 Go 空指针</h3><p>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code></p><p><code>nil</code> 指针也称为空指针</p><p><code>nil</code> 在概念上与其它语言的 <code>null</code>、<code>None</code>、<code>nil</code>、<code>NULL</code> 一样，都指代零值或空值</p><p>一个指针变量通常缩写为 <code>ptr</code></p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var ptr *int    fmt.Printf(&quot;ptr 的值为：%x\n&quot;, ptr)&#125;</code></pre><p>空指针判断</p><pre><code class="go">if(ptr != nil) // ptr 不是空指针if(ptr == nil) // ptr 是空指针</code></pre><h3 id="10-4-Go-指针更多内容"><a href="#10-4-Go-指针更多内容" class="headerlink" title="10.4 Go 指针更多内容"></a>10.4 Go 指针更多内容</h3><table><thead><tr><th align="left">内容</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>Go</code> 指针数组</td><td align="left">你可以定义一个指针数组来存储地址</td></tr><tr><td align="left"><code>Go</code> 指向指针的指针</td><td align="left"><code>Go</code> 支持指向指针的指针</td></tr><tr><td align="left"><code>Go</code> 向函数传递指针参数</td><td align="left">通过引用或地址传参，在函数调用时可以改变其值</td></tr></tbody></table><h4 id="10-4-1-Go-指针数组"><a href="#10-4-1-Go-指针数组" class="headerlink" title="10.4.1 Go 指针数组"></a>10.4.1 Go 指针数组</h4><p>在我们了解指针数组前，先看个实例，定义了长度为 <code>3</code> 的整型数组：</p><pre><code class="go">package mainimport &quot;fmt&quot;const MAX int = 3func main() &#123;    a := []int&#123;10, 100, 200&#125;    var i int    for i = 0; i &lt; MAX; i++ &#123;        fmt.Printf(&quot;a[%d] = %d\n&quot;, i, a[i])    &#125;&#125;</code></pre><p>有一种情况，我们可能需要保存数组，这样我们就需要使用到指针。</p><p>以下声明了整型指针数组：</p><pre><code class="go">var ptr [MAX]*int</code></pre><p><code>ptr</code> 为整型指针数组。因此每个元素都指向了一个值。以下实例的三个整数将存储在指针数组中：</p><pre><code class="go">package mainimport &quot;fmt&quot;const MAX int = 3func main() &#123;    a := []int&#123;10, 100, 200&#125;    var i int    var ptr [MAX]*int    for i = 0; i &lt; MAX; i++ &#123;        ptr[i] = &amp;a[i] // 整数地址赋值给指针数组    &#125;    for i = 0; i &lt; MAX; i++ &#123;        fmt.Printf(&quot;a[%d] = %d\n&quot;, i, *ptr[i])    &#125;&#125;// a[0] = 10// a[1] = 100// a[2] = 200</code></pre><p>注意：创建指针数组的时候，不适合用 <code>range</code> 循环。</p><h4 id="10-4-2-Go-指向指针的指针"><a href="#10-4-2-Go-指向指针的指针" class="headerlink" title="10.4.2 Go 指向指针的指针"></a>10.4.2 Go 指向指针的指针</h4><p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p><p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/06/pointer_to_pointer.jpg#align=left&display=inline&height=65&margin=%5Bobject%20Object%5D&originHeight=65&originWidth=414&status=done&style=none&width=414" class="lazyload" data-srcset="https://www.runoob.com/wp-content/uploads/2015/06/pointer_to_pointer.jpg#align=left&display=inline&height=65&margin=%5Bobject%20Object%5D&originHeight=65&originWidth=414&status=done&style=none&width=414" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>指向指针的指针变量声明格式如下：</p><pre><code class="go">var ptr **int</code></pre><p>以上指向指针的指针变量为整型。</p><p>访问指向指针的指针变量值需要使用两个 <code>*</code> 号，如下所示：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var a int    var ptr *int    var pptr **int    a = 3000    // 指向 ptr 地址    ptr = &amp;a    // 指向指针 ptr 地址    pptr = &amp;ptr    // 获取 pptr 的值    fmt.Printf(&quot;变量 a = %d\n&quot;, a)    fmt.Printf(&quot;指针变量 *ptr = %d\n&quot;, *ptr)    fmt.Printf(&quot;指向指针的变量 **pptr = %d\n&quot;, **pptr)&#125;// 变量 a = 3000// 指针变量 *ptr = 3000// 指向指针的指针变量 **pptr = 3000</code></pre><p>多次指向的指针即在相应的指针前增加 <code>*</code></p><h4 id="10-4-3-Go-向函数传递指针参数"><a href="#10-4-3-Go-向函数传递指针参数" class="headerlink" title="10.4.3 Go 向函数传递指针参数"></a>10.4.3 Go 向函数传递指针参数</h4><p><code>Go</code> 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。</p><p>以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var a int = 100    var b int = 200    fmt.Printf(&quot;交换前a的值：%d\n&quot;, a)    fmt.Printf(&quot;交换前b的值：%d\n&quot;, b)    // 调用函数用于交换值    // &amp;a 指向 a 变量的地址    // &amp;b 指向 b 变量的地址    swap(&amp;a, &amp;b)    fmt.Printf(&quot;交换后a的值：%d\n&quot;, a)    fmt.Printf(&quot;交换后b的值：%d\n&quot;, b)&#125;func swap(x *int, y *int) &#123;    var temp int    temp = *x // 保存 x 地址的值    *x = *y // 将 y 赋值给 x    *y = temp // 将 temp 赋值给 y    // 简洁写法 *x, *y = *y, *x&#125;// 交换前 a 的值 : 100// 交换前 b 的值 : 200// 交换后 a 的值 : 200// 交换后 b 的值 : 100</code></pre><h2 id="十一、Go-语言结构体"><a href="#十一、Go-语言结构体" class="headerlink" title="十一、Go 语言结构体"></a>十一、Go 语言结构体</h2><p><code>Go</code> 语言中数组可以存储同一类型的数据，但在结构体中我们可以为 <strong>不同项定义不同的数据类型</strong>。</p><p>结构体是由一系列 <strong>具有相同类型</strong> 或 <strong>不同类型的数据</strong> 构成的数据集合。</p><p>结构体表示一项记录，比如保存图书馆的书籍记录，每本书有以下属性：</p><ul><li><code>Title</code> ：标题</li><li><code>Author</code> ： 作者</li><li><code>Subject</code>：学科</li><li><code>ID</code>：书籍 <code>ID</code></li></ul><h3 id="11-1-定义结构体"><a href="#11-1-定义结构体" class="headerlink" title="11.1 定义结构体"></a>11.1 定义结构体</h3><p>结构体定义需要使用 <code>type</code> 和 <code>struct</code> 语句。<code>struct</code> 语句定义一个新的数据类型，结构体中有一个或多个成员。<code>type</code> 语句设定了结构体的名称。结构体的格式如下：</p><pre><code class="go">type struct_variable_type struct &#123;    member definition    member definition    ...    member definition&#125;</code></pre><p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p><pre><code class="go">variable_name := structure_variable_type &#123;value1, value2, value3, ..., valuen&#125;或variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</code></pre><pre><code class="go">package mainimport &quot;fmt&quot;type Books struct &#123;    title   string    author  string    subject string    book_id int&#125;func main() &#123;    // 创建一个新的结构体    fmt.Println(Books&#123;&quot;Go 语言&quot;, &quot;www.google.com&quot;, &quot;Go 语言介绍&quot;, 1234567&#125;)    // 也可以使用 key =&gt; value 格式    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.google.com&quot;, subject: &quot;Go 语言介绍&quot;, book_id: 1234567&#125;)    // 忽略的字段为 0 或 空    fmt.Println(Books&#123;title: &quot;Go 语言&quot;, author: &quot;www.google.com&quot;&#125;)&#125;// &#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;// &#123;Go 语言 www.runoob.com Go 语言教程 6495407&#125;// &#123;Go 语言 www.runoob.com  0&#125;</code></pre><h3 id="11-2-访问结构体成员"><a href="#11-2-访问结构体成员" class="headerlink" title="11.2 访问结构体成员"></a>11.2 访问结构体成员</h3><p>如果要访问结构体成员，需要使用点号 <code>.</code> 操作符，格式为：</p><pre><code class="go">结构体.成员名</code></pre><p>结构体类型变量使用 <code>struct</code> 关键字定义，实例如下：</p><pre><code class="go">package mainimport &quot;fmt&quot;type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;   var Book1 Books        /* 声明 Book1 为 Books 类型 */   var Book2 Books        /* 声明 Book2 为 Books 类型 */   /* book 1 描述 */   Book1.title = &quot;Go 语言&quot;   Book1.author = &quot;www.google.com&quot;   Book1.subject = &quot;Go 语言介绍&quot;   Book1.book_id = 6495407   /* book 2 描述 */   Book2.title = &quot;Python 教程&quot;   Book2.author = &quot;www.google.com&quot;   Book2.subject = &quot;Python 语言介绍&quot;   Book2.book_id = 6495700   /* 打印 Book1 信息 */   fmt.Printf( &quot;Book 1 title : %s\n&quot;, Book1.title)   fmt.Printf( &quot;Book 1 author : %s\n&quot;, Book1.author)   fmt.Printf( &quot;Book 1 subject : %s\n&quot;, Book1.subject)   fmt.Printf( &quot;Book 1 book_id : %d\n&quot;, Book1.book_id)   /* 打印 Book2 信息 */   fmt.Printf( &quot;Book 2 title : %s\n&quot;, Book2.title)   fmt.Printf( &quot;Book 2 author : %s\n&quot;, Book2.author)   fmt.Printf( &quot;Book 2 subject : %s\n&quot;, Book2.subject)   fmt.Printf( &quot;Book 2 book_id : %d\n&quot;, Book2.book_id)&#125;// Book 1 title : Go 语言// Book 1 author : www.google.com// Book 1 subject : Go 语言说明// Book 1 book_id : 6495407// Book 2 title : Python 教程// Book 2 author : www.google.com// Book 2 subject : Python 语言说明// Book 2 book_id : 6495700</code></pre><h3 id="11-3-结构体作为函数参数"><a href="#11-3-结构体作为函数参数" class="headerlink" title="11.3 结构体作为函数参数"></a>11.3 结构体作为函数参数</h3><p>你可以像其他数据类型一样将结构体类型作为参数传递给函数。并以以上实例的方式访问结构体变量：</p><pre><code class="go">package mainimport &quot;fmt&quot;type Books struct &#123;    title string    author string    subject string    book_id int&#125;func main() &#123;    var Book1 Books // 声明 Book1 为 Books 类型    var Book2 Books // 声明 Book2 为 Books 类型    // book1描述    Book1.title = &quot;Go 语言&quot;    Book1.author = &quot;www.google.com&quot;    Book1.subject = &quot;Go 语言介绍&quot;    Book1.book_id = 6495407    /* book 2 描述 */    Book2.title = &quot;Python 教程&quot;    Book2.author = &quot;www.google.com&quot;    Book2.subject = &quot;Python 语言介绍&quot;    Book2.book_id = 6495700    printBook(Book1)    printBook(Book2)&#125;func printBook(book Books) &#123;    fmt.Printf( &quot;Book title : %s\n&quot;, book.title)    fmt.Printf( &quot;Book author : %s\n&quot;, book.author)    fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject)    fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id)&#125;// Book title : Go 语言// Book author : www.google.com// Book subject : Go 语言说明// Book book_id : 6495407// Book title : Python 教程// Book author : www.google.com// Book subject : Python 语言说明// Book book_id : 6495700</code></pre><h3 id="11-4-结构体指针"><a href="#11-4-结构体指针" class="headerlink" title="11.4 结构体指针"></a>11.4 结构体指针</h3><p>你可以定义指向结构体的指针类似于其他指针变量，格式如下：</p><pre><code class="go">var struct_pointer *Books</code></pre><p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p><pre><code class="go">struct_pointer = &amp;Book1</code></pre><p>使用结构体指针访问结构体成员，使用 <code>&quot;.&quot;</code> 操作符：</p><pre><code class="go">struct_pointer.title</code></pre><p>接下来让我们使用结构体指针重写以上实例，代码如下：</p><pre><code class="go">package mainimport &quot;fmt&quot;type Books struct &#123;    title string    author string    subject string    book_id int&#125;func main() &#123;    var Book1 Books // 声明 Book1 为 Books 类型    var Book2 Books // 声明 Book2 为 Books 类型    // book1描述    Book1.title = &quot;Go 语言&quot;    Book1.author = &quot;www.google.com&quot;    Book1.subject = &quot;Go 语言介绍&quot;    Book1.book_id = 6495407    /* book 2 描述 */    Book2.title = &quot;Python 教程&quot;    Book2.author = &quot;www.google.com&quot;    Book2.subject = &quot;Python 语言介绍&quot;    Book2.book_id = 6495700    printBook(&amp;Book1)    printBook(&amp;Book2)&#125;func printBook(book *Books) &#123;    fmt.Printf( &quot;Book title : %s\n&quot;, book.title)    fmt.Printf( &quot;Book author : %s\n&quot;, book.author)    fmt.Printf( &quot;Book subject : %s\n&quot;, book.subject)    fmt.Printf( &quot;Book book_id : %d\n&quot;, book.book_id)&#125;// Book title : Go 语言// Book author : www.google.com// Book subject : Go 语言说明// Book book_id : 6495407// Book title : Python 教程// Book author : www.google.com// Book subject : Python 语言说明// Book book_id : 6495700</code></pre><p>例子：</p><pre><code class="go">package mainimport &quot;fmt&quot;type Books struct &#123;    title string    author string    subject string    book_id int&#125;func changeBook(book Books) &#123;    book.title = &quot;book1_change&quot;&#125;func main() &#123;    var book1 Books    book1.title = &quot;book1&quot;    book1.author = &quot;zuozhe&quot;    book1.book_id = 1    changeBook(book1)    fmt.Println(book1)&#125;// &#123;book1 zuozhe 1&#125;</code></pre><p>如果想在函数里面改变结构体数据内容，需要传入指针：</p><pre><code class="go">package mainimport &quot;fmt&quot;type Books struct &#123;    title string    author string    subject string    book_id int&#125;func changeBook(book *Books) &#123;    book.title = &quot;book1_change&quot;&#125;func main() &#123;    var book1 Books    book1.title = &quot;book1&quot;    book1.author = &quot;zuozhe&quot;    book1.book_id = 1    changeBook(&amp;book1)    fmt.Println(book1)&#125;// &#123;book1_change zuozhe  1&#125;</code></pre><h3 id="11-5-quot-类-quot-的创建"><a href="#11-5-quot-类-quot-的创建" class="headerlink" title="11.5 &quot;类&quot; 的创建"></a>11.5 &quot;类&quot; 的创建</h3><p><code>struct</code> 类似于 <code>java</code> 中的类，可以在 <code>struct</code> 中定义成员变量。</p><blockquote><p>要访问成员变量，可以有两种方式：</p><ul><li><ol><li> 通过 <code>struct 成员.变量</code> 变量来访问</li></ol></li><li><ol start="2"><li> 通过 <code>struct 指针.成员</code> 变量来访问</li></ol></li></ul></blockquote><p>不需要通过 <code>getter</code>, <code>setter</code> 来设置访问权限。</p><pre><code class="go">type Rect struct &#123; // 定义矩形类    x, y float64 // 类型只包含属性，并没有方法    width, height float64&#125;func (r *Rect) Area() float64 &#123; // 为 Rect 类型绑定 Area 的方法，*Rect 为指针引用可以修改传入参数的值    return r.width * r.height // 方法归于类型，不归属于具体的对象，声明该类型的对象即可调用该类型的方法&#125;</code></pre><h2 id="十二、Go-语言切片（slice）-动态数组"><a href="#十二、Go-语言切片（slice）-动态数组" class="headerlink" title="十二、Go 语言切片（slice）- 动态数组"></a>十二、Go 语言切片（slice）- 动态数组</h2><p><code>Go</code> 语言切片是对数组的抽象。</p><p><code>Go</code> 数组的长度不可改变，在特定场景中这样的集合就不太适用，<code>Go</code> 中提供了一种灵活，功能强悍的内置类型切片(<code>&quot;动态数组&quot;</code>),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><h3 id="12-1-定义切片"><a href="#12-1-定义切片" class="headerlink" title="12.1 定义切片"></a>12.1 定义切片</h3><p>你可以声明一个 <strong><code>未指定大小</code></strong> 的数组来定义切片：</p><pre><code class="go">var identifier []type</code></pre><p>切片不需要说明长度。</p><p>或使用 <strong><code>make()函数</code></strong> 来创建切片:</p><pre><code class="go">var slice1 []type = make([]type, len)也可以简写为：slice1 := make([]type, len)</code></pre><p>也可以指定容量，其中 <code>capacity</code> 为可选参数。</p><pre><code class="go">make([]T, length, capacity)</code></pre><p>这里 <code>len</code> 是 <strong><code>数组的长度</code></strong> 并且也是 **<code>切片的初始长度</code>**。</p><h3 id="12-2-切片初始化"><a href="#12-2-切片初始化" class="headerlink" title="12.2 切片初始化"></a>12.2 切片初始化</h3><p>直接初始化切片，<code>[]</code> 表示是切片类型，<code>&#123;1,2,3&#125;</code> 初始化值依次是 <code>1,2,3</code> .其 <code>cap=len=3</code></p><pre><code class="go">s := []int&#123;1, 2, 3&#125;</code></pre><p>初始化切片 <code>s</code>,是数组 <code>arr</code> 的引用</p><pre><code class="go">s := arr[:]</code></pre><p>将 <code>arr</code> 中从下标 <code>startIndex</code> 到 <code>endIndex - 1</code> 下的元素创建为一个新的切片</p><pre><code class="go">s := arr[startIndex:endIndex]</code></pre><p>默认 <code>endIndex</code> 时将表示一直到 <code>arr</code> 的最后一个元素</p><pre><code class="go">s := arr[startIndex:]</code></pre><p>默认 <code>startIndex</code> 时将表示表示从 <code>arr</code> 的第一个元素开始</p><pre><code class="go">s1 := arr[:endIndex]</code></pre><p>通过切片 <code>s</code> 初始化切片 <code>s1</code></p><pre><code class="go">s1 := s[startIndex:endIndex]</code></pre><p>通过内置函数 <code>make()</code> 初始化切片 <code>s</code>, <code>[]int</code> 标识为其元素类型为 <code>int</code> 的切片</p><pre><code class="go">s := make([]int, len, cap)</code></pre><h3 id="12-3-len-和-cap-函数"><a href="#12-3-len-和-cap-函数" class="headerlink" title="12.3 len() 和 cap() 函数"></a>12.3 <code>len()</code> 和 <code>cap()</code> 函数</h3><p>切片是可索引的，并且可以由 <code>len()</code> 方法获取长度。</p><p>切片提供了计算容量的方法 <code>cap()</code> 可以 **<code>测量切片最长可以达到多少</code>**。</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var numbers = make([]int, 3, 5)    printSlice(numbers)&#125;func printSlice(x []int) &#123;    fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;, len(x), cap(x), x)&#125;// len=3 cap=5 slice=[0 0 0]</code></pre><h3 id="12-4-nil-空切片"><a href="#12-4-nil-空切片" class="headerlink" title="12.4 nil 空切片"></a>12.4 <code>nil</code> 空切片</h3><p>一个切片在未初始化之前默认为 <code>nil</code>，长度为 <code>0</code>，实例如下：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var numbers []int    printSlice(numbers)    if(numbers == nil) &#123;        fmt.Printf(&quot;切片是空的&quot;)    &#125;&#125;func printSlice(x []int) &#123;    fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;, len(x), cap(x), x)&#125;// len=0 cap=0 slice=[]// 切片是空的</code></pre><h3 id="12-5-切片截取"><a href="#12-5-切片截取" class="headerlink" title="12.5 切片截取"></a>12.5 切片截取</h3><p>可以通过设置下限及上限来设置截取切片 <code>[lower-bound:upper-bound]</code>，实例如下：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    // 创建切片    numbers := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8&#125;    printSlice(numbers)    // 打印原始切片    fmt.Println(&quot;numbers == &quot;, numbers)    // 打印子切片从索引 1(包含) 到索引4(不包含)    fmt.Println(&quot;numbers[1:4] == &quot;, numbers[1:4])    // 默认下限为 0    fmt.Println(&quot;numbers[:3] == &quot;, numbers[:3])    // 默认上限为 len(s)    fmt.Println(&quot;numbers[4:] == &quot;, numbers[4:])    numbers1 := make([] int, 0, 5)    printSlice(numbers1)    // 打印子切片从索引 0(包含) 到索引 2(不包含)    numbers2 := numbers[:2]    printSlice(numbers2)    // 打印子切片从索引 2(包含) 到索引 5(不包含)    numbers3 := numbers[2:5]    printSlice(numbers3)&#125;func printSlice(x []int) &#123;    fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;, len(x), cap(x), x)&#125;// len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]// numbers == [0 1 2 3 4 5 6 7 8]// numbers[1:4] == [1 2 3]// numbers[:3] == [0 1 2]// numbers[4:] == [4 5 6 7 8]// len=0 cap=5 slice=[]// len=2 cap=9 slice=[0 1]// len=3 cap=7 slice=[2 3 4]</code></pre><h3 id="12-6-append-和-copy-函数"><a href="#12-6-append-和-copy-函数" class="headerlink" title="12.6 append() 和 copy() 函数"></a>12.6 <code>append()</code> 和 <code>copy()</code> 函数</h3><p>如果想增加切片的容量，我们必须 <strong><code>创建一个新的更大的切片</code></strong> 并把 **<code>原分片的内容都拷贝过来</code>**。</p><p>下面的代码描述了从拷贝切片的 <code>copy 方法</code> 和 <code>向切片追加新元素的 append 方法</code>。</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var numbers []int    printSlice(numbers)    // 允许追加空切片    numbers = append(numbers, 0)    printSlice(numbers)    // 向切片添加一个元素    numbers = append(numbers, 1)    printSlice(numbers)    // 同时添加多个元素    numbers = append(numbers, 2, 3, 4)    printSlice(numbers)    // 创建切片 numbers1 是之前切片的两倍容量    numbers1 := make([] int, len(numbers), (cap(numbers)) * 2)    // 拷贝 numbers 的内容到 numbers1    copy(numbers1, numbers)    printSlice(numbers1)&#125;func printSlice(x []int)&#123;   fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;, len(x), cap(x), x)&#125;// len=0 cap=0 slice=[]// len=1 cap=1 slice=[0]// len=2 cap=2 slice=[0 1]// len=5 cap=6 slice=[0 1 2 3 4]// len=5 cap=12 slice=[0 1 2 3 4]</code></pre><h2 id="十三、Go-语言范围-range"><a href="#十三、Go-语言范围-range" class="headerlink" title="十三、Go 语言范围 (range)"></a>十三、Go 语言范围 (<code>range</code>)</h2><p><code>Go</code> 语言中 <code>range</code> 关键字用于 <code>for</code> 循环中 <em><code>迭代数组(array)</code></em> 、_<code>切片(slice)</code><em>、</em><code>通道(channel)</code>_ 或 <em><code>集合(map)</code></em> 的元素。在 <em><code>数组</code></em> 和 <em><code>切片</code></em> 中它 _<code>返回元素的索引和索引对应的值</code>_，在 <em><code>集合</code></em> 中返回 <em><code>key-value</code></em> 对。</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    // 这是我们使用 range 去求一个 slice 的和。使用数组跟这个很类似    nums := []int&#123;2, 3, 4&#125;    sum := 0    for _, num := range nums &#123;        sum += num    &#125;    fmt.Println(&quot;sum: &quot;, sum)    // 在数组上使用 range 将传入 index 和 值 两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。    for i, num := range nums &#123;        if num == 3 &#123;            fmt.Println(&quot;index: &quot;, i)        &#125;    &#125;    // range 也可以用在 map 的键值对上    kvs := map[string] string&#123;&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;&#125;    for k, v := range kvs &#123;        fmt.Printf(&quot;%s -&gt; %s\n&quot;, k, v)    &#125;    // range 也可以用来枚举 Unicode 字符串。第一个参数是字符的索引，第二个值是字符(Unicode的值)本身    for i, c::= range &quot;go&quot; &#123;        fmt.Println(i, c)    &#125;&#125;// sum: 9// index: 1// a -&gt; apple// b -&gt; banana// 0 103// 1 111</code></pre><h2 id="十四、Go-语言-Map-集合"><a href="#十四、Go-语言-Map-集合" class="headerlink" title="十四、Go 语言 Map(集合)"></a>十四、Go 语言 Map(集合)</h2><p><code>Map</code> 是一种 <strong><em>无序的键值对的集合</em></strong> 。<code>Map</code> 最重要的一点是通过 <code>key</code> 来快速检索数据，<code>key</code> 类似于索引，指向数据的值。</p><p><code>Map</code> 是一种集合，所以我们可以像 <em><code>迭代数组</code></em> 和 <em><code>切片</code></em> 那样迭代它。不过，<code>Map</code> 是无序的，我们无法决定它的返回顺序，这是因为 <code>Map</code> 是使用 <code>hash</code> 表来实现的。</p><h3 id="14-1-定义-Map"><a href="#14-1-定义-Map" class="headerlink" title="14.1 定义 Map"></a>14.1 定义 <code>Map</code></h3><p>可以使用内建函数 <code>make</code> 也可以使用 <code>map</code> 关键字来定义 <code>Map</code>:</p><pre><code class="go">// 声明变量，默认 map 是 nilvar map_variable map[key_data_type] value_data_type// 使用 make 函数map_variable := make(map[key_data_type] value_data_type)</code></pre><p>如果不初始化 <code>map</code>，那么就会创建一个 <code>nil map</code>。<code>nil map</code> 不能用来存放键值对</p><p>下面实例演示了创建和使用 <code>map</code>:</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var countryCapticalMap map[string] string    countryCapticalMap = make(map[string] string)    // map 插入 key-value 时，各个国家对应的首都    countryCapticalMap[&quot;France&quot;] = &quot;巴黎&quot;    countryCapticalMap[&quot;Italy&quot;] = &quot;罗马&quot;    countryCapticalMap[&quot;Japan&quot;] = &quot;日本&quot;    countryCapticalMap[&quot;India&quot;] = &quot;新德里&quot;    // 使用键输出 Map 值    for country := range countryCapticalMap &#123;        fmt.Println(country, &quot;首都是&quot;, countryCapticalMap[country])    &#125;    // 查看元素在集合中是否存在    captical, ok := countryCapticalMap[&quot;American&quot;]    fmt.Println(captical, ok)    if(ok) &#123;        fmt.Println(&quot;American的首都是&quot;, captical)    &#125; else &#123;        fmt.Println(&quot;American的首都不存在&quot;)    &#125;&#125;// France 首都是 巴黎// Italy 首都是 罗马// Japan 首都是 东京// India  首都是 新德里// American 的首都不存在</code></pre><h3 id="14-2-delete-函数"><a href="#14-2-delete-函数" class="headerlink" title="14.2 delete() 函数"></a>14.2 <code>delete()</code> 函数</h3><p><code>delete()</code> 函数用于删除集合的元素，参数为 <code>map</code> 和其对应的 <code>key</code>。</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    // 创建 map    countryCapitalMap := map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;    fmt.Println(&quot;原始 Map&quot;)    // 打印 Map    for country := range countryCapticalMap &#123;        fmt.Println(country, &quot;首都是&quot;, countryCapticalMap[country])    &#125;    // 删除元素    delete(countryCapticalMap, &quot;France&quot;)    fmt.Println(&quot;法国条目被删除&quot;)    fmt.Println(&quot;删除元素后 Map&quot;)    // 打印 Map    for country := range countryCapticalMap &#123;        fmt.Println(country, &quot;首都是&quot;, countryCapticalMap[country])    &#125;&#125;// 原始 Map// India 首都是 New delhi// France 首都是 Paris// Italy 首都是 Rome// Japan 首都是 Tokyo// 法国条目被删除// 删除元素后 Map// Italy 首都是 Rome// Japan 首都是 Tokyo// India 首都是 New delhi</code></pre><h3 id="14-3-基于-go-实现简单的-HashMap"><a href="#14-3-基于-go-实现简单的-HashMap" class="headerlink" title="14.3 基于 go 实现简单的 HashMap"></a>14.3 基于 <code>go</code> 实现简单的 <code>HashMap</code></h3><p>暂未做 <code>key</code> 值的校验</p><pre><code class="go">package mainimport &quot;fmt&quot;type HashMap struct &#123;    key      string    value    string    hashCode int    next     *HashMap&#125;var table [16](*HashMap)func initTable() &#123;    for i := range table &#123;        table[i] = &amp;HashMap&#123;&quot;&quot;, &quot;&quot;, i, nil&#125;    &#125;&#125;func getInstance() [16](*HashMap) &#123;    if table[0] == nil &#123;        initTable()    &#125;    return table&#125;func getHashCode(k string) int &#123;    if len(k) == 0 &#123;        return 0    &#125;    var hashCode int = 0    var lastIndex int = len(k) - 1    for i := range k &#123;        if i == lastIndex &#123;            hashCode += int(k[i])            break        &#125;        hashCode += (hashCode + int(k[i])) * 31    &#125;    return hashCode&#125;func IndexTable(hashCode int) int &#123;    return hashCode % 16&#125;func indexNode(hashCode int) int &#123;    return hashCode &gt;&gt; 4&#125;func put(k string, v string) string &#123;    var hashCode = getHashCode(k)    var thisNode = HashMap&#123;k, v, hashCode, nil&#125;    var tableIndex = IndexTable(hashCode)    var nodeIndex = indexNode(hashCode)    var headPtr [16](*HashMap) = getInstance()    var headNode = headPtr[tableIndex]    if (*headNode).key == &quot;&quot; &#123;        *headNode = thisNode        return &quot;&quot;    &#125;    var lastNode *HashMap = headNode    var nextNode *HashMap = (*headNode).next    for nextNode != nil &amp;&amp; (indexNode((*nextNode).hashCode) &lt; nodeIndex) &#123;        lastNode = nextNode        nextNode = (*nextNode).next    &#125;    if (*lastNode).hashCode == thisNode.hashCode &#123;        var oldValue string = lastNode.value        lastNode.value = thisNode.value        return oldValue    &#125;    if lastNode.hashCode &lt; thisNode.hashCode &#123;        lastNode.next = &amp;thisNode    &#125;    if nextNode != nil &#123;        thisNode.next = nextNode    &#125;    return &quot;&quot;&#125;func get(k string) string &#123;    var hashCode = getHashCode(k)    var tableIndex = IndexTable(hashCode)    var headPtr [16](*HashMap) = getInstance()    var node *HashMap = headPtr[tableIndex]    if (*node).key == k &#123;        return (*node).value    &#125;    for (*node).next != nil &#123;        if k == (*node).key &#123;            return (*node).value        &#125;        node = (*node).next    &#125;    return &quot;&quot;&#125;// for examplefunc main() &#123;    getInstance()    put(&quot;a&quot;, &quot;a_put&quot;)    put(&quot;b&quot;, &quot;b_put&quot;)    fmt.Println(get(&quot;a&quot;))    fmt.Println(get(&quot;b&quot;))    put(&quot;p&quot;, &quot;p_put&quot;)    fmt.Println(get(&quot;p&quot;))&#125;// a_put// b_put// p_put</code></pre><h2 id="十五、Go-语言递归函数"><a href="#十五、Go-语言递归函数" class="headerlink" title="十五、Go 语言递归函数"></a>十五、Go 语言递归函数</h2><p>递归，就是在运行的过程中调用自己。</p><p>语法格式如下：</p><pre><code class="go">func recursion() &#123;   recursion() /* 函数调用自身 */&#125;func main() &#123;   recursion()&#125;</code></pre><p><code>Go</code> 语言支持递归。但我们在使用递归时，开发者需要 **<code>设置退出条件</code>**，否则递归 **<code>将陷入无限循环中</code>**。</p><p>递归函数对于解决数学上的问题是非常有用的，就像 _<code>计算阶乘</code>_，生成 <em><code>斐波那契数列</code></em> 等。</p><h3 id="15-1-阶乘"><a href="#15-1-阶乘" class="headerlink" title="15.1 阶乘"></a>15.1 阶乘</h3><pre><code class="go">package mainimport &quot;fmt&quot;func Factorial(n uint64)(result uint64) &#123;    if n &gt; 0 &#123;        result = n * Factorial(n - 1)        return result    &#125;    return 1&#125;func main() &#123;    var i int = 15    fmt.Printf(&quot;%d 的阶乘是 %d\n&quot;, i, Factorial(uint64(i)))&#125;// 15 的阶乘是 1307674368000</code></pre><h3 id="15-2-斐波那契数列"><a href="#15-2-斐波那契数列" class="headerlink" title="15.2 斐波那契数列"></a>15.2 斐波那契数列</h3><pre><code class="go">package mainimport &quot;fmt&quot;func fibonacci(n int) int &#123;    if n &lt; 2 &#123;        return n    &#125;    return fibonacci(n - 2) + fibonacci(n - 1)&#125;func main() &#123;    var i int    for i = 0; i &lt; 10; i++ &#123;        fmt.Printf(&quot;%d\t&quot;, fibonacci(i))    &#125;&#125;// 0    1    1    2    3    5    8    13    21    34</code></pre><h2 id="十六、Go-语言类型转换"><a href="#十六、Go-语言类型转换" class="headerlink" title="十六、Go 语言类型转换"></a>十六、Go 语言类型转换</h2><p>类型转换用于将一种数据类型的变量转换为另外一种类型的变量。<code>Go</code> 语言类型转换基本格式如下：</p><pre><code class="go">// type_name 为类型，expression 为表达式。type_name(expression)</code></pre><p>以下实例中将整型转化为浮点型，并计算结果，将结果赋值给浮点型变量：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    var sum int = 17    var count int = 5    var mean float32    mean = float32(num) / float32(count)    fmt.Printf(&quot;mean 的值为: %f\n&quot;,mean)&#125;// mean 的值为: 3.400000</code></pre><h2 id="十七、Go-语言接口"><a href="#十七、Go-语言接口" class="headerlink" title="十七、Go 语言接口"></a>十七、Go 语言接口</h2><p><code>Go</code> 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><pre><code class="go">// 定义接口type interface_name interface &#123;    method_name1 [return_type]    method_name2 [return_type]    method_name3 [return_type]    ...    method_namen [return_type]&#125;// 结构体type struct_name struct &#123;&#125;// 实现接口方法func (struct_name_variable struct_name) method_name1() [return_type] &#123;    // 方法实现&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123;    // 方法实现&#125;</code></pre><p>实例：</p><pre><code class="go">package mainimport &quot;fmt&quot;type Phone interface &#123;    call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123;    fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123;    fmt.Println(&quot;I am iPhone, I can call you&quot;)&#125;func main() &#123;    var phone Phone    phone = new(NokiaPhone)    phone.call()    phone = new(IPhone)    phone.call()&#125;</code></pre><p>在上面的例子中，我们定义了一个接口 <code>Phone</code>，接口里面有一个方法 <code>call()</code>。然后我们在 <code>main</code> <code>函数里面定义了一个Phone</code> 类型变量，并分别为之赋值为 <code>NokiaPhone</code> 和 <code>IPhone</code>。然后调用 <code>call()</code> 方法，输出结果如下：</p><pre><code class="go">I am Nokia, I can call you!I am iPhone, I can call you!</code></pre><h2 id="十八、Go-错误处理"><a href="#十八、Go-错误处理" class="headerlink" title="十八、Go 错误处理"></a>十八、Go 错误处理</h2><p><code>Go</code> 语言通过 <strong><code>内置的错误接口</code></strong> 提供了非常简单的错误处理机制。</p><p><code>error</code> 类型是一个接口类型，这是它的定义：</p><pre><code class="go">type error interface &#123;    Error() string&#125;</code></pre><p>我们可以在编码中通过实现 <code>error</code> 接口类型来生成错误信息。</p><p>函数通常在最后的返回值中返回错误信息。使用 <code>errors.New</code>   可返回一个错误信息：</p><pre><code class="go">func Sqrt(f float64) (float64, error) &#123;    if f &lt; 0 &#123;        return 0, errors.New(&quot;math: square root of negative number&quot;)    &#125;    // 实现&#125;</code></pre><p>在下面的例子中，我们在调用 <code>Sqrt</code> 的时候传递的一个负数，然后就得到了 <code>non-nil</code> 的 <code>error</code> 对象，将此对象与 <code>nil</code> 比较，结果为 <code>true</code>，所以 <code>fmt.Println</code> ( <code>fmt</code> 包在处理 <code>error</code> 时会调用 <code>Error</code> 方法)被调用，以输出错误，请看下面调用的示例代码：</p><pre><code class="go">result, err := sqrt(-1)if err != nil &#123;    fmt.Println(err)&#125;</code></pre><p>实例：</p><pre><code class="go">package mainimport &quot;fmt&quot;// 定义一个 DivideError 结构type DivideError struct &#123;    dividee int    divider int&#125;// 实现 error 接口func (de *DivideError) Error() string &#123;    strFormat := `        Cannot proceed, the divider is zero.        dividee: %d        divider: 0    `    return fmt.Sprintf(strFormat, de.dividee)&#125;// 定义 int 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;    if varDivider == 0 &#123;        dData := DivideError&#123;            dividee: varDividee,            divider: varDivider,        &#125;        errorMsg = dData.Error()        return    &#125; else &#123;        return varDividee / varDivider, &quot;&quot;    &#125;&#125;func main() &#123;    // 正常情况    if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;        fmt.Println(&quot;100 / 10 = &quot;, result)    &#125;    // 当被除数为零的时候会返回错误信息    if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;        fmt.Println(&quot;errorMsg is: &quot;, errorMsg)    &#125;&#125;// 100/10 =  10// errorMsg is://     Cannot proceed, the divider is zero.//     dividee: 100//     divider: 0</code></pre><h2 id="十九、Go-并发"><a href="#十九、Go-并发" class="headerlink" title="十九、Go 并发"></a>十九、Go 并发</h2><p><code>Go</code> 语言支持并发，我们只需要通过 <code>go</code> 关键字来开启 <code>goroutine</code> 即可。</p><p><code>goroutine</code> 是轻量级线程，<code>goroutine</code> 的调度是由 <code>Golang</code> 运行时进行管理的。</p><p><code>goroutine</code> 语法格式：</p><pre><code class="go">go 函数名 &#123; 参数列表 &#125;</code></pre><p>例如：</p><pre><code class="go">go f(x, y, z)</code></pre><p>开启一个新的 <code>goroutine</code>:</p><pre><code class="go">f(x, y, z)</code></pre><p><code>Go</code> 允许使用 <code>go</code> 语句开启一个新的 **<code>运行期线程</code>**， 即 <code>goroutine</code>，以一个不同的、新创建的 <code>goroutine</code> 来执行一个函数。 同一个程序中的 **<code>所有 goroutine 共享同一个地址空间</code>**。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;time&quot;)func say(s string) &#123;    for i := 0; i &lt; 5; i++ &#123;        time.Sleep(100 * time.Millisecond)        fmt.Println(s)    &#125;&#125;func main() &#123;    go say(&quot;world&quot;)    say(&quot;hello&quot;)&#125;</code></pre><p>执行以上代码，你会看到输出的 <code>hello</code> 和 <code>world</code> 是没有固定先后顺序。因为它们是两个 <code>goroutine</code> 在执行：</p><pre><code class="go">// world// hello// hello// world// world// hello// hello// world// world// hello</code></pre><h3 id="19-1-通道（channel）"><a href="#19-1-通道（channel）" class="headerlink" title="19.1 通道（channel）"></a>19.1 通道（<code>channel</code>）</h3><p>通道（<code>channel</code>）是 **<code>用来传递数据的一个数据结构</code>**。</p><p>通道可用于两个 <code>goroutine</code> 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <code>&lt;-</code> 用于指定通道的方向，**<code>发送或接收</code>**。如果 **<code>未指定方向，则为双向通道</code>**。</p><pre><code class="go">ch &lt;- v // 把 v 发送到通道 chv := &lt;-ch // 从 ch 接收数据，并把值赋给 v</code></pre><p>声明一个通道很简单，我们使用 <code>chan</code> 关键字即可，通道在使用前必须先创建：</p><pre><code class="go">ch := make(chan int)</code></pre><p><strong>注意</strong>：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须又接收相应的接收数据。<br>以下实例通过两个 <code>goroutine</code> 来计算数字之和，在 <code>goroutine</code> 完成计算后，它会计算两个结果的和：</p><pre><code class="go">package mainimport &quot;fmt&quot;func sum(s []int, c chan int)  &#123;    sum := 0    for _, v := range s &#123;        sum += v    &#125;    // 把 sum 发送到通道 c    c &lt;- sum&#125;func main()  &#123;    s := []int&#123;7, 2, 8, -9, 4, 0&#125;    c := make(chan int)    go sum(s[:len(s) / 2], c)    go sum(s[len(s) / 2:], c)    // 从通道 c 中接收    x, y := &lt;-c, &lt;-c    fmt.Println(x, y, x + y)&#125;</code></pre><h3 id="19-2-通道缓冲区"><a href="#19-2-通道缓冲区" class="headerlink" title="19.2 通道缓冲区"></a>19.2 通道缓冲区</h3><p>通道可以设置缓冲区，通过 <code>make</code> 的第二个参数指定缓冲区大小：</p><pre><code class="go">ch := make(chan int, 100)</code></pre><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于 <strong><code>异步状态</code></strong> ，就是说 **<code>发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据</code>**。</p><p>不过由于 **<code>缓冲区的大小是有限的</code>**，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p>如果没有设置容量，或者容量设置为 <code>0</code>, 说明 <code>Channel</code> 没有缓存，只有 <code>sender</code> 和 <code>receiver</code> 都准备好了后，<br>它们的通讯( <code>communication</code> )才会发生( <code>Blocking</code> )。如果设置了缓存，就有可能不发生阻塞， 只有 <code>buffer</code> 满了后 <code>send</code> 才会阻塞，<br>而只有缓存空了后 <code>receive</code> 才会阻塞。一个 <code>nil channel</code> 不会通信。</p><p>注意：</p><ul><li>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；</li><li>如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</li></ul><p>实例：</p><pre><code class="go">package mainimport &quot;fmt&quot;func main()  &#123;    // 这里我们定义了一个可以存储整数类型的带缓冲通道    // 缓冲区大小为 2    ch := make(chan int, 2)    // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据    // 而不用立刻需要去同步读取数据    ch &lt;- 1    ch &lt;- 2    // 获取这两个数据    fmt.Println(&lt;-ch)    fmt.Println(&lt;-ch)&#125;// 1// 2</code></pre><h3 id="19-3-Go-遍历通道与关闭通道"><a href="#19-3-Go-遍历通道与关闭通道" class="headerlink" title="19.3 Go 遍历通道与关闭通道"></a>19.3 <code>Go</code> 遍历通道与关闭通道</h3><p><code>Go</code> 通过 <code>range</code> 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p><pre><code class="go">v, ok := &lt;-ch</code></pre><p>例子：</p><pre><code class="go">func main() &#123;    go func() &#123;        time.Sleep(1 * time.Hour)    &#125;()    c := make(chan int)    go func() &#123;        for i := 0; i &lt; 10; i = i + 1 &#123;            c &lt;- i        &#125;        close(c)    &#125;()    for i := range c &#123;        fmt.Println(i)    &#125;    fmt.Println(&quot;Finished&quot;)&#125;</code></pre><p>如果通道接收不到数据后 <code>ok</code> 就为 <code>false</code>，这时通道就可以使用 <code>close()</code> 函数来 **<code>关闭</code>**。</p><p>斐波那契序列：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)func fibonacci(n int, c chan int)  &#123;    x, y := 0, 1    for i := 0; i &lt; n; i++ &#123;        c &lt;- x        x, y = y, x + y    &#125;    close(c)&#125;func main() &#123;    c := make(chan int, 10)    // 此处 cap 函数返回的是缓冲区的长度    go fibonacci(cap(c), c)    /*         range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个数据之后就关闭了通道，所以        这里我们 range 函数在接收到 10 个数据之后就结束了。如果上面的 c 通道不关闭，那么 range 函数        就不会结束，从而在接收第 11 个数据的时候就阻塞了     */    for i := range c &#123;        fmt.Println(i)    &#125;&#125;</code></pre><h3 id="19-4-Channel-类型"><a href="#19-4-Channel-类型" class="headerlink" title="19.4 Channel 类型"></a>19.4 <code>Channel</code> 类型</h3><p><code>Channel</code> 类型的定义格式如下：</p><pre><code class="go">ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType</code></pre><p>它包括 <strong><code>三种类型的定义</code></strong> 。可选的 <code>&lt;-</code> 代表 <code>channel</code> 的方向。如果没有指定方向，那么 <code>Channel</code> 就是双向的，既可以接收数据，也可以发送数据。</p><pre><code class="go">chan T          // 可以接收的发送类型为 T 的数据chan&lt;- float64  // 只可以用来发送 float64 类型的数据&lt;-chan int      // 只可以用来接收 int 类型的数据</code></pre><p><code>&lt;-</code> 总是优先和最左边的类型结合。</p><pre><code class="go">chan&lt;- chan int // 等价 chan&lt;- (chan int)chan&lt;- &lt;-chan int // 等价 chan&lt;- (&lt;-chan int)&lt;-chan &lt;-chan int // 等价 &lt;-chan (&lt;-chan int)chan (&lt;-chan int)</code></pre><p>你可以在多个 <code>goroutine</code> 从/往 一个 <code>channel</code> 中 <code>receive/send</code> 数据, 不必考虑额外的同步措施。</p><p><code>Channel</code> 可以作为一个 <strong><code>先入先出(FIFO)</code></strong> 的队列，接收的数据和发送的数据的顺序是一致的。</p><p><code>channel</code> 的 <code>receive</code> 支持 <code>多值赋值(multi-valued assignment)</code>，如</p><pre><code class="go">v, ok := &lt;-ch</code></pre><p>可以使用一个 <strong><code>额外的返回参数</code></strong> 来检查 <code>channel</code> 是否关闭。</p><pre><code class="go">x, ok := &lt;-chx, ok = &lt;-chvar x, ok = &lt;-ch</code></pre><p>如果 <code>OK</code> 是 <code>false</code>，表明接收的 <code>x</code> 是产生的零值，这个 <code>channel</code> 被关闭了或者为空。</p><h3 id="19-5-blocking"><a href="#19-5-blocking" class="headerlink" title="19.5 blocking"></a>19.5 blocking</h3><p>默认情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在 <code>gororutine</code> 中进行同步，而不必使用 <strong><code>显示的锁</code></strong> 或者 **<code>条件变量</code>**。</p><p>如官方的例子中 <code>x, y := &lt;-c, &lt;-c</code> 这句会一直等待计算结果发送到 <code>channel</code> 中。</p><pre><code class="go">package mainimport &quot;fmt&quot;func sum(s []int, c chan int) &#123;    sum := 0    for _, v := range s &#123;        sum += v    &#125;    c &lt;- sum // send sum to c&#125;func main() &#123;    s := []int&#123;7, 2, 8, -9, 4, 0&#125;c := make(chan int)    go sum(s[:len(s)/2], c)    go sum(s[len(s)/2:], c)    x, y := &lt;-c, &lt;-c // receive from c    fmt.Println(x, y, x+y)&#125;</code></pre><h3 id="19-6-timeout"><a href="#19-6-timeout" class="headerlink" title="19.6 timeout"></a>19.6 timeout</h3><p><code>select</code> 有很重要的一个应用就是 **<code>超时处理</code>**。 因为上面我们提到，如果没有 <code>case</code> 需要处理，<code>select</code> 语句就会一直阻塞着。<br>这时候我们可能就需要一个超时操作，用来处理超时的情况。</p><p>下面这个例子我们会在 <code>2</code> 秒后往 <code>channel c1</code> 中发送一个数据，但是 <code>select</code> 设置为 <code>1</code> 秒超时,因此我们会打印出 <code>timeout 1</code>,而不是 <code>result 1</code>。</p><p>其实它利用的是 <code>time.After</code> 方法，它返回一个类型为 <code>&lt;-chan Time</code> 的单向的 <code>channel</code>，在指定的时间发送一个当前时间给返回的 <code>channel</code> 中。</p><pre><code class="go">package mainimport (    &quot;time&quot;    &quot;fmt&quot;)func main() &#123;    c1 := make(chan string, 1)    go func() &#123;        time.Sleep(time.Second * 2)        c &lt;- &quot;result 1&quot;    &#125;()    select &#123;        case res := &lt;-c1:            fmt.Println(res)        case &lt;-time.After(time.Second * 1):            fmt.Println(&quot;timeout 1&quot;)    &#125;&#125;</code></pre><h3 id="19-7-Timer-和-Ticker"><a href="#19-7-Timer-和-Ticker" class="headerlink" title="19.7 Timer 和 Ticker"></a>19.7 <code>Timer</code> 和 <code>Ticker</code></h3><p>我们看一下关于时间的两个 <code>Channel</code>。</p><h4 id="19-7-1-Timer"><a href="#19-7-1-Timer" class="headerlink" title="19.7.1 Timer"></a>19.7.1 <code>Timer</code></h4><p><code>timer</code> 是一个定时器，代表未来的一个单一事件，你可以告诉 <code>timer</code> 你要等待多长时间，它提供一个 <code>Channel</code>，在将来的那个时间那个 <code>Channel</code> 提供了一个时间值。</p><p>下面的例子中第二行会阻塞 <code>2</code> 秒钟左右的时间，直到时间到了才会继续执行。</p><pre><code class="go">timer1 := time.NewTimer(time.Second * 2)&lt;-timer1.Cfmt.Println(&quot;Timer 1 expired&quot;)</code></pre><p>当然如果你只是想 <strong><code>单纯的等待</code></strong> 的话，可以使用 <strong><code>time.Sleep</code></strong> 来实现。</p><p>你还可以使用 **<code>timer.Stop 来停止计时器</code>**。</p><pre><code class="go">    timer2 := time.NewTimer(time.Second)    go func() &#123;        &lt;-timer2.C        fmt.Println(&quot;Timer 2 expired&quot;)    &#125;()    stop2 := timer2.Stop()    if stop2 &#123;        fmt.Println(&quot;Timer 2 stopped&quot;)    &#125;</code></pre><h4 id="19-7-2-Ticker"><a href="#19-7-2-Ticker" class="headerlink" title="19.7.2 Ticker"></a>19.7.2 <code>Ticker</code></h4><p><code>ticker</code> 是一个定时触发的计时器，它会以一个间隔( <code>interval</code> )往 <code>Channel</code> 发送一个事件(当前时间)，<br>而 <code>Channel</code> 的接收者可以以固定的时间间隔从 <code>Channel</code> 中读取事件。</p><p>下面的例子中 <code>ticker</code> 每 <code>500</code> 毫秒触发一次，你可以观察输出的时间。</p><pre><code class="go">ticker := time.NewTicker(time.Millisecond * 500)go func() &#123;    for t := range ticker,C &#123;        fmt.Println(&quot;Tick at&quot;, t)    &#125;&#125;</code></pre><p>类似 <code>timer</code>, <code>ticker</code> 也可以通过 <code>Stop</code> 方法来停止。一旦它停止，接收者不再会从 <code>channel</code> 中接收数据了。</p><h3 id="19-8-close"><a href="#19-8-close" class="headerlink" title="19.8 close"></a>19.8 close</h3><p>内建的 <code>close</code> 方法可以用来关闭 <code>channel</code>。</p><p>总结一下 <code>channel</code> 关闭后 <code>sender</code> 的 <code>receiver</code> 操作。</p><p>如果 <code>channel c</code> 已经被关闭,继续往它发送数据会导致 <code>panic: send on closed channel:</code></p><pre><code class="go">import &quot;time&quot;func main() &#123;    go func() &#123;        time.Sleep(time.Hour)    &#125;()    c := make(chan int, 10)    c &lt;- 1    c &lt;- 2    close(c)    c &lt;- 3&#125;</code></pre><p>但是从这个关闭的 <code>channel</code> 中不但可以读取出已发送的数据，还可以不断的读取零值:</p><pre><code class="go">c := make(chan int, 10)c &lt;- 1c &lt;- 2close(c)fmt.Println(&lt;-c) // 1fmt.Println(&lt;-c) // 2fmt.Println(&lt;-c) // 0fmt.Println(&lt;-c) // 0</code></pre><p>但是如果通过 <code>range</code> 读取，<code>channel</code> 关闭后 <code>for</code> 循环会跳出：</p><pre><code class="go">c := make(chan int, 10)c &lt;- 1c &lt;- 2close(c)for i := range c &#123;    fmt.Println(i)&#125;</code></pre><p>通过 <code>i, ok := &lt;-c</code> 可以查看 <code>Channel</code> 的状态，判断值是零值还是正常读取的值。</p><pre><code class="go">c := make(chan int, 10)close(c)i, ok := &lt;-cfmt.Printf(&quot;%d, %t&quot;, i, ok) //0, false</code></pre><h3 id="19-9-同步"><a href="#19-9-同步" class="headerlink" title="19.9 同步"></a>19.9 同步</h3><p><code>channel</code> 可以用在 <code>goroutine</code> 之间的同步。</p><p>下面的例子中 <code>main goroutine</code> 通过 <code>done channel</code> 等待 <code>worker</code> 完成任务。 <code>worker</code> 做完任务后只需往 <code>channel</code> 发送一个数据就可以通知<br><code>main goroutine</code> 任务完成。</p><pre><code class="go">import (    &quot;fmt&quot;    &quot;time&quot;)func worker(done chan bool) &#123;    time.Sleep(time.Second)    // 通知任务已完成    done &lt;- true&#125;func main() &#123;    done := make(chan bool, 1)    go worker(done)    // 等待任务完成    &lt;-done&#125;</code></pre><h2 id="二十、占位符"><a href="#二十、占位符" class="headerlink" title="二十、占位符"></a>二十、占位符</h2><p>定义示例类型和变量</p><pre><code class="go">type Human struct &#123;    Name string&#125;var people = Human&#123;Name:&quot;zhangsan&quot;&#125;</code></pre><h3 id="20-1-普通占位符"><a href="#20-1-普通占位符" class="headerlink" title="20.1 普通占位符"></a>20.1 普通占位符</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>%v</code></td><td align="left">相应值的默认格式。</td><td align="left"><code>Printf(&quot;%v&quot;, people)</code></td><td align="left"><code>&#123;zhangsan&#125;</code></td></tr><tr><td align="left"><code>%+v</code></td><td align="left">打印结构体时，会添加字段名</td><td align="left"><code>Printf(&quot;%+v&quot;, people)</code></td><td align="left"><code>&#123;Name:zhangsan&#125;</code></td></tr><tr><td align="left"><code>%#v</code></td><td align="left">相应值的 <code>Go</code> 语法表示</td><td align="left"><code>Printf(&quot;#v&quot;, people)</code></td><td align="left"><code>main.Human&#123;Name:&quot;zhangsan&quot;&#125;</code></td></tr><tr><td align="left"><code>%T</code></td><td align="left">相应值的类型的 <code>Go</code> 语法表示</td><td align="left"><code>Printf(&quot;%T&quot;, people)</code></td><td align="left"><code>main.Human</code></td></tr><tr><td align="left"><code>%%</code></td><td align="left">字面上的百分号，并非值的占位符</td><td align="left"><code>Printf(&quot;%%&quot;)</code></td><td align="left"><code>%</code></td></tr></tbody></table><h3 id="20-2-布尔占位符"><a href="#20-2-布尔占位符" class="headerlink" title="20.2 布尔占位符"></a>20.2 布尔占位符</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>%t</code></td><td align="left"><code>true</code> 或 <code>false</code></td><td align="left"><code>Printf(&quot;%t&quot;, true)</code></td><td align="left"><code>true</code></td></tr></tbody></table><h3 id="20-3-整数占位符"><a href="#20-3-整数占位符" class="headerlink" title="20.3 整数占位符"></a>20.3 整数占位符</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>%b</code></td><td align="left">二进制表示</td><td align="left"><code>Printf(&quot;%b&quot;, 5)</code></td><td align="left"><code>101</code></td></tr><tr><td align="left"><code>%c</code></td><td align="left">相应 <code>Unicode</code> 码点所表示的字符</td><td align="left"><code>Printf(&quot;%c&quot;, 0x4E2D)</code></td><td align="left">中</td></tr><tr><td align="left"><code>%d</code></td><td align="left">十进制表示</td><td align="left"><code>Printf(&quot;%d&quot;, 0x12)</code></td><td align="left"><code>18</code></td></tr><tr><td align="left"><code>%o</code></td><td align="left">八进制表示</td><td align="left"><code>Printf(&quot;%d&quot;, 10)</code></td><td align="left"><code>12</code></td></tr><tr><td align="left"><code>%q</code></td><td align="left">单引号围绕的字符字面值，由 <code>Go</code> 语法安全地转义</td><td align="left"><code>Printf(&quot;%q&quot;, 0x4E2D)</code></td><td align="left">&#39;中&#39;</td></tr><tr><td align="left"><code>%x</code></td><td align="left">十六进制表示，字母形式为小写 <code>a-f</code></td><td align="left"><code>Printf(&quot;%x&quot;, 13)</code></td><td align="left"><code>d</code></td></tr><tr><td align="left"><code>%X</code></td><td align="left">十六进制表示，字母形式为大写 <code>A-F</code></td><td align="left"><code>Printf(&quot;%x&quot;, 13)</code></td><td align="left"><code>D</code></td></tr><tr><td align="left"><code>%U</code></td><td align="left"><code>Unicode</code> 格式：<code>U+1234</code>，等同于 <code>&quot;U+%04X&quot;</code></td><td align="left"><code>Printf(&quot;%U&quot;, 0x4E2D)</code></td><td align="left"><code>U+4E2D</code></td></tr></tbody></table><h3 id="20-4-浮点数和复数的组成部分（实部和虚部）"><a href="#20-4-浮点数和复数的组成部分（实部和虚部）" class="headerlink" title="20.4 浮点数和复数的组成部分（实部和虚部）"></a>20.4 浮点数和复数的组成部分（实部和虚部）</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>%b</code></td><td align="left">无小数部分的，指数为二的幂的科学计数法， 与 <code>strconv.FormatFloat</code> 的 <code>&#39;b&#39;</code> 转换格式一致。例如 <code>-123456p-78</code></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>%e</code></td><td align="left">科学计数法，例如 <code>-1234.456e+78</code></td><td align="left"><code>Printf(&quot;%e&quot;, 10.2)</code></td><td align="left"><code>1.020000e+01</code></td></tr><tr><td align="left"><code>%E</code></td><td align="left">科学计数法，例如 <code>-1234.456E+78</code></td><td align="left"><code>Printf(&quot;%e&quot;, 10.2)</code></td><td align="left"><code>1.020000E+01</code></td></tr><tr><td align="left"><code>%f</code></td><td align="left">有小数点而无指数，例如 <code>123.456</code></td><td align="left"><code>Printf(&quot;%f&quot;, 10.2)</code></td><td align="left"><code>10.200000</code></td></tr><tr><td align="left"><code>%g</code></td><td align="left">根据情况选择 <code>%e</code> 或 <code>%f</code> 以产生更紧凑的（无末尾的 <code>0</code>）输出</td><td align="left"><code>Printf(&quot;%g&quot;, 10.20)</code></td><td align="left"><code>10.2</code></td></tr><tr><td align="left"><code>%G</code></td><td align="left">根据情况选择 <code>%E</code> 或 <code>%f</code> 以产生更紧凑的（无末尾的 <code>0</code>）输出</td><td align="left"><code>Printf(&quot;%G&quot;, 10.20+2i)</code></td><td align="left"><code>(10.2+2i)</code></td></tr></tbody></table><h3 id="20-5-字符串与字节切片"><a href="#20-5-字符串与字节切片" class="headerlink" title="20.5 字符串与字节切片"></a>20.5 字符串与字节切片</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>%s</code></td><td align="left">输出字符串表示（<code>string</code> 类型或 <code>[]byte</code>)</td><td align="left"><code>Printf(&quot;%s&quot;, []byte(&quot;Go语言&quot;))</code></td><td align="left"><code>Go</code> 语言</td></tr><tr><td align="left"><code>%q</code></td><td align="left">双引号围绕的字符串，由 <code>Go</code> 语法安全地转义</td><td align="left"><code>Printf(&quot;%q&quot;, &quot;Go语言&quot;)</code></td><td align="left">&quot;<code>Go</code> 语言&quot;</td></tr><tr><td align="left"><code>%x</code></td><td align="left">十六进制，小写字母，每字节两个字符</td><td align="left"><code>Printf(&quot;%x&quot;, &quot;golang&quot;)</code></td><td align="left"><code>676f6c616e67</code></td></tr><tr><td align="left"><code>%X</code></td><td align="left">十六进制，大写字母，每字节两个字符</td><td align="left"><code>Printf(&quot;%X&quot;, &quot;golang&quot;)</code></td><td align="left"><code>676F6C616E67</code></td></tr></tbody></table><h3 id="20-6-指针"><a href="#20-6-指针" class="headerlink" title="20.6 指针"></a>20.6 指针</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>%p</code></td><td align="left">十六进制表示，前缀 <code>0x</code></td><td align="left"><code>Printf(&quot;%p&quot;, &amp;people)</code></td><td align="left"><code>0x4f57f0</code></td></tr></tbody></table><h3 id="20-5-其它标记"><a href="#20-5-其它标记" class="headerlink" title="20.5 其它标记"></a>20.5 其它标记</h3><table><thead><tr><th align="left">占位符</th><th align="left">说明</th><th align="left">举例</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">总打印数值的正负号；对于 <code>%q（%+q）</code> 保证只输出 <code>ASCII</code> 编码的字符。</td><td align="left"><code>Printf(&quot;%+q&quot;, &quot;中文&quot;)</code></td><td align="left"><code>&quot;\u4e2d\u6587&quot;</code></td></tr><tr><td align="left"><code>-</code></td><td align="left">在右侧而非左侧填充空格（左对齐该区域）</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>#</code></td><td align="left">备用格式：为八进制添加前导 <code>0（%#o）</code> 为十六进制添加前导 <code>0x（%#x）</code> 或 <code>0X（%#X）</code>，为 <code>%p（%#p）</code> 去掉前导 <code>0x</code>； 如果可能的话，<code>%q（%#q）</code> 会打印原始 （即反引号围绕的）字符串； 如果是可打印字符，<code>%U（%#U）</code> 会写出该字符的 <code>Unicode</code> 编码形式（如字符 <code>x</code> 会被打印成 <code>U+0078 &#39;x&#39;</code>）。</td><td align="left"><code>Printf(&quot;%#U&quot;, &#39;中&#39;)</code></td><td align="left"><code>U+4E2D</code></td></tr><tr><td align="left"><code>&#39;&#39;</code></td><td align="left">(空格)为数值中省略的正负号留出空白（% d）； 以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>0</code></td><td align="left">填充前导的 0 而非空格；对于数字，这会将填充移到正负号之后</td><td align="left"></td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 文档</title>
      <link href="%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%90%8E%E7%AB%AF/Dart%20%E6%96%87%E6%A1%A3/"/>
      <url>%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%90%8E%E7%AB%AF/Dart%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dart.dev/" target="_blank" rel="noopener external nofollow noreferrer"><strong>官方网站：https://dart.dev/</strong></a></p><p><a href="http://dart.goodev.org/" target="_blank" rel="noopener external nofollow noreferrer"><strong>中文网站：http://dart.goodev.org/</strong></a></p><h2 id="一、-安装"><a href="#一、-安装" class="headerlink" title="一、 安装"></a>一、 安装</h2><p>获取 <code>dart SDK</code></p><pre><code class="bash">// 稳定版brew tap dart-lang/dartbrew install dart</code></pre><pre><code class="bash">// 最新版brew install dart --devel</code></pre><pre><code class="bash">// 升级brew upgrade dart</code></pre><pre><code class="bash">// 安装稳定版brew unlink dartbrew install dart</code></pre><pre><code class="bash">// 安装最新版brew upgrade --force dart -- --level</code></pre><pre><code class="bash">// 查看版本brew info dart</code></pre><h2 id="二、-介绍"><a href="#二、-介绍" class="headerlink" title="二、 介绍"></a>二、 介绍</h2><p><code>main</code> 方法：程序入口</p><p><code>print</code> 方法：可以在控制台输出内容</p><h2 id="三、-变量与常量"><a href="#三、-变量与常量" class="headerlink" title="三、 变量与常量"></a>三、 变量与常量</h2><h3 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h3><p>使用 <code>var</code> 声明变量，可赋予不同类型的值。</p><p>未初始化时，默认值为 <code>null</code>。</p><p>使用 <code>final</code> 关键字声明一个只能赋值一次的变量。</p><h3 id="3-2-常量"><a href="#3-2-常量" class="headerlink" title="3.2 常量"></a>3.2 常量</h3><p>使用 <code>const</code> 声明常量</p><p>使用 <code>const</code> 声明的必须是编译器的常量 <code>=&amp;gt;</code> 在编译阶段就可以确定它的值</p><h2 id="四、-数据类型"><a href="#四、-数据类型" class="headerlink" title="四、 数据类型"></a>四、 数据类型</h2><h3 id="4-1-数值型：Number-简写：num"><a href="#4-1-数值型：Number-简写：num" class="headerlink" title="4.1 数值型：Number (简写：num)"></a>4.1 数值型：<code>Number</code> (简写：<code>num</code>)</h3><ul><li>子类型：</li></ul><ol><li>整型 <code>Int</code></li><li>浮点型 <code>double</code></li></ol><ul><li>数值型操作：</li></ul><p><strong>运算符：</strong> <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>～/</code>(<strong>取整</strong>)、<code>%</code>(<strong>取余</strong>)</p><p><strong>常用属性：</strong> <code>isNaN</code> (<strong>是否是非数字</strong>)、<code>isEven</code> (<strong>是否是偶数</strong>)、<code>isOdd</code> (<strong>是否是奇数</strong>)</p><p><strong>常用方法：</strong></p><ol><li><p> <code>abs()</code> 绝对值</p></li><li><p> <code>round()</code> 四舍五入</p></li><li><p> <code>floor()</code> 取不大于它的整数，向下取整</p></li><li><p> <code>ceil()</code> 取不小于于它的整数，向上取整</p></li><li><p> <code>toInt()</code> 浮点型转整形</p></li><li><p> <code>toDouble()</code> 整形转浮点型</p></li></ol><p><strong>注意:</strong> <code>0.0 /0.0 =&gt; NAN</code></p><h3 id="4-2-字符串：String"><a href="#4-2-字符串：String" class="headerlink" title="4.2 字符串：String"></a>4.2 字符串：<code>String</code></h3><ul><li>字符串的使用</li></ul><ol><li>使用单引号，双引号创建字符串</li><li>使用三个引号或双引号创建多行字符串</li><li>使用 <code>r</code> 创建原始 <code>raw</code> 字符串. <code>=&amp;gt;</code></li></ol><pre><code class="dart">String str = &#39;Hello \n World!&#39;;print(str); // 输出换行形式的 Hello WorldString str1 = r&#39;Hello \n World!&#39;;print(str1); // 输出 Hello \n World</code></pre><ul><li>字符串操作</li></ul><p><strong>运算符:</strong> <code>+</code>、<code>*</code>(<strong>重复次数</strong>)、<code>==</code>、<code>[]</code>(<strong>取字符</strong>)</p><p><strong>插值表达式：</strong> <code>$&#123;expression&#125;</code></p><pre><code class="dart">int a = 1;int b = 2;print(&#39;a + b = $&#123;a + b&#125;&#39;);print(&#39;a=$a&#39;);</code></pre><p><strong>常用属性</strong>：<code>length</code>、<code>isEmpty</code>、<code>isNotEmpty</code></p><p><strong>常用方法</strong>：</p><p>1、<code>contains()</code>(是否包含)</p><p>2、<code>subString()</code>(截取一段字符串，参数 1:开始位置；参数 2:结束位置(不包括))</p><p>3、<code>startsWith()</code>(是否以一个字符串开头)</p><p>4、<code>endsWith()</code>(是否以一个字符串结尾)</p><p>5、<code>indexOf()</code>(是否包含一个字符，返回这个字符的下标)</p><p>6、<code>lastIndexOf()</code>(是否包含一个字符，倒序返回这个字符的下标)</p><p>7、<code>toLowerCase()</code>(转换小写)</p><p>8、<code>toUpperCase()</code>(转换大写)</p><p>9、<code>trim()</code>(截取空格)</p><p>10、<code>trimLeft()</code>(截取左边空格)</p><p>11、<code>trimRight()</code>(截取右边空格)</p><p>12、<code>split()</code>(分割字符串)</p><p>13、<code>replaceXXX()</code>(替换)</p><h3 id="4-3-布尔型：Boolean"><a href="#4-3-布尔型：Boolean" class="headerlink" title="4.3 布尔型：Boolean"></a>4.3 布尔型：<code>Boolean</code></h3><h3 id="4-4-列表：List"><a href="#4-4-列表：List" class="headerlink" title="4.4 列表：List"></a>4.4 列表：<code>List</code></h3><ul><li><strong><code>List</code>(数组)的创建</strong></li></ul><p><strong>创建 <code>List</code>：</strong></p><pre><code class="dart">var list = [1, 2, 3];</code></pre><p><strong>创建不可变的 List：</strong></p><pre><code class="dart">var list = const [1, 2, 3];</code></pre><p><strong>构造创建：</strong></p><pre><code class="dart">var list = new List();</code></pre><ul><li><strong>常用操作</strong></li></ul><p><code>[].length</code></p><p><code>add()</code>、<code>insert()</code> <strong>用来添加元素</strong></p><p><code>remove()</code>、<code>clear()</code> <strong>用来删除元素，其中 <code>clear</code> 是清空整个 <code>list</code></strong></p><p><code>indexOf()</code>、<code>lastIndexOf</code> <strong>获取 <code>list</code> 中元素的位置</strong></p><p><code>sort()</code> <strong>排序，可以传递参数，参数是要传递的方法，默认按照 <code>ASCII</code> 码来进行排序。</strong></p><p><code>sublist()</code> <strong>获取子 <code>list</code></strong></p><p><code>shuffle()</code> <strong>打乱(随机打乱 )</strong></p><p><code>asMap()</code>  <strong>将 <code>list</code> 转换为 <code>map</code></strong></p><p><code>forEach()</code> <strong>循环一个 <code>list</code>，括号中传递的是一个方法。</strong> <code>list.forEach(print);</code></p><p><code>generate</code> (生成集合的长度, 迭代器回调函数)<strong>集合的生成函数</strong></p><h3 id="4-5-键值对：Map"><a href="#4-5-键值对：Map" class="headerlink" title="4.5 键值对：Map"></a>4.5 键值对：<code>Map</code></h3><ul><li><code>Map</code> 的创建</li></ul><blockquote><p>创建 Map</p></blockquote><pre><code class="dart">var language = &#123;&#39;first&#39;: &#39;Dart&#39;, &#39;second&#39;: &#39;Java&#39;&#125;;</code></pre><blockquote><p>创建不可变 Map</p></blockquote><pre><code class="dart">var language = const &#123;&#39;first&#39;: &#39;Dart&#39;, &#39;second&#39;: &#39;Java&#39;&#125;;</code></pre><blockquote><p>构造创建</p></blockquote><pre><code class="dart">var language = new Map();</code></pre><ul><li><code>Map</code> 常用操作</li></ul><p>1、<code>[].length</code></p><p>2、<code>isEmpty()</code>、<code>isNotEmpty()</code> <strong>是否为空</strong></p><p>3、<code>keys,values</code> <strong>获取 map 所有的键和所有的值</strong></p><p>4、<code>containsKey()</code> <strong>是否包含某个键</strong></p><p>5、<code>containsValue()</code> <strong>是否包含某个值</strong></p><p>6、<code>remove()</code> <strong>移除某个元素</strong></p><p>7、<code>forEach()</code> <strong>循环，传入两个方法</strong></p><pre><code class="dart">void main() &#123;  var map = &#123;&#39;first&#39;: &#39;Dart&#39;, &#39;Second&#39;: &#39;Java&#39;, &#39;Third&#39;: &#39;Python&#39;&#125;;  map.forEach(f);&#125;void f(key, value) &#123;  print(&quot;key=$key, value=$value&quot;);&#125;</code></pre><p>8、 <code>map()</code> <strong><code>map</code> 的遍历方式，接受一个回调函数作为参数，返回一个新 <code>map</code></strong></p><pre><code class="dart">void main() &#123;    Map age = &#123;&quot;zhangsan&quot;: 18, &quot;lisi&quot;: 20&#125;;    Map age2 = age.map(f);    print(age2); // &#123;18: &quot;zhangsan&quot;, 20: &quot;lisi&quot;&#125;;&#125;MapEntry f(k, v) &#123;    return MapEntry(v, k); // 调换 k, v 的值&#125;</code></pre><h3 id="4-6-Runes-Symbols"><a href="#4-6-Runes-Symbols" class="headerlink" title="4.6 Runes, Symbols"></a>4.6 <code>Runes, Symbols</code></h3><h3 id="4-7-dynamic-amp-gt-动态类型"><a href="#4-7-dynamic-amp-gt-动态类型" class="headerlink" title="4.7 dynamic =&amp;gt; 动态类型"></a>4.7 <code>dynamic =&amp;gt</code>; 动态类型</h3><pre><code class="dart">void main() &#123;  var list = new List&lt;dynamic&gt;();  list.add(1);  list.add(&quot;hello&quot;);  list.add(true);  print(list);&#125;</code></pre><h3 id="4-8-dynamic-var-Object-的区别"><a href="#4-8-dynamic-var-Object-的区别" class="headerlink" title="4.8 dynamic, var, Object 的区别"></a>4.8 <code>dynamic, var, Object</code> 的区别</h3><p><em>dynamic</em> 是动态类型，如果使用其声明一种类型，则仍旧可以为其声明另一种类型；通常不直接使用。</p><p><em>var</em> 是关键字，如果使用其声明一种类型，不可为其声明另一种类型，但可改变同类型的值；</p><p><em>Obejct</em> 是基类，用其声明的变量只能使用 <em><strong>Object</strong></em> 类所提供的方法</p><h2 id="五、-运算符"><a href="#五、-运算符" class="headerlink" title="五、 运算符"></a>五、 运算符</h2><h3 id="5-1-算数运算符"><a href="#5-1-算数运算符" class="headerlink" title="5.1 算数运算符"></a>5.1 算数运算符</h3><ul><li><strong>加减乘除</strong>: <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>～/</code>，<code>%</code>。</li><li><strong>递增递减:</strong> ·<code>++var</code>，<code>var++</code>，<code>--var</code>，<code>var--</code>。</li></ul><h3 id="5-2-关系运算符"><a href="#5-2-关系运算符" class="headerlink" title="5.2 关系运算符"></a>5.2 关系运算符</h3><ul><li><strong>运算符:</strong> <code>==</code>，<code>!=</code>，<code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code></li><li><strong>判断内容是否相同使用 <code>==</code></strong></li></ul><h3 id="5-3-逻辑运算符"><a href="#5-3-逻辑运算符" class="headerlink" title="5.3 逻辑运算符"></a>5.3 逻辑运算符</h3><ul><li><strong>运算符：</strong> <code>!</code>，<code>&amp;&amp;</code>，<code>||</code></li><li><strong>针对布尔类型运算</strong></li></ul><h3 id="5-4-赋值运算符"><a href="#5-4-赋值运算符" class="headerlink" title="5.4 赋值运算符"></a>5.4 赋值运算符</h3><ul><li><strong>基础运算符：</strong> <code>=</code>，<code>??=</code><strong>(如果左边的变量没有值，就将右侧的值赋给它；如果左边变量有值，右边的值无效。)</strong></li><li><strong>复合运算符：</strong><code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>，<code>~/=</code></li></ul><h3 id="5-5-条件表达式"><a href="#5-5-条件表达式" class="headerlink" title="5.5 条件表达式"></a>5.5 条件表达式</h3><ul><li><strong>三目运算符：</strong> <code>condition ? expr1 : expr2</code></li><li><strong><code>??</code>运算符：</strong> <code>expr1 ?? expr2</code>(<strong>如果第一个表达式为空，则使用第二个表达式，否则直接使用第一个表达式的值.</strong>)</li></ul><h2 id="六、-控制流语句"><a href="#六、-控制流语句" class="headerlink" title="六、 控制流语句"></a>六、 控制流语句</h2><h3 id="6-1-条件语句"><a href="#6-1-条件语句" class="headerlink" title="6.1 条件语句"></a>6.1 条件语句</h3><ul><li><strong>if 语句</strong></li><li><strong>if...else if 语句</strong></li><li><strong>if...else if...else 语句</strong></li></ul><h3 id="6-2-循环语句"><a href="#6-2-循环语句" class="headerlink" title="6.2 循环语句"></a>6.2 循环语句</h3><ul><li><strong>for 循环</strong></li><li><strong>for...in 循环</strong></li><li><strong>while 循环</strong></li><li><strong>do...while 循环</strong></li><li><strong>break 和 continue</strong><ul><li><strong>break 用于终止循环</strong></li><li><strong>continue 用于跳出当前循环</strong></li></ul></li><li><strong>switch...case 语句</strong><ul><li><strong>比较类型:</strong> <strong>num, String, 编译器常量, 对象, 枚举</strong></li><li><strong>非空 case 必须有一个 break</strong></li><li><strong>default 关键字来处理默认情况</strong></li><li><strong>continue 跳转标签</strong></li></ul></li></ul><h2 id="七、-方法"><a href="#七、-方法" class="headerlink" title="七、 方法"></a>七、 方法</h2><h3 id="7-1-方法定义"><a href="#7-1-方法定义" class="headerlink" title="7.1 方法定义"></a>7.1 方法定义</h3><p><strong>方法定义：</strong></p><pre><code>返回类型 方法名 (参数1，参数2 ...) &#123;    方法体    return 返回值&#125;</code></pre><p><strong>方法特性：</strong></p><p><code>1、</code> 方法也是对象，并且有具体类型 <code>Function</code>。</p><p><code>2、</code> 返回值类型，参数类型都可以省略。</p><p><code>3、</code> 箭头语法：<code>=&gt; expr</code> 是 <code>&#123;return expr;&#125;</code>缩写。只适用于 <strong>一个表达式</strong>。</p><p><code>4、</code> 方法都有返回值。如果没有指定，默认 <code>return null</code> 最后一句执行。</p><h3 id="7-2-可选参数"><a href="#7-2-可选参数" class="headerlink" title="7.2 可选参数"></a>7.2 可选参数</h3><ul><li>可选命名参数：<code>&#123;param1, param2, ...&#125;</code></li></ul><pre><code class="dart">void main() &#123;  printPerson(&quot;张三&quot;);// name=张三, age=null, gender=null  printPerson(&quot;张三&quot;, age: 20); // name=张三, age=20, gender=null  printPerson(&quot;张三&quot;, age: 20, gender: &quot;Male&quot;); // name=张三, age=20, gender=&quot;Male&quot;  printPerson(&quot;张三&quot;, gender: &quot;Male&quot;); // name=张三, age=null, gender=&quot;Male&quot;&#125;printPerson(String name, &#123; int age, String gender &#125;) &#123;  print(&#39;name=$name, age=$age, gender=$gender&#39;);&#125;</code></pre><ul><li>可选位置参数：<code>[param1, param2, ...]</code></li></ul><pre><code class="dart">void main() &#123;  printPerson(&quot;李四&quot;);// name=李四, age=null, gender=null  printPerson(&quot;李四&quot;, 18);// name=李四, age=18, gender=null  printPerson(&quot;李四&quot;, 18, &quot;男&quot;); // name=李四, age=18, gender=男&#125;printPerson(String name, [int age, String gender]) &#123;  print(&#39;name=$name, age=$age, gender=$gender&#39;);&#125;</code></pre><ul><li>如果存在具体参数，可选参数声明，必须在参数后面</li></ul><h3 id="7-3-默认参数值"><a href="#7-3-默认参数值" class="headerlink" title="7.3 默认参数值"></a>7.3 默认参数值</h3><ul><li>使用 <code>=</code> 在 <strong>可选参数</strong> 指定默认值</li></ul><pre><code class="dart">void main() &#123;  printPerson(&quot;张三&quot;); // name=张三, age=30, gender=女  printPerson(&quot;张三&quot;, age: 20); // name=张三, age=20, gender=女  printPerson(&quot;张三&quot;, gender: &quot;男&quot;); // name=张三, age=30, gender=男&#125;printPerson(String name, &#123; int age = 30, String gender = &quot;女&quot; &#125;) &#123;  print(&#39;name=$name, age=$age, gender=$gender&#39;);&#125;</code></pre><ul><li>默认值只能是编译时常量</li></ul><h3 id="7-4-方法对象"><a href="#7-4-方法对象" class="headerlink" title="7.4 方法对象"></a>7.4 方法对象</h3><ul><li>方法可以作为对象赋值给其它变量</li></ul><pre><code class="dart">void main() &#123;  // var func = printHello;  Function func = printHello;  func();&#125;void printHello() &#123;  print(&quot;Hello&quot;);&#125;</code></pre><ul><li>方法可作为参数传递给其它方法</li></ul><pre><code class="dart">void main() &#123;  var list = [1, 2, 3, 4];  list.forEach(print);&#125;// 或者void main() &#123;  var list1 = [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;];  print(listTimes(list1, times));&#125;List listTimes(List list, String f(str)) &#123;  for(var index = 0; index &lt; list.length; index++) &#123;    list[index] = f(list[index]);  &#125;  return list;&#125;String times(str) &#123;  return str * 3;&#125;</code></pre><h3 id="7-5-匿名方法"><a href="#7-5-匿名方法" class="headerlink" title="7.5 匿名方法"></a>7.5 匿名方法</h3><p>如何定义：</p><pre><code class="dart">(参数1，参数2，...) &#123;    方法体...    return 返回值&#125;</code></pre><p>匿名方法的特性：</p><ul><li>可赋值给变量，通过变量进行调用</li></ul><pre><code class="dart">void main() &#123;  // 第一种  var func = (str) &#123;    print(&quot;Hello---$str&quot;);  &#125;;  func(30);  // 第二种  (() &#123;      print(&quot;Test&quot;);  &#125;)()&#125;</code></pre><ul><li>可在其它方法中直接调用或传递给其它方法</li></ul><pre><code class="dart">void main() &#123;  var list1 = [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;];  var result = listTimes(list1, (str) &#123;return str * 3;&#125;);  // var result = listTimes(list1, (str) =&gt; str * 3);  print(result);&#125;List listTimes(List list, f(str)) &#123;  for(var index = 0; index &lt; list.length; index++) &#123;    list[index] = f(list[index]);  &#125;  return list;&#125;</code></pre><pre><code class="dart">void main() &#123;  var list2 = [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;];  print(listTimes2(list2));&#125;List listTimes2(List list) &#123;  var func = (str) &#123; return str * 3; &#125;;  for(var i = 0; i &lt; list.length; i++) &#123;    list[i] = func(list[i]);  &#125;  return list;&#125;</code></pre><p>注意：匿名方法不能直接定义在外面</p><h3 id="7-6-闭包"><a href="#7-6-闭包" class="headerlink" title="7.6 闭包"></a>7.6 闭包</h3><ul><li>闭包是一个方法(对象)</li><li>闭包定义在其它方法内部</li><li>闭包能够访问外部方法内的局部变量，并持有其状态</li></ul><pre><code class="dart">void main() &#123;  var func = a();  func();  func();  func();  func();&#125;a() &#123;  int count = 0;  printCount() &#123;    print(count++);  &#125;;  return printCount;&#125;</code></pre><pre><code class="dart">// 使用匿名方法的闭包void main() &#123;  var func = a();  func();  func();  func();  func();&#125;a() &#123;  int count = 0;  return () &#123;    print(count++);  &#125;;&#125;</code></pre><h2 id="八、-Dart-面向对象编程"><a href="#八、-Dart-面向对象编程" class="headerlink" title="八、 Dart 面向对象编程"></a>八、 <code>Dart</code> 面向对象编程</h2><h3 id="8-1-类于对象"><a href="#8-1-类于对象" class="headerlink" title="8.1 类于对象"></a>8.1 类于对象</h3><ol><li>使用关键字 <code>class</code> 声明一个类</li><li>使用关键字 <code>new</code> 创建一个对象，<code>new</code> 可省略</li><li>所有对象都继承于 <code>Object</code> 类型</li></ol><h3 id="8-2-属性和方法"><a href="#8-2-属性和方法" class="headerlink" title="8.2 属性和方法"></a>8.2 属性和方法</h3><ol><li>属性默认会生成 <code>getter</code> 和 <code>setter</code> 方法</li><li>使用 <code>final</code> 声明的属性只有 <code>getter</code> 方法（只可读不可写）</li><li>属性和方法是通过 <code>.</code> 访问</li><li>方法不能被重栽</li></ol><h3 id="8-3-类及成员可见性"><a href="#8-3-类及成员可见性" class="headerlink" title="8.3 类及成员可见性"></a>8.3 类及成员可见性</h3><ol><li><code>Dart</code> 中的可见性是以 <code>library(库)</code> 为单位</li><li>默认情况下，每一个 <code>Dart</code> 文件就是一个库</li><li>使用 <code>_</code> 表示库的私有性</li></ol><pre><code class="dart">// person.dartclass _Person &#123;  String name;  int age;  // final String address;  void work() &#123;    print(&quot;name is $name, age is $age&quot;);  &#125;&#125;// class_and_object.dartimport &#39;person.dart&#39;;void main() &#123;  // var person = new Person();  var person = _Person(); // error  person.name = &quot;Tom&quot;;  person.age = 20;  print(person.name);  person.work();  // print(person.address);&#125;</code></pre><ol start="4"><li>使用 <em><strong>import</strong></em> 导入库</li></ol><h3 id="8-4-计算属性"><a href="#8-4-计算属性" class="headerlink" title="8.4 计算属性"></a>8.4 计算属性</h3><ol><li>顾名思义，计算属性的值是通过计算而来，本身不存储值</li><li>计算属性赋值，其实是通过计算转换到其它实例变量</li></ol><pre><code class="dart">void main() &#123;  var rect = new Rectangle();  rect.width = 10;  rect.height = 20;  print(rect.area); // 200;  // 已知面积求宽度  rect.area = 200;  print(rect.width); // 10.0&#125;class Rectangle &#123;  num width, height;  // 获取计算属性的值  num get area =&gt; width * height;  // num get area &#123;  //   return width * height;  // &#125;  // 设置计算属性值  set area(value)&#123;    width = value / 20;  &#125;&#125;</code></pre><h3 id="8-5-构造方法"><a href="#8-5-构造方法" class="headerlink" title="8.5 构造方法"></a>8.5 构造方法</h3><ol><li>如果没有自定义构造方法，则会有个默认构造方法</li><li>如果存在自定义构造方法，则默认构造方法无效</li></ol><pre><code class="dart">void main() &#123;  var person = new Person(&quot;Tom&quot;, 20);&#125;class Person &#123;  String name;  int age;  // final String gender;  Person(String name, int age) &#123;    this.name = name;    this.age = age;  &#125;  void work() &#123;    print(&quot;work...&quot;);  &#125;&#125;</code></pre><p><strong>语法糖</strong>：在构造方法执行之前对属性进行赋值</p><pre><code class="dart">void main() &#123;  var person = new Person(&quot;Tom&quot;, 20, &quot;Male&quot;);&#125;class Person &#123;  String name;  int age;  final String gender;  Person(this.name, this.age, this.gender); // 语法糖  void work() &#123;    print(&quot;work...&quot;);  &#125;&#125;</code></pre><ol start="3"><li>构造方法不能重载</li></ol><h3 id="8-6-命名构造方法"><a href="#8-6-命名构造方法" class="headerlink" title="8.6 命名构造方法"></a>8.6 命名构造方法</h3><ol><li>使用命名构造方法，可以实现多个构造方法</li><li>使用 <strong>类名.方法</strong> 的形式实现</li></ol><pre><code class="dart">void main() &#123;  var person = new Person.width(&quot;Tom&quot;);&#125;class Person &#123;  String name;  Person.width(String name) &#123;    this.name = name;  &#125;  void work() &#123;    print(&quot;work...&quot;);  &#125;&#125;</code></pre><h3 id="8-7-常量构造方法"><a href="#8-7-常量构造方法" class="headerlink" title="8.7 常量构造方法"></a>8.7 常量构造方法</h3><ol><li>如果类是不可变状态，可以把对象定义为编译时常量</li><li>使用 <code>const</code> 声明构造方法，并且所有变量都为 <code>fianl</code></li><li>使用 <code>const</code> 声明对象，可以省略</li></ol><pre><code class="dart">void main() &#123;  // const person = const Person(&quot;张三&quot;, 20, &quot;Male&quot;);  const person = Person(&quot;张三&quot;, 20, &quot;Male&quot;);&#125;class Person &#123;  final String name;  final int age;  final String gender;  const Person(this.name, this.age, this.gender);  void work() &#123;    print(&quot;work&quot;);  &#125;&#125;</code></pre><h3 id="8-8-工厂构造方法"><a href="#8-8-工厂构造方法" class="headerlink" title="8.8 工厂构造方法"></a>8.8 工厂构造方法</h3><ol><li>工厂构造方法类似于设计模式中的工厂模式</li><li>在构造方法前添加关键字 <code>factory</code> 实现一个工厂构造方法</li><li>在工厂构造方法中可返回对象</li></ol><pre><code class="dart">class Logger &#123;  final String name;  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt; &#123;&#125;;  factory Logger(String name) &#123;    return Logger._internal(&#39;Dart&#39;); // 可以返回  &#125;  Logger._internal(this.name);  void log(String msg) &#123;    print(msg);  &#125;&#125;</code></pre><ul><li>_<strong>命名工厂构造方法</strong><em>（</em><strong>factory 类名.方法名</strong>_）</li></ul><p>它可以有返回值，而且不需要将类的 <em><strong>final</strong></em> 变量作为参数，是提供一种灵活获取类对象的方式</p><pre><code class="dart">class Student &#123;  factory Student._stu(Student stu) &#123;    return Student(stu._school, stu.name, stu.age);  &#125;&#125;</code></pre><h3 id="8-9-初始化列表常用于设置-fianl-变量的值"><a href="#8-9-初始化列表常用于设置-fianl-变量的值" class="headerlink" title="8.9 初始化列表常用于设置 (fianl 变量的值)"></a>8.9 初始化列表常用于设置 (<code>fianl</code> 变量的值)</h3><ol><li>初始化列表会在构造方法体执行之前执行</li><li>使用逗号分隔初始化表达式</li><li>初始化列表常用于设置 <code>final</code> 变量的值</li></ol><pre><code class="dart">void main() &#123;  var person = new Person(&quot;Tom&quot;, 20, &quot;Male&quot;);&#125;class Person &#123;  String name;  int age;  final String gender;  Person(this.name, this.age, this.gender);  // 初始化列表  Person.withMap(Map map): gender = map[&quot;gender&quot;] &#123;    this.name = map[&quot;name&quot;];    this.age = map[&quot;age&quot;];  &#125;  // 或者  Person.withMap1(Map map): name = map[&quot;name&quot;], age = map[&quot;age&quot;], gender = map[&quot;gender&quot;];  void work() &#123;    print(&quot;work&quot;);  &#125;&#125;</code></pre><h3 id="8-10-静态成员"><a href="#8-10-静态成员" class="headerlink" title="8.10 静态成员"></a>8.10 静态成员</h3><ol><li>使用 <code>static</code> 关键字来实现类级别的变量和函数（不再属于对象级别）</li><li>静态成员不能访问非静态成员，非静态成员可以访问静态成员</li><li>类中的常量需要使用 <code>static const</code> 声明</li></ol><pre><code class="dart">void main() &#123;  var page = new Page();  // page.scrollDown();  Page.scrollDown();&#125;class Page &#123;  // 添加常量  static const int maxAge = 10;  static int currentPage = 1;  static void scrollDown() &#123;    currentPage = 1;    print(&quot;scrollDown&quot;);  &#125;  void scrollUp() &#123;    currentPage++;    print(&quot;scrollUp&quot;);  &#125;&#125;</code></pre><h3 id="8-11-对象操作符"><a href="#8-11-对象操作符" class="headerlink" title="8.11 对象操作符"></a>8.11 对象操作符</h3><ol><li>条件成员访问：<code>?.</code>（如果该操作符前边不为空，则继续向后执行，否则不继续执行）</li><li>类型转换：<code>as</code></li></ol><pre><code class="dart">void main() &#123;  var person;  person = &quot;&quot;;  person = new Person();  (person as Person).work();&#125;class Person &#123;  String name;  int age;  void work() &#123;    print(&quot;work...&quot;);  &#125;&#125;</code></pre><ol start="3"><li>是否指定类型：<code>is</code>，<code>is!</code></li></ol><pre><code class="dart">void main() &#123;  var person;  person = &quot;&quot;;  person = new Person();  if(person is Person) &#123;    person.work();  &#125;&#125;class Person &#123;  String name;  int age;  void work() &#123;    print(&quot;work...&quot;);  &#125;&#125;</code></pre><ol start="4"><li>级联操作：<code>..</code></li></ol><pre><code class="dart">void main() &#123;  var person = new Person();  person..name = &quot;Tom&quot; ..age = 20 ..work();  // 等价于  person.name = &quot;Tom&quot;;  person.age = 20;  person.work();&#125;class Person &#123;  String name;  int age;  void work() &#123;    print(&quot;work...&quot;);  &#125;&#125;</code></pre><h3 id="8-11-对象-call-方法"><a href="#8-11-对象-call-方法" class="headerlink" title="8.11 对象 call 方法"></a>8.11 对象 <code>call</code> 方法</h3><ul><li>如果类实现了 <code>call()</code> 方法，则该类的对象可以作为方法使用</li></ul><pre><code class="dart">void main() &#123;  var person = new Person();  // person(&quot;张三&quot;, 30);  print(person(&quot;张三&quot;, 30));&#125;class Person &#123;  String name;  int age;  // void call(String name, int age) &#123;  //   print(&quot;Name is $name, Age is $age&quot;);  // &#125;  String call(String name, int age) &#123;    return &quot;Name is $name, Age is $age&quot;;  &#125;&#125;</code></pre><h2 id="九、面向对象扩展"><a href="#九、面向对象扩展" class="headerlink" title="九、面向对象扩展"></a>九、面向对象扩展</h2><ul><li>继承，继承中的构造方法</li><li>抽象类</li><li>接口</li><li><code>Mixins</code>，操作符的覆写（操作符/运算符重载）</li></ul><h3 id="9-1-继承"><a href="#9-1-继承" class="headerlink" title="9.1 继承"></a>9.1 继承</h3><ol><li>使用关键字 <code>extends</code> 继承一个类</li><li>子类会继承父类可见的属性和方法（私有属性无法继承），不会继承构造方法</li><li>子类能够复写父类的方法、<code>getter</code> 和 <code>setter</code></li><li>单继承，多态性（例如可以重写 <code>toString</code> 方法）</li></ol><pre><code class="dart">// person.dartclass Person &#123;  String name;  int age;  String _birthday;  bool get isAudit =&gt; age &gt; 10;  void run() &#123;    print(&quot;Person run&quot;);  &#125;&#125;</code></pre><ul><li><em>**<a href="/override">@override </a> **</em> 表示下面的计算属性或方法是从父类中复写过来的，并不是自己的</li><li><strong><code>super.run();</code></strong>  <strong><em><code>super</code></em></strong> 表示在子类中调用父类的方法，相当于 <em><strong><code>this</code></strong></em></li></ul><pre><code class="dart">// student.dartimport &quot;person.dart&quot;;void main() &#123;  var student = new Student();  student.study();  student.name = &quot;Tom&quot;;  student.age = 16;  print(student.isAudit);  student.run();&#125;class Student extends Person &#123;  void study() &#123;    print(&quot;Student study...&quot;);  &#125;  // @override 表示下面的计算属性或方法是从父类中复写过来的，并不是自己的  @override  bool get isAudit =&gt; age &gt; 15;  @override  void run() &#123;    // super.run(); // super表示在子类中调用父类的方法    print(&quot;Student run...&quot;);  &#125;&#125;</code></pre><ul><li>多态</li></ul><pre><code class="dart">// 子类的实例可以赋值给父类的一个应用void main() &#123;    Person person = new Student();    if(person is Student) &#123;      person.study();    &#125;&#125;</code></pre><h3 id="9-2-继承中的构造方法"><a href="#9-2-继承中的构造方法" class="headerlink" title="9.2 继承中的构造方法"></a>9.2 继承中的构造方法</h3><ul><li>继承中的构造方法</li></ul><ol><li>子类中的构造方法默认会调用父类的无名无参的构造方法</li><li>如果父类没有无名无参的构造方法，则需要显示调用父类构造方法</li><li>在构造方法参数后使用 <code>:</code> 显示调用父类构造方法</li></ol><pre><code class="dart">void main() &#123;  var student = new Student(&quot;Tom&quot;);  print(student.name);&#125;class Person &#123;  String name;  Person(this.name);  Person.withName(this.name);&#125;class Student extends Person &#123;  int age;//  Student(String name) : super(name);  Student(String name) : super.withName(name);&#125;</code></pre><ul><li>构造方法的执行顺序</li></ul><ol><li>父类的构造方法在子类构造方法体开始执行的位置调用</li><li>如果有初始化列表，初始化列表会在父类构造方法之前执行</li></ol><pre><code class="dart">void main() &#123;  var student = new Student(&quot;Tom&quot;, &quot;Male&quot;);  print(student.name);&#125;class Person &#123;  String name;  Person(this.name);  Person.withName(this.name);&#125;class Student extends Person &#123;  int age;  final String gender;//  Student(String name) : super(name);  // 初始化列表必须放在显示调用父类构造方法的前面  Student(String name, String genderName) : gender = genderName, super.withName(name);&#125;</code></pre><h3 id="9-3-抽象类"><a href="#9-3-抽象类" class="headerlink" title="9.3 抽象类"></a>9.3 抽象类</h3><ol><li>抽象类使用关键字 <code>abstract</code> 表示，不能直接被实例化</li><li>抽象方法不用 <code>abstract</code> 修饰，无实现</li><li>抽象类可以没有抽象方法</li><li>有抽象方法的类一定得声明为抽象类</li></ol><p>抽象类更多用来作为接口使用</p><pre><code class="dart">void main() &#123;  var person = new Student();  person.run();&#125;abstract class Person &#123;  void run();&#125;class Student extends Person &#123;  @override  void run() &#123;    print(&quot;run...&quot;);  &#125;&#125;</code></pre><h3 id="9-4-接口"><a href="#9-4-接口" class="headerlink" title="9.4 接口"></a>9.4 接口</h3><ol><li>在 <code>dart</code> 中，类和接口是统一的，类就是接口</li><li>每个类都隐式的定义了一个包含所有实例成员的接口</li><li>如果是复用已有类的实现，使用继承（<code>extends</code>）</li><li>如果只是使用已有类的外在行为(一些行为)，则使用接口（<code>implements</code>）</li></ol><pre><code class="dart">void main() &#123;  var student = new Student();&#125;class Person &#123;  String name;  int get age =&gt; 18;  void run() &#123;    print(&quot;Person run...&quot;);  &#125;&#125;class Student implements Person &#123;  @override  String name;  @override  // TODO: implement age  int get age =&gt; 15;  @override  void run() &#123;    // TODO: implement run  &#125;&#125;</code></pre><ul><li>更好的写法，利用抽象类</li></ul><pre><code class="dart">void main() &#123;  var student = new Student();  student.run();&#125;abstract class Person &#123;  void run();&#125;class Student implements Person &#123;  @override  void run() &#123;    print(&quot;Student run...&quot;);  &#125;&#125;</code></pre><h3 id="9-5-Mixins"><a href="#9-5-Mixins" class="headerlink" title="9.5 Mixins"></a>9.5 <code>Mixins</code></h3><ol><li><code>Mixins</code> 类似于多继承，是在多类继承中重用一个类代码的方式</li></ol><pre><code class="dart">void main() &#123;  var d = new D();  d.a();  d.b();  d.c();&#125;class A &#123;  void a() &#123;    print(&quot;A.a()...&quot;);  &#125;&#125;class B &#123;  void a() &#123;    print(&quot;B.a()...&quot;);  &#125;  void b() &#123;    print(&quot;B.b()...&quot;);  &#125;&#125;class C &#123;  void a() &#123;    print(&quot;C.a()...&quot;);  &#125;  void b() &#123;    print(&quot;C.b()...&quot;);  &#125;  void c() &#123;    print(&quot;C.c()...&quot;);  &#125;&#125;// 必须先有继承，才能使用 Mixins；如果使用 Mixins 的几个类中有相同的方法，则处于最后一个的方法优先被调用class D extends A with B, C &#123;&#125;</code></pre><ol start="2"><li>作为 <code>Mixin</code> 的类不能有显示声明构造方法</li><li>作为 <code>Mixin</code> 的类只能继承自 <code>Object</code></li><li>使用关键字 <code>with</code> 连接一个或多个 <code>Mixin</code></li></ol><p>如果是由其它类组装而来的，没有自己的属性或方法，则可以简写</p><pre><code class="dart">void main() &#123;&#125;abstract class Engine &#123;  void work();&#125;class OilEngine implements Engine &#123;  @override  void work() &#123;    print(&quot;Work with qil...&quot;);  &#125;&#125;class ElectricEngine implements Engine &#123;  @override  void work() &#123;    print(&quot;Work with electric...&quot;);  &#125;&#125;class Tyre &#123;  String name;  void run() &#123;&#125;&#125;// 如果是由其它类组装而来的，没有自己的属性或方法，则可以简写class Car = Tyre with ElectricEngine;// 完整写法//class Car extends Tyre with ElectricEngine &#123;&#125;class Bus = Tyre with OilEngine;</code></pre><h3 id="9-6-操作符覆写-重载运算符-运算符重载"><a href="#9-6-操作符覆写-重载运算符-运算符重载" class="headerlink" title="9.6 操作符覆写(重载运算符/运算符重载)"></a>9.6 操作符覆写(重载运算符/运算符重载)</h3><ol><li>覆写操作符需要在类中定义</li></ol><pre><code class="dart">返回类型 operator 操作符 (参数1, 参数2, ...) &#123;    实现体...    return 返回值&#125;</code></pre><ol start="2"><li>如果覆写 <code>==</code> ，还需要覆写对象的 <code>hashCode</code> <code>getter</code> 方法</li><li>可覆写的操作符<br>| _<strong>&lt;**_ | _**+**_ | _**|**_ | _**[]**_ |<br>| :--- | :--- | :--- | :--- |<br>| _**&gt;</strong>_ | _<strong>/</strong>_ | _<strong>^</strong>_ | _<strong>[]=</strong>_ |<br>| _<strong>&lt;=**_ | _**<del>/<strong>_ | _</strong>&amp;<strong>_ | _</strong></del>**_ |<br>| _**&gt;=</strong>_ | _<strong>*</strong>_ | _**&lt;&lt;**_ | _**==**_ |<br>| _**-**_ | _**%**_ | &gt;&gt; | |</li></ol><pre><code class="dart">void main() &#123;  var person1 = new Person(18);  var person2 = new Person(20);  var person3 = new Person(20);  print(person1 &gt; person2);  print(person1[&quot;age&quot;]);  print(person2 == person3);&#125;class Person &#123;  int age;  Person(this.age);  // 覆写 &gt;  bool operator &gt;(Person person) &#123;    return this.age &gt; person.age;  &#125;  // 覆写 []  int operator [](String str) &#123;    if(&quot;age&quot; == str) &#123;      return age;    &#125;    return 0;  &#125;  // 覆写等号，重写hashCode，右键打开generate选项然后选择  @override  bool operator ==(Object other) =&gt;      identical(this, other) ||          other is Person &amp;&amp;              runtimeType == other.runtimeType &amp;&amp;              age == other.age;  @override  int get hashCode =&gt; age.hashCode;&#125;</code></pre><h2 id="十、枚举"><a href="#十、枚举" class="headerlink" title="十、枚举"></a>十、枚举</h2><ul><li>枚举</li></ul><ol><li>枚举是一种有穷序列集的数据类型</li><li>使用关键字 <code>enum</code> 定义一个枚举</li><li>常用于代替常量，控制语句等</li></ol><pre><code class="dart">void main() &#123;  var currentSeason = Season.spring;  print(currentSeason.index);  switch(currentSeason) &#123;    case Season.spring:      print(&quot;1-3月&quot;);      break;    case Season.summer:      print(&quot;4-6月&quot;);      break;    case Season.autumn:      print(&quot;7-9月&quot;);      break;    case Season.winter:      print(&quot;10-12月&quot;);      break;  &#125;&#125;enum Season &#123;  spring,  summer,  autumn,  winter&#125;</code></pre><ul><li><code>Dart</code> 枚举特性</li></ul><ol><li><code>index</code> 从 <code>0</code> 开始，依次累加</li><li>不能指定原始值</li><li>不能添加方法</li></ol><h2 id="十一、泛型"><a href="#十一、泛型" class="headerlink" title="十一、泛型"></a>十一、泛型</h2><ul><li>泛型</li></ul><ol><li><code>Dart</code> 中的类型是可选的，可使用泛型限定类型</li><li>使用泛型能够有效的减少代码重复</li></ol><ul><li>泛型的使用</li></ul><ol><li>类的泛型</li></ol><pre><code class="dart">void main() &#123;  var utils = new Utils&lt;String&gt;();  utils.put(&quot;element&quot;);&#125;class Utils&lt;T&gt; &#123;  T element;  void put(T element) &#123;    this.element = element;  &#125;&#125;</code></pre><ol start="2"><li>方法的泛型</li></ol><pre><code class="dart">void main() &#123;  var utils = new Utils();  utils.put&lt;String&gt;(&quot;element&quot;);&#125;class Utils &#123;  void put&lt;T&gt;(T element) &#123;    print(element);  &#125;&#125;</code></pre><h2 id="十二、库"><a href="#十二、库" class="headerlink" title="十二、库"></a>十二、库</h2><ul><li>常用库</li></ul><ol><li><code>Dart web</code> 应用通常使用 <code>dart:html</code> 库</li><li><code>dart:core</code> 库定义了 <code>num</code>, <code>int</code>, 和 <code>double</code> 类，这些类 定义一些操作数字的基础功能。</li><li>异步编程通常使用回调函数，但是 <code>Dart</code> 提供了另外的 选择： <a href="https://api.dartlang.org/stable/dart-async/Future-class.html" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>Future</strong></em></a> 和 <a href="https://api.dartlang.org/stable/dart-async/Stream-class.html" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>Stream</strong></em></a> 对象。 <code>Future</code> 和 <code>JavaScript</code> 中的 <code>Promise</code> 类似，代表在将来某个时刻会返回一个 结果。<code>Stream</code> 是一种用来获取一些列数据的方式，例如 <code>事件流</code>。 <code>Future</code>, <code>Stream</code>, 以及其他异步操作的类在 <a href="https://api.dartlang.org/stable/dart-async/dart-async-library.html" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>dart:async</strong></em></a> 库中。</li><li><code>Math</code> 库提供了常见的数学运算功能，例如 <code>sine</code> 和 <code>cosine</code>， <code>最大值</code>、<code>最小值等</code>，还有各种常量 例如 <code>pi</code> 和 <code>e</code> 等。<code>Math</code> 库中 的大部分函数都是顶级方法。导入 <code>dart:math</code> 就可以使用 <code>Math</code> 库了</li></ol><ul><li>如果导入的两个库具有冲突的标识符，则可以使用库的前缀来区分</li></ul><pre><code class="dart">import &#39;package:lib1/lib1.dart&#39;;import &#39;package:lib2/lib2.dart&#39; as lib2;// ...Element element1 = new Element();           // Uses Element from lib1.lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.</code></pre><ul><li>导入库的一部分</li></ul><p>如果你只使用库的一部分功能，则可以选择需要导入的 内容。例如：</p><pre><code class="dart">// Import only foo.import &#39;package:lib1/lib1.dart&#39; show foo;// Import all names EXCEPT foo.import &#39;package:lib2/lib2.dart&#39; hide foo;</code></pre><ul><li>延迟载入库</li></ul><p><code>Deferred loading</code> (也称之为 <code>lazy loading</code>) 可以让应用在需要的时候再 加载库。 下面是一些使用延迟加载库的场景：</p><ul><li>减少 <code>APP</code> 的启动时间。</li><li>执行 <code>A/B</code> 测试，例如 尝试各种算法的 不同实现。</li><li>加载很少使用的功能，例如可选的屏幕和对话框。</li></ul><p>要延迟加载一个库，需要先使用 <code>deferred as</code> 来 导入：</p><pre><code class="dart">import &#39;package:deferred/hello.dart&#39; deferred as hello;</code></pre><p>当需要使用的时候，使用库标识符调用 <code>loadLibrary()</code> 函数来加载库：</p><pre><code class="dart">greet() async &#123;  await hello.loadLibrary();  hello.printGreeting();&#125;</code></pre><p>在前面的代码， 使用 <code>await</code> 关键字暂停代码执行一直到库加载完成。 关于 <code>async</code> 和 <code>await</code> 的更多信息请参考 <a href="http://dart.goodev.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>异步支持</strong></em></a>。</p><p>在一个库上你可以多次调用 <code>loadLibrary()</code> 函数。 但是该库只是载入一次。</p><p>使用延迟加载库的时候，请注意一下问题：</p><ul><li>延迟加载库的常量在导入的时候是不可用的。 只有当库加载完毕的时候，库中常量才可以使用。</li><li>在导入文件的时候无法使用延迟库中的类型。 如果你需要使用类型，则考虑把接口类型移动到另外一个库中， 让两个库都分别导入这个接口库。</li><li><em><strong>Dart</strong></em> 隐含的把 <code>loadLibrary()</code> 函数导入到使用 <code>deferred as</code> 的命名空间中。 <code>loadLibrary()</code> 方法返回一个 <a href="http://dart.goodev.org/guides/libraries/library-tour#future" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>Future</strong></em></a>。</li></ul><h2 id="十三、异步支持"><a href="#十三、异步支持" class="headerlink" title="十三、异步支持"></a>十三、异步支持</h2><p><code>Dart</code> 库中有很多返回 <code>Future</code> 或者 <code>Stream</code> 对象的方法。 这些方法是 _异步的_： 这些函数在设置完基本的操作 后就返回了， 而无需等待操作执行完成。 例如读取一个文件，在打开文件后就返回了。</p><p>有两种方式可以使用 <code>Future</code> 对象中的 数据：</p><ul><li>使用 <code>async</code> 和 <code>await</code></li><li>使用 <a href="http://dart.goodev.org/guides/libraries/library-tour#future" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>Future API</strong></em></a></li></ul><p>同样，从 <code>Stream</code> 中获取数据也有两种方式：</p><ul><li>使用 <code>async</code> 和一个 异步 <code>for</code> 循环 (<code>await for</code>)</li><li>使用 <a href="http://dart.goodev.org/guides/libraries/library-tour#stream" target="_blank" rel="noopener external nofollow noreferrer"><em><strong>Stream API</strong></em></a></li></ul><p><strong>1.</strong> 要使用 <code>await</code>，其方法必须带有 <code>async</code> 关键字：</p><pre><code class="dart">checkVersion() async &#123;  var version = await lookUpVersion();  if (version == expectedVersion) &#123;    // Do something.  &#125; else &#123;    // Do something else.  &#125;&#125;</code></pre><p><strong>2.</strong> 可以使用 <code>try</code>, <code>catch</code>, 和 <code>finally</code> 来处理使用 <code>await</code> 的异常：</p><pre><code class="dart">try &#123;  server = await HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, 4044);&#125; catch (e) &#123;  // React to inability to bind to the port...&#125;</code></pre><h3 id="13-1-声明异步方法"><a href="#13-1-声明异步方法" class="headerlink" title="13.1 声明异步方法"></a>13.1 声明异步方法</h3><p>一个 <code>async</code> 方法是函数体被标记为 <code>async</code> 的方法。 虽然异步方法的执行可能需要一定时间，但是 异步方法立刻返回 - 在方法体还没执行之前就返回了。</p><pre><code class="dart">checkVersion() async &#123;  // ...&#125;lookUpVersion() async =&gt; /* ... */;</code></pre><p>在一个方法上添加 <code>async</code> 关键字，则这个方法返回值为 <code>Future</code>。 例如，下面是一个返回字符串 的同步方法：</p><pre><code class="dart">String lookUpVersionSync() =&gt; &#39;1.0.0&#39;;</code></pre><p>如果使用 <code>async</code> 关键字，则该方法 返回一个 <code>Future</code>，并且 认为该函数是一个耗时的操作。</p><pre><code class="dart">Future&lt;String&gt; lookUpVersion() async =&gt; &#39;1.0.0&#39;;</code></pre><p>有时候，你的算法要求调用很多异步方法，并且等待 所有方法完成后再继续执行。使用 <a href="https://api.dartlang.org/stable/dart-async/Future/wait.html" target="_blank" rel="noopener external nofollow noreferrer"><code>Future.wait()</code></a> 这个静态函数来管理多个 <code>Future</code> 并等待所有 <code>Future</code> 执行完成。</p><pre><code class="dart">Future deleteDone = deleteLotsOfFiles();Future copyDone = copyLotsOfFiles();Future checksumDone = checksumLotsOfOtherFiles();Future.wait([deleteDone, copyDone, checksumDone])    .then((List values) &#123;      print(&#39;Done with all the long steps&#39;);    &#125;);</code></pre><h3 id="13-2-使用-await-表达式"><a href="#13-2-使用-await-表达式" class="headerlink" title="13.2 使用 await 表达式"></a>13.2 使用 <code>await</code> 表达式</h3><p>在一个异步方法内可以使用多次 <code>await</code> 表达式。 例如，下面的示例使用了三次 <code>await</code> 表达式 来执行相关的功能：</p><pre><code class="dart">var entrypoint = await findEntrypoint();var exitCode = await runExecutable(entrypoint, args);await flushThenExit(exitCode);</code></pre><p>在 <code>await expression</code> 中， <code>expression</code> 的返回值通常是一个 <code>Future</code>； 如果返回的值不是 <code>Future</code>，则 <code>Dart</code> 会自动把该值放到 <code>Future</code> 中返回。 <code>Future</code> 对象代表返回一个对象的承 (<code>promise</code>)。 <code>await expression</code> 执行的结果为这个返回的对象。 <code>await expression</code> 会阻塞住，直到需要的对象返回为止。</p><p><strong>如果 <code>await</code> 无法正常使用，请确保是在一个 <code>async</code> 方法中。</strong> 例如要在 <code>main()</code> 方法中使用 <code>await</code>， 则 <code>main()</code> 方法的函数体必须标记为 <code>async</code>：</p><pre><code class="dart">main() async &#123;  checkVersion();  print(&#39;In main: version is $&#123;await lookUpVersion()&#125;&#39;);&#125;</code></pre><h3 id="13-3-在循环中使用异步"><a href="#13-3-在循环中使用异步" class="headerlink" title="13.3 在循环中使用异步"></a>13.3 在循环中使用异步</h3><p>异步 <code>for</code> 循环具有如下的形式：</p><pre><code class="dart">await for (variable declaration in expression) &#123;  // Executes each time the stream emits a value.&#125;</code></pre><p>上面 <code>expression</code> 返回的值必须是 <code>Stream</code> 类型的。 执行流程如下：</p><ol><li>等待直到 <em><strong>stream</strong></em> 返回一个数据</li><li>使用 <code>stream</code> 返回的参数 执行 <code>for</code> 循环代码，</li><li>重复执行 <code>1</code> 和 <code>2</code> 直到 <code>stream</code> 数据返回完毕。</li></ol><p>使用 <code>break</code> 或者 <code>return</code> 语句可以 停止接收 <code>stream</code> 的数据， 这样就跳出了 <code>for</code> 循环并且 从 <code>stream</code> 上取消注册了。</p><p><strong>如果异步 <code>for</code> 循环不能正常工作， 确保是在一个 <code>async</code> 方法中使用。</strong> 例如，要想在 <code>main()</code> 方法中使用异步 <code>for</code> 循环，则需要把 <code>main()</code> 方法的函数体标记为 <code>async</code>：</p><pre><code class="dart">main() async &#123;  ...  await for (var request in requestServer) &#123;    handleRequest(request);  &#125;  ...&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用工具和插件</title>
      <link href="%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6%E6%94%B6%E8%97%8F/"/>
      <url>%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6%E6%94%B6%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="一、Can-I-Use-兼容性查询"><a href="#一、Can-I-Use-兼容性查询" class="headerlink" title="一、Can I Use 兼容性查询"></a>一、Can I Use 兼容性查询</h3><p><a href="https://www.caniuse.com/" target="_blank" rel="noopener external nofollow noreferrer">Can I Use</a></p><h3 id="二、Stackoverflow-技术文档"><a href="#二、Stackoverflow-技术文档" class="headerlink" title="二、Stackoverflow 技术文档"></a>二、Stackoverflow 技术文档</h3><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener external nofollow noreferrer">Stackoverflow</a></p><h3 id="三、GitBook-记录一切"><a href="#三、GitBook-记录一切" class="headerlink" title="三、GitBook 记录一切"></a>三、GitBook 记录一切</h3><p><a href="https://www.gitbook.com/" target="_blank" rel="noopener external nofollow noreferrer">gitbook</a></p><h3 id="四、Serverless-微服务"><a href="#四、Serverless-微服务" class="headerlink" title="四、Serverless 微服务"></a>四、Serverless 微服务</h3><p><a href="https://www.serverless.com/cn/" target="_blank" rel="noopener external nofollow noreferrer">serverless</a></p><h3 id="五、在线绘图工具"><a href="#五、在线绘图工具" class="headerlink" title="五、在线绘图工具"></a>五、在线绘图工具</h3><p><a href="https://app.diagrams.net/" target="_blank" rel="noopener external nofollow noreferrer">diagrams</a></p><h3 id="六、Css-重置的现代化替代方案"><a href="#六、Css-重置的现代化替代方案" class="headerlink" title="六、Css 重置的现代化替代方案"></a>六、Css 重置的现代化替代方案</h3><p><a href="https://github.com/necolas/normalize.css/" target="_blank" rel="noopener external nofollow noreferrer">normalize.css</a></p><h3 id="七、AI-生成常用单词的搜索工具"><a href="#七、AI-生成常用单词的搜索工具" class="headerlink" title="七、AI 生成常用单词的搜索工具"></a>七、AI 生成常用单词的搜索工具</h3><p><a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener external nofollow noreferrer">codeIf</a></p><h3 id="八、将本机映射到外网服务器"><a href="#八、将本机映射到外网服务器" class="headerlink" title="八、将本机映射到外网服务器"></a>八、将本机映射到外网服务器</h3><p><a href="https://ngrok.com/" target="_blank" rel="noopener external nofollow noreferrer">ngrok</a></p><h3 id="九、创建代码截图"><a href="#九、创建代码截图" class="headerlink" title="九、创建代码截图"></a>九、创建代码截图</h3><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=pnp.polacode" target="_blank" rel="noopener external nofollow noreferrer">Polacode</a></li><li><a href="https://carbon.now.sh/" target="_blank" rel="noopener external nofollow noreferrer">Carbon</a></li></ul><h3 id="十、代码格式化插件"><a href="#十、代码格式化插件" class="headerlink" title="十、代码格式化插件"></a>十、代码格式化插件</h3><p><a href="https://prettier.io/docs/en/install.html" target="_blank" rel="noopener external nofollow noreferrer">prettier</a></p><h3 id="十一、好用的-Markdown-编辑器"><a href="#十一、好用的-Markdown-编辑器" class="headerlink" title="十一、好用的 Markdown 编辑器"></a>十一、好用的 Markdown 编辑器</h3><p><a href="https://marktext.app/" target="_blank" rel="noopener external nofollow noreferrer">Mark Text</a></p><h3 id="十二、网易云音乐-Node-js-Api"><a href="#十二、网易云音乐-Node-js-Api" class="headerlink" title="十二、网易云音乐 Node.js Api"></a>十二、网易云音乐 Node.js Api</h3><p><a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/" target="_blank" rel="noopener external nofollow noreferrer">官方地址</a></p><h3 id="十三、字体图标库"><a href="#十三、字体图标库" class="headerlink" title="十三、字体图标库"></a>十三、字体图标库</h3><h4 id="fontawesome"><a href="#fontawesome" class="headerlink" title="fontawesome"></a>fontawesome</h4><p><a href="http://www.fontawesome.com.cn/faicons/" target="_blank" rel="noopener external nofollow noreferrer">图标库</a></p><h4 id="IconFont"><a href="#IconFont" class="headerlink" title="IconFont"></a>IconFont</h4><p><a href="https://www.iconfont.cn/" target="_blank" rel="noopener external nofollow noreferrer">阿里云矢量图标库</a></p><h3 id="十四、接口测试工具"><a href="#十四、接口测试工具" class="headerlink" title="十四、接口测试工具"></a>十四、接口测试工具</h3><ul><li><a href="https://postwoman.io/" target="_blank" rel="noopener external nofollow noreferrer">PostWoman</a></li><li><a href="https://www.postman.com/" target="_blank" rel="noopener external nofollow noreferrer">PostMan</a></li></ul><h3 id="十五、抓包工具"><a href="#十五、抓包工具" class="headerlink" title="十五、抓包工具"></a>十五、抓包工具</h3><ul><li>Mac <a href="https://www.charlesproxy.com/" target="_blank" rel="noopener external nofollow noreferrer">Charles</a></li><li>Windows <a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener external nofollow noreferrer">fiddler</a></li></ul><h3 id="十六、静态网站资源自动部署"><a href="#十六、静态网站资源自动部署" class="headerlink" title="十六、静态网站资源自动部署"></a>十六、静态网站资源自动部署</h3><p><a href="https://app.netlify.com/teams/conjuringwxq/sites" target="_blank" rel="noopener external nofollow noreferrer">netlify</a></p><h3 id="十七、在线代码编辑器"><a href="#十七、在线代码编辑器" class="headerlink" title="十七、在线代码编辑器"></a>十七、在线代码编辑器</h3><ul><li><a href="https://stackblitz.com/" target="_blank" rel="noopener external nofollow noreferrer">stackblitz</a></li><li><a href="https://codesandbox.io/" target="_blank" rel="noopener external nofollow noreferrer">codesandbox</a></li><li><a href="https://codepen.io/" target="_blank" rel="noopener external nofollow noreferrer">codepen</a></li></ul><h3 id="十八、Mac-Iterm2-终端美化工具"><a href="#十八、Mac-Iterm2-终端美化工具" class="headerlink" title="十八、Mac Iterm2 终端美化工具"></a>十八、Mac Iterm2 终端美化工具</h3><p><a href="https://ohmyz.sh/" target="_blank" rel="noopener external nofollow noreferrer">Iterm2 美化工具</a></p><h3 id="十九、CDN"><a href="#十九、CDN" class="headerlink" title="十九、CDN"></a>十九、CDN</h3><p><a href="https://www.bootcdn.cn/" target="_blank" rel="noopener external nofollow noreferrer">BootCDN</a></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="1-常用插件"><a href="#1-常用插件" class="headerlink" title="1. 常用插件"></a>1. 常用插件</h3><h4 id="一、轮播图"><a href="#一、轮播图" class="headerlink" title="一、轮播图"></a>一、轮播图</h4><p><a href="https://www.swiper.com.cn/" target="_blank" rel="noopener external nofollow noreferrer">Swiper</a></p><h4 id="二、视频播放器"><a href="#二、视频播放器" class="headerlink" title="二、视频播放器"></a>二、视频播放器</h4><p><a href="http://dplayer.js.org/zh/" target="_blank" rel="noopener external nofollow noreferrer">dPlayer</a></p><h4 id="三、大图预览，大图弹窗"><a href="#三、大图预览，大图弹窗" class="headerlink" title="三、大图预览，大图弹窗"></a>三、大图预览，大图弹窗</h4><p><a href="https://fengyuanchen.github.io/viewerjs/" target="_blank" rel="noopener external nofollow noreferrer">Viewer.js</a></p><p><a href="https://photoswipe.com/" target="_blank" rel="noopener external nofollow noreferrer">PhotoSwipe</a></p><h4 id="四、拖拽列表"><a href="#四、拖拽列表" class="headerlink" title="四、拖拽列表"></a>四、拖拽列表</h4><p><a href="http://www.sortablejs.com/" target="_blank" rel="noopener external nofollow noreferrer">Sortable.js</a></p><h4 id="五、格式化时间"><a href="#五、格式化时间" class="headerlink" title="五、格式化时间"></a>五、格式化时间</h4><p><a href="https://momentjs.com/" target="_blank" rel="noopener external nofollow noreferrer">Moment.js</a></p><p><a href="https://day.js.org/zh-CN/" target="_blank" rel="noopener external nofollow noreferrer">Day.js</a></p><h4 id="六、Mddir-快速生成项目结构说明"><a href="#六、Mddir-快速生成项目结构说明" class="headerlink" title="六、Mddir 快速生成项目结构说明"></a>六、Mddir 快速生成项目结构说明</h4><blockquote><ol><li><code>$ npm install mddir -g</code></li><li>进入想生成目录的项目路径</li><li>执行 <code>mddir</code></li><li>将生成的 <code>directoryList.md</code> 文件内容复制即可</li></ol></blockquote><h4 id="七、mockJS"><a href="#七、mockJS" class="headerlink" title="七、mockJS"></a>七、mockJS</h4><p><a href="http://mockjs.com/" target="_blank" rel="noopener external nofollow noreferrer">文档</a></p><ul><li>安装：<code>npm install mockjs --save-dev</code></li><li>方式 1：<code>创建data.json文件，然后引入</code></li></ul><pre><code class="javascript">import Mock from &quot;mockjs&quot;;import data from &quot;./data.json&quot;;Mock.mock(&quot;http://www.weichuang.com/getList&quot;, &#123;  data: data.list&#125;);</code></pre><ul><li>方式 2：限定条件</li></ul><pre><code class="javascript">Mock.mock(&quot;http://www.weichuang.com/getUser&quot;, &#123;  &quot;name|2&quot;: &quot;weichuang&quot;,  &quot;age|18-35&quot;: 20 //这里的20代表数据类型&#125;);</code></pre><ul><li>方式 3：正则表达式</li></ul><pre><code class="javascript">Mock.mock(&quot;http://www.weichuang.com/regexp&quot;, &#123;  regexp1: /[a-z][A-Z][0-9]/,  regexp2: /\d&#123;5,10&#125;/ //    重复5-10次&#125;);</code></pre><ul><li>方式 4：占位符</li></ul><pre><code class="javascript">Mock.mock(&quot;http://www.weichuang.com/list&quot;, &#123;  &quot;info|10-20&quot;: [    &#123;      // 按照以下规则生成10-20条数据      &quot;index|+1&quot;: 1,      name: &quot;@first @last&quot;,      id: &quot;@integer(10000, 99999)&quot;,      date: &quot;@datetime&quot;,      img: &#39;@image(&quot;200*200&quot;)&#39;,      text: &quot;@sentence(6, 22)&quot;    &#125;  ]&#125;);</code></pre><ul><li>方式 5：<code>Mock.Random</code></li></ul><pre><code class="javascript">let Random = Mock.Random;let productData = req =&gt; &#123;  let productList = []; // 存放农机信息的数组  for (let i = 0; i &lt; 100; i++) &#123;    let product = &#123;      name: Random.ctitle(5, 20),      img: Random.dataImage(&quot;100x100&quot;, &quot;农机&quot; + Random.integer(1, 100)),      price: Random.integer(1000, 10000),      owner: Random.cname()    &#125;;    productList.push(product);  &#125;  return productList;&#125;;Mock.mock(&quot;http://www.weichuang.com/getVarietyItem&quot;, productData);</code></pre><h4 id="八、数据请求"><a href="#八、数据请求" class="headerlink" title="八、数据请求"></a>八、数据请求</h4><p><a href="http://www.axios-js.com/docs/" target="_blank" rel="noopener external nofollow noreferrer">axios</a></p><h4 id="九、剪切板"><a href="#九、剪切板" class="headerlink" title="九、剪切板"></a>九、剪切板</h4><p><a href="http://www.clipboardjs.cn/" target="_blank" rel="noopener external nofollow noreferrer">clipboardjs</a></p><h4 id="十、markdown-渲染"><a href="#十、markdown-渲染" class="headerlink" title="十、markdown 渲染"></a>十、markdown 渲染</h4><p><a href="https://github.com/markedjs/marked" target="_blank" rel="noopener external nofollow noreferrer">marked</a></p><h4 id="十一、代码高亮"><a href="#十一、代码高亮" class="headerlink" title="十一、代码高亮"></a>十一、代码高亮</h4><p><a href="https://highlightjs.org/" target="_blank" rel="noopener external nofollow noreferrer">highlight.js</a></p><h4 id="十二、加密"><a href="#十二、加密" class="headerlink" title="十二、加密"></a>十二、加密</h4><p><a href="https://github.com/brix/crypto-js" target="_blank" rel="noopener external nofollow noreferrer">crypto-js</a></p><h4 id="十三、组件库"><a href="#十三、组件库" class="headerlink" title="十三、组件库"></a>十三、组件库</h4><p><a href="https://v4.bootcss.com/" target="_blank" rel="noopener external nofollow noreferrer">BootStrap</a></p><h4 id="十四、浏览器进度条"><a href="#十四、浏览器进度条" class="headerlink" title="十四、浏览器进度条"></a>十四、浏览器进度条</h4><p><a href="https://ricostacruz.com/nprogress/" target="_blank" rel="noopener external nofollow noreferrer">NProgress</a></p><h3 id="2-Vue-相关"><a href="#2-Vue-相关" class="headerlink" title="2. Vue 相关"></a>2. Vue 相关</h3><h4 id="一、官网"><a href="#一、官网" class="headerlink" title="一、官网"></a>一、官网</h4><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener external nofollow noreferrer">vue</a></p><h4 id="二、后台管理"><a href="#二、后台管理" class="headerlink" title="二、后台管理"></a>二、后台管理</h4><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/" target="_blank" rel="noopener external nofollow noreferrer">vue-element-admin</a></p><p><a href="https://d2.pub/zh/doc/d2-admin/" target="_blank" rel="noopener external nofollow noreferrer">D2-admin</a></p><h4 id="三、SSR"><a href="#三、SSR" class="headerlink" title="三、SSR"></a>三、SSR</h4><p><a href="https://nuxtjs.org/" target="_blank" rel="noopener external nofollow noreferrer">nuxt.js</a></p><h4 id="四、组件库"><a href="#四、组件库" class="headerlink" title="四、组件库"></a>四、组件库</h4><ul><li><a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener external nofollow noreferrer">element-ui</a></li><li><a href="https://www.antdv.com/docs/vue/introduce-cn/" target="_blank" rel="noopener external nofollow noreferrer">ant-design-vue</a></li><li><a href="https://www.iviewui.com/docs/introduce" target="_blank" rel="noopener external nofollow noreferrer">iview</a></li><li><a href="https://youzan.github.io/vant/?source=vuejsorg#/zh-CN/" target="_blank" rel="noopener external nofollow noreferrer">vant</a></li></ul><h4 id="五、vue-表单验证"><a href="#五、vue-表单验证" class="headerlink" title="五、vue 表单验证"></a>五、vue 表单验证</h4><p><a href="https://vuelidate.js.org/" target="_blank" rel="noopener external nofollow noreferrer">vuelidate</a></p><h4 id="六、vue-轮播图"><a href="#六、vue-轮播图" class="headerlink" title="六、vue 轮播图"></a>六、vue 轮播图</h4><p><a href="https://github.surmon.me/vue-awesome-swiper/" target="_blank" rel="noopener external nofollow noreferrer">vue-awesome-swiper</a></p><h4 id="七、vue-大图预览"><a href="#七、vue-大图预览" class="headerlink" title="七、vue 大图预览"></a>七、vue 大图预览</h4><p><a href="https://mirari.cc/v-viewer/" target="_blank" rel="noopener external nofollow noreferrer">v-viewer</a></p><h4 id="八、图片懒加载"><a href="#八、图片懒加载" class="headerlink" title="八、图片懒加载"></a>八、图片懒加载</h4><p><a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener external nofollow noreferrer">vue-lazyload</a></p><h4 id="九、拖拽"><a href="#九、拖拽" class="headerlink" title="九、拖拽"></a>九、拖拽</h4><p><a href="https://sortablejs.github.io/Vue.Draggable/#/simple" target="_blank" rel="noopener external nofollow noreferrer">vue-draggable</a></p><h3 id="3-React-相关"><a href="#3-React-相关" class="headerlink" title="3. React 相关"></a>3. React 相关</h3><h4 id="一、官网-1"><a href="#一、官网-1" class="headerlink" title="一、官网"></a>一、官网</h4><p><a href="https://react.docschina.org/" target="_blank" rel="noopener external nofollow noreferrer">react</a></p><p><a href="https://reactrouter.com/" target="_blank" rel="noopener external nofollow noreferrer">react-router</a></p><h4 id="二、SSR"><a href="#二、SSR" class="headerlink" title="二、SSR"></a>二、SSR</h4><p><a href="https://nextjs.frontendx.cn/" target="_blank" rel="noopener external nofollow noreferrer">next.js</a></p><h4 id="三、组件库"><a href="#三、组件库" class="headerlink" title="三、组件库"></a>三、组件库</h4><ul><li><a href="https://ant.design/index-cn" target="_blank" rel="noopener external nofollow noreferrer">antd</a></li></ul><h4 id="四、脚手架"><a href="#四、脚手架" class="headerlink" title="四、脚手架"></a>四、脚手架</h4><p><a href="https://create-react-app.dev/" target="_blank" rel="noopener external nofollow noreferrer">create-react-app</a></p><h4 id="五、可拔插渐进式框架"><a href="#五、可拔插渐进式框架" class="headerlink" title="五、可拔插渐进式框架"></a>五、可拔插渐进式框架</h4><p><a href="https://umijs.org/zh-CN" target="_blank" rel="noopener external nofollow noreferrer">umi</a></p><h4 id="六、react-hooks-库"><a href="#六、react-hooks-库" class="headerlink" title="六、react hooks 库"></a>六、react hooks 库</h4><p><a href="https://ahooks.js.org/zh-CN" target="_blank" rel="noopener external nofollow noreferrer">ahooks</a></p><h4 id="七、react-状态管理"><a href="#七、react-状态管理" class="headerlink" title="七、react 状态管理"></a>七、react 状态管理</h4><p><a href="https://dvajs.com/" target="_blank" rel="noopener external nofollow noreferrer">dva</a></p><h4 id="八、轮播图"><a href="#八、轮播图" class="headerlink" title="八、轮播图"></a>八、轮播图</h4><p><a href="https://react-slick.neostack.com/docs/example/simple-slider" target="_blank" rel="noopener external nofollow noreferrer">React Slick</a></p><h4 id="九、canvas-类库"><a href="#九、canvas-类库" class="headerlink" title="九、canvas 类库"></a>九、canvas 类库</h4><p><a href="http://fabricjs.com/" target="_blank" rel="noopener external nofollow noreferrer">fabric.js</a></p><h4 id="十、可视化"><a href="#十、可视化" class="headerlink" title="十、可视化"></a>十、可视化</h4><p><a href="https://echarts.apache.org/en/index.html" target="_blank" rel="noopener external nofollow noreferrer">echarts</a></p><h4 id="十一、直接从浏览器-React-组件快速跳转到本地-IDE-查看源代码"><a href="#十一、直接从浏览器-React-组件快速跳转到本地-IDE-查看源代码" class="headerlink" title="十一、直接从浏览器 React 组件快速跳转到本地 IDE 查看源代码!"></a>十一、直接从浏览器 React 组件快速跳转到本地 IDE 查看源代码!</h4><p><a href="https://react-dev-inspector.zthxxx.me/" target="_blank" rel="noopener external nofollow noreferrer">react-dev-inspector</a></p><h4 id="十二、管理对文档头部的所有更改"><a href="#十二、管理对文档头部的所有更改" class="headerlink" title="十二、管理对文档头部的所有更改"></a>十二、管理对文档头部的所有更改</h4><p><a href="https://github.com/nfl/react-helmet" target="_blank" rel="noopener external nofollow noreferrer">react-helmet</a></p><p><a href="https://github.com/staylor/react-helmet-async" target="_blank" rel="noopener external nofollow noreferrer">react-helmet-async</a></p><p>十三、拖拽</p><p><a href="https://github.com/atlassian/react-beautiful-dnd/" target="_blank" rel="noopener external nofollow noreferrer">react-beautiful-dnd</a></p><p><a href="https://github.com/react-dnd/react-dnd" target="_blank" rel="noopener external nofollow noreferrer">react-dnd</a></p><p><a href="https://github.com/clauderic/react-sortable-hoc" target="_blank" rel="noopener external nofollow noreferrer">react-sortable-hoc</a></p><h3 id="4-Angular-相关"><a href="#4-Angular-相关" class="headerlink" title="4. Angular 相关"></a>4. Angular 相关</h3><h4 id="一、官网-2"><a href="#一、官网-2" class="headerlink" title="一、官网"></a>一、官网</h4><p><a href="https://angular.io/" target="_blank" rel="noopener external nofollow noreferrer">angular</a></p><h3 id="5-小程序"><a href="#5-小程序" class="headerlink" title="5. 小程序"></a>5. 小程序</h3><h4 id="一、框架"><a href="#一、框架" class="headerlink" title="一、框架"></a>一、框架</h4><p><a href="https://taro.aotu.io/" target="_blank" rel="noopener external nofollow noreferrer">taro</a></p><h3 id="6-单元测试"><a href="#6-单元测试" class="headerlink" title="6. 单元测试"></a>6. 单元测试</h3><h4 id="一、方案一"><a href="#一、方案一" class="headerlink" title="一、方案一"></a>一、方案一</h4><p><a href="https://jestjs.io/en/" target="_blank" rel="noopener external nofollow noreferrer">jest 测试框架</a></p><h4 id="二、方案二"><a href="#二、方案二" class="headerlink" title="二、方案二"></a>二、方案二</h4><p><a href="https://mochajs.org/" target="_blank" rel="noopener external nofollow noreferrer">mocha 测试框架</a> + <a href="https://www.chaijs.com/" target="_blank" rel="noopener external nofollow noreferrer">chai 断言库</a></p><h3 id="7-微前端"><a href="#7-微前端" class="headerlink" title="7. 微前端"></a>7. 微前端</h3><h4 id="一、框架-1"><a href="#一、框架-1" class="headerlink" title="一、框架"></a>一、框架</h4><p><a href="https://qiankun.umijs.org/" target="_blank" rel="noopener external nofollow noreferrer">qiankun</a></p><h3 id="8-App"><a href="#8-App" class="headerlink" title="8. App"></a>8. App</h3><h4 id="一、官网-3"><a href="#一、官网-3" class="headerlink" title="一、官网"></a>一、官网</h4><p><a href="https://reactnative.dev/" target="_blank" rel="noopener external nofollow noreferrer">react-native 英文官网</a></p><p><a href="https://www.reactnative.cn/" target="_blank" rel="noopener external nofollow noreferrer">react-native 中文官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 常用工具和插件 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
