---
title: 归并排序
---

## 简介

归并排序就是利用分冶的思想，采用递归的形式，对元素进行排序

当我们有两个长度为 n 的有序数组时，可以通过两个指针的移动，在 O(n) 的时间复杂度内，快速将它们合并成一个有序数组。而这两个长度为 n 的有序数组，也是可以通过两个 n/2 的有序数组合并得来。因此，只要对数组不断进行分冶，就可以把一个无序数组变成有序

由于在数组拆分时用到了递归，而对数组组合的过程用到了合并，因此命名：归并排序

## 步骤

- 首先将数组拆分成左右两部分
- 对于左边部分，继续拆分成左右两部分，直到无法拆分，此时将最小单元左侧部分保持有序，最小单元右侧部分也保持有序，然后对排序后的这两部分进行合并
- 对于右侧部分，同左边部分一样拆分和合并
- 最后合并左右两部分的数组

## 时间复杂度和空间复杂度

## 实现

```py
def Merge(a, start, mid, end):
    # 临时列表
    tmp = []
    # 两个游标，分别从两段区间的起点开始
    l = start
    r = mid + 1
    # 当两个区间都未到达区间右端点时
    while l <= mid and r <= end:
        # 判断，将小的值插入临时列表
        if a[l] <= a[r]:
            tmp.append(a[l])
            # 对相应游标进行自增
            l += 1
        else:
            tmp.append(a[r])
            # 对相应游标进行自增
            r += 1
    # 当跳出循环时，将剩余的部分直接塞入临时列表
    tmp.extend(a[l : mid + 1])
    tmp.extend(a[r : end + 1])

    # 把临时列表的值，拷贝回原列表 a
    for i in range(start, end + 1):
        a[i] = tmp[i - start]
    # 打印本次合并结果
    print(start, end, tmp)

# 递归函数
def MergeSort(a, start, end):
    # 若待排序元素只有一个则直接返回
    if start == end:
        return
    # 否则计算出中点 mid
    mid = (start + end) // 2
    # 对左端点 start 到中点 mid 的元素执行一次归并排序
    MergeSort(a, start, mid)
    # 对中点 mid + 1 到右端点 end 的元素执行一次归并排序
    MergeSort(a, mid + 1, end)
    # 以上两次归并排序产生了两个有序数组，最后调用 Merge 进行归并排序
    Merge(a, start, mid, end)

# 测试
a = [8, 5, 6, 4, 3, 7, 10, 2]
MergeSort(a, 0, 7)

# 输出
0 1 [5, 8]
2 3 [4, 6]
0 3 [4, 5, 6, 8]
4 5 [3, 7]
6 7 [2, 10]
4 7 [2, 3, 7, 10]
0 7 [2, 3, 4, 5, 6, 7, 8, 10]
```
