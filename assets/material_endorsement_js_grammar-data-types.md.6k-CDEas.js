import{_ as e,b as a,o as r,a8 as t}from"./chunks/framework.BwoOF8WG.js";const m=JSON.parse('{"title":"语法和数据类型","description":"","frontmatter":{},"headers":[],"relativePath":"material/endorsement/js/grammar-data-types.md","filePath":"material/endorsement/js/grammar-data-types.md"}'),o={name:"material/endorsement/js/grammar-data-types.md"},l=t('<h1 id="语法和数据类型" tabindex="-1">语法和数据类型 <a class="header-anchor" href="#语法和数据类型" aria-label="Permalink to &quot;语法和数据类型&quot;">​</a></h1><h2 id="声明" tabindex="-1">声明 <a class="header-anchor" href="#声明" aria-label="Permalink to &quot;声明&quot;">​</a></h2><h3 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-label="Permalink to &quot;变量声明&quot;">​</a></h3><ul><li>var：声明一个变量，可选初始化一个值。</li><li>let：声明一个块作用域的局部变量，可选初始化一个值。</li><li>const：声明一个块作用域的只读常量。</li></ul><h3 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h3><ul><li>在函数之外声明的变量，叫做<strong>全局变量</strong>，因为它可被当前文档中的任何其他代码所访问。</li><li>在函数内部声明的变量，叫做<strong>局部变量</strong>，因为它只能在当前函数的内部访问。</li><li>ES6 之前的 JavaScript 没有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#%E8%AF%AD%E5%8F%A5%E5%9D%97" target="_blank" rel="noreferrer"><strong>语句块</strong></a><strong>作用域</strong>；相反，语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量。</li></ul><h3 id="变量提升" tabindex="-1">变量提升 <a class="header-anchor" href="#变量提升" aria-label="Permalink to &quot;变量提升&quot;">​</a></h3><ul><li>在 ES6 中，let 和 const 同样会被提升变量到<strong>代码块</strong>的顶部但是<strong>不会被赋予初始值</strong>。</li><li>在变量声明之前引用这个变量，将抛出<strong>引用错误（ReferenceError）</strong>。</li><li>这个变量将从代码块一开始的时候就处在一个“<strong>暂时性死区</strong>”，<strong>直到这个变量被声明为止</strong>。</li></ul><h3 id="函数提升" tabindex="-1">函数提升 <a class="header-anchor" href="#函数提升" aria-label="Permalink to &quot;函数提升&quot;">​</a></h3><p>对于函数来说，<strong>只有函数声明会被提升</strong>到顶部，而<strong>函数表达式不会被提升</strong>。</p><h3 id="全局变量" tabindex="-1">全局变量 <a class="header-anchor" href="#全局变量" aria-label="Permalink to &quot;全局变量&quot;">​</a></h3><ul><li>全局变量是全局对象的属性。在网页中，（译注：缺省的）全局对象是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noreferrer">window</a> ，所以可以用形如 window.variable 的语法来设置和访问全局变量。</li><li>可以通过指定 window 或 frame 的名字，在当前 window 或 frame 访问另一个 window 或 frame 中声明的变量。例如，在文档里声明一个叫 phoneNumber 的变量，那么可以在子框架里使用 parent.phoneNumber 的方式来引用它。</li></ul><h3 id="常量" tabindex="-1">常量 <a class="header-anchor" href="#常量" aria-label="Permalink to &quot;常量&quot;">​</a></h3><ul><li>可以用关键字 const 创建一个只读的常量。常量标识符的命名规则和变量相同：必须以字母、下划线（_）或美元符号（$）开头并可以包含有字母、数字或下划线。</li><li>常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明。它必须被初始化为某个值。</li><li>常量的<strong>作用域规则与 let 块级作用域变量相同</strong>。若省略 const 关键字，则该标识符将被视为变量。</li><li>在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/wcywxq/image-store/master/ssg/endorsement/javascript/grammar-data-types/1.png" alt="1.png"></p><h2 id="数据结构和类型" tabindex="-1">数据结构和类型 <a class="header-anchor" href="#数据结构和类型" aria-label="Permalink to &quot;数据结构和类型&quot;">​</a></h2><h3 id="_8-种数据类型" tabindex="-1">8 种数据类型 <a class="header-anchor" href="#_8-种数据类型" aria-label="Permalink to &quot;8 种数据类型&quot;">​</a></h3><ul><li>7 种基本数据类型： <ul><li>布尔值（<strong>Boolean</strong>）：有 2 个值分别是：true 和 false。</li><li><strong>null</strong>：一个表明 null 值的特殊关键字。JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。</li><li><strong>undefined</strong>：和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。</li><li>数字（<strong>Number</strong>）：整数或浮点数，例如： 42 或者 3.14159。</li><li>任意精度的整数（<strong>BigInt</strong>）：可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li><li>字符串（<strong>String</strong>）：字符串是一串表示文本值的字符序列，例如：&quot;Howdy&quot;。</li><li>代表（<strong>Symbol</strong>，在 ES6 中新添加的类型）。一种实例是唯一且不可改变的数据类型。</li></ul></li><li>引用数据类型： <ul><li>对象（<strong>Object</strong>）。</li></ul></li></ul><h3 id="存储位置" tabindex="-1">存储位置 <a class="header-anchor" href="#存储位置" aria-label="Permalink to &quot;存储位置&quot;">​</a></h3><ul><li>栈：存放基本数据类型（<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>、<code>Symbol</code>、<code>BigInt</code>）</li></ul><blockquote><p>基本数据类型是直接存储在栈 stack 中的简单数据段，<strong>占据空间小、大小固定</strong>，属于被频繁使用的数据，因此放入栈中存储（在数据结构中，栈中数据的存储方式为先进后出）</p><p>栈是一个优先队列，是按优先级进行排序的，优先级可以按照大小来规定</p></blockquote><ul><li>堆：存放引用数据类型（<code>对象</code>、<code>数组</code>、<code>函数</code>）</li></ul><blockquote><p>引用数据类型是存储在堆 heap 中的对象，<strong>占据空间大、大小不固定</strong>。如果存储在栈中，将会影响程序运行的性能；</p><p>引用数据类型在栈中存储了<strong>指针</strong>，该<strong>指针指向堆中该实体的起始地址</strong>。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p></blockquote><ul><li>在操作系统中，内存被分为<strong>栈区和堆区</strong></li></ul><blockquote><p>栈区：内存由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈</p><p>堆区：内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收</p></blockquote><h2 id="字面量" tabindex="-1">字面量 <a class="header-anchor" href="#字面量" aria-label="Permalink to &quot;字面量&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">数组字面量</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">布尔字面量</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">数字字面量</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">对象字面量</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#regexp_%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">RegExp 字面量</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noreferrer">字符串字面量</a></li></ul>',28),i=[l];function n(s,d,h,c,g,u){return r(),a("div",null,i)}const b=e(o,[["render",n]]);export{m as __pageData,b as default};
